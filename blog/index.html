<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="A Faster Python">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>PyPy</title>
<link href="../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../rss.xml">
<link rel="canonical" href="https://www.pypy.org/blog/">
<link rel="icon" href="../favicon2.ico" sizes="16x16">
<link rel="icon" href="../favicon32x32.ico" sizes="32x32">
<link rel="next" href="index-45.html" type="text/html">
<!--[if lt IE 9]><script src="../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../assets/css/tipuesearch.css">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../index.html">
                    <image id="toplogo" src="../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../compat.html">Compatibility</a> </li>  
                    <li> <a href="../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href=".">Index</a> </li>  
                    <li> <a href="../categories/">Tags</a> </li>  
                    <li> <a href="../archive.html">Archive by year</a> </li>  
                    <li> <a href="../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Search…" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><div class="post">
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2025/12/toy-load-store.html" class="u-url">Load and store forwarding in the Toy Optimizer</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/max-bernstein.html">Max Bernstein</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2025/12/toy-load-store.html" rel="bookmark">
            <time class="published dt-published" datetime="2025-12-24T23:00:00Z" itemprop="datePublished" title="2025-12-24 23:00">2025-12-24 23:00</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>This is a <a href="https://bernsteinbear.com/blog/toy-load-store/" rel="canonical">cross-post</a> from Max Bernstein from his blog where he writes
about programming languages, compilers, optimizations, virtual machines.</p>
<hr>
<p>A long, long time ago (two years!) <a href="https://cfbolz.de/">CF Bolz-Tereick</a> and I made a <a href="https://www.youtube.com/watch?v=w-UHg0yOPSE">video
about load/store forwarding</a> and an accompanying <a href="https://gist.github.com/tekknolagi/4e3fa26d350f6d3b39ede40d372b97fe">GitHub Gist</a>
about load/store forwarding (also called load elimination) in the Toy Optimizer. I
said I would write a blog post about it, but never found the time—it got lost
amid a sea of large life changes.</p>
<p>It's a neat idea: do an abstract interpretation over the trace, modeling the
heap at compile-time, eliminating redundant loads and stores. That means it's
possible to optimize traces like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
<span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">load</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">)</span>
<span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">load</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">load</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="n">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_something</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="p">)</span>
</pre></div>

<p>into traces like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
<span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">load</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">)</span>
<span class="n">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_something</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span>
</pre></div>

<p>(where <code>load(v0, 5)</code> is equivalent to <code>*(v0+5)</code> in C syntax and <code>store(v0, 6,
123)</code> is equvialent to <code>*(v0+6)=123</code> in C syntax)</p>
<p>This indicates that we were able to eliminate two redundant loads by keeping
around information about previous loads and stores. Let's get to work making
this possible.</p>
<h3 id="the-usual-infrastructure">The usual infrastructure</h3>
<p>We'll start off with the usual infrastructure from the <a href="https://pypy.org/categories/toy-optimizer.html">Toy
Optimizer series</a>: a very stringly-typed representation of a
<a href="https://gist.github.com/tekknolagi/4e3fa26d350f6d3b39ede40d372b97fe#file-port-py-L4-L112">trace-based SSA IR</a> and a union-find rewrite mechanism.</p>
<p>This means we can start writing some new optimization pass and our first test:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="c1"># TODO: copy an optimized version of bb into opt_bb</span>
    <span class="k">return</span> <span class="n">opt_bb</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_two_loads</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = load(var0, 0)</span>
<span class="s2">var2 = escape(var1)</span>
<span class="s2">var3 = escape(var1)"""</span>
</pre></div>

<p>This test is asserting that we can remove duplicate loads. Why load twice if we
can cache the result? Let's make that happen.</p>
<h3 id="caching-loads">Caching loads</h3>
<p>To do this, we'll model the the heap at compile-time. When I say "model", I
mean that we will have an imprecise but correct abstract representation of the
heap: we don't (and can't) have knowledge of every value, but we can know for
sure that some addresses have certain values.</p>
<p>For example, if we have observed a load from object <em>O</em> at offset <em>8</em> <code>v0 =
load(O, 8)</code>, we know that the SSA value <code>v0</code> is at <code>heap[(O, 8)]</code>. That sounds
tautological, but it's not. Future loads can make use of this information.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="n">Operation</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">Constant</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

<span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="c1"># Stores things we know about the heap at... compile-time.</span>
    <span class="c1"># Key: an object and an offset pair acting as a heap address</span>
    <span class="c1"># Value: a previous SSA value we know exists at that address</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">load_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">compile_time_heap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">load_info</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">previous</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">op</span><span class="o">.</span><span class="n">make_equal_to</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">compile_time_heap</span><span class="p">[</span><span class="n">load_info</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>This pass records information about loads and uses the result of a previous
cached load operation if available. We treat the pair of (SSA value, offset) as
an address into our abstract heap.</p>
<p>That's great! If you run our simple test, it should now pass. But what happens
if we store into that address before the second load? Oops...</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_store_to_same_object_offset_invalidates_load</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">var3</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var3</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = load(var0, 0)</span>
<span class="s2">var2 = store(var0, 0, 5)</span>
<span class="s2">var3 = load(var0, 0)</span>
<span class="s2">var4 = escape(var1)</span>
<span class="s2">var5 = escape(var3)"""</span>
</pre></div>

<p>This test fails because we are incorrectly keeping around <code>var1</code> in our
abstract heap. We need to get rid of it and not replace <code>var3</code> with <code>var1</code>.</p>
<h3 id="invalidating-cached-loads">Invalidating cached loads</h3>
<p>So it turns out we have to also model stores in order to cache loads correctly.
One valid, albeit aggressive, way to do that is to throw away all the
information we know at each store operation:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">compile_time_heap</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="c1"># ...</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>That makes our test pass—yay!—but at great cost. It means any store
operation mucks up redundant loads. In our world where we frequently read from
and write to objects, this is what we call a huge bummer.</p>
<p>For example, a store to offset 4 on some object should never interfere with a
load from a different offset on the same object<sup id="fnref:size"><a class="footnote-ref" href="../posts/2025/12/toy-load-store.html#fn:size">1</a></sup>. We should be able to
keep our load from offset 0 cached here:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_store_to_same_object_different_offset_does_not_invalidate_load</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">var3</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var3</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = load(var0, 0)</span>
<span class="s2">var2 = store(var0, 4, 5)</span>
<span class="s2">var3 = escape(var1)</span>
<span class="s2">var4 = escape(var1)"""</span>
</pre></div>

<p>We could try instead checking if our specific (object, offset) pair is in the
heap and only removing cached information about that offset and that object.
That would definitely help!</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">load_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">load_info</span> <span class="ow">in</span> <span class="n">compile_time_heap</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">compile_time_heap</span><span class="p">[</span><span class="n">load_info</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="c1"># ...</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>It makes our test pass, too, which is great news.</p>
<p>Unfortunately, this runs into problems due to aliasing: it's entirely possible
that our compile-time heap could contain a pair <code>(v0, 0)</code> and a pair <code>(v1, 0)</code> where <code>v0</code>
and <code>v1</code> are the same object (but not known to the optimizer). Then we might
run into a situation where we incorrectly cache loads because the optimizer
doesn't know our abstract addresses <code>(v0, 0)</code> and <code>(v1, 0)</code> are actually the
same pointer at run-time.</p>
<p>This means that we are breaking abstract interpretation rules: our abstract
interpreter has to correctly model <em>all</em> possible outcomes at run-time. This
means to me that we should instead pick some tactic in-between clearing all
information (correct but over-eager) and clearing only exact matches of
object+offset (incorrect).</p>
<p>The term that will help us here is called an <em>alias class</em>. It is a name for a
way to efficiently partition objects in your abstract heap into completely
disjoint sets. Writes to any object in one class never affect objects in
another class.</p>
<p>Our very scrappy alias classes will be just based on the offset: each offset is
a different alias class. If we write to any object at offset K, we have to
invalidate all of our compile-time offset K knowledge—even if it's for
another object. This is a nice middle ground, and it's possible because our
(made up) object system guarantees that distinct objects do not overlap, and
also that we are not writing out-of-bounds.<sup id="fnref:tbaa"><a class="footnote-ref" href="../posts/2025/12/toy-load-store.html#fn:tbaa">2</a></sup></p>
<p>So let's remove all of the entries from <code>compile_time_heap</code> where the offset
matches the offset in the current <code>store</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">compile_time_heap</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">load_info</span><span class="p">:</span> <span class="n">value</span>
                <span class="k">for</span> <span class="n">load_info</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">compile_time_heap</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">load_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">offset</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="c1"># ...</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>Great! Now our test passes.</p>
<p>This concludes the load optimization section of the post. We have modeled
enough of loads and stores that we can eliminate redundant loads. Very cool.
But we can go further.</p>
<h3 id="caching-stores">Caching stores</h3>
<p>Stores don't just invalidate information. They also give us new information!
Any time we see an operation of the form <code>v1 = store(v0, 8, 5)</code> we also learn
that <code>load(v0, 8) == 5</code>! Until it gets invalidated, anyway.</p>
<p>For example, in this test, we can eliminate the load from <code>var0</code> at offset 0:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_load_after_store_removed</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = store(var0, 0, 5)</span>
<span class="s2">var2 = load(var0, 1)</span>
<span class="s2">var3 = escape(5)</span>
<span class="s2">var4 = escape(var2)"""</span>
</pre></div>

<p>Making that work is thankfully not very hard; we need only add that new
information to the compile-time heap after removing all the
potentially-aliased info:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">compile_time_heap</span> <span class="o">=</span> <span class="c1"># ... as before ...</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">compile_time_heap</span><span class="p">[(</span><span class="n">obj</span><span class="p">,</span> <span class="n">offset</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_value</span>  <span class="c1"># NEW!</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="c1"># ...</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>This makes the test pass. It makes another test fail, but only
because—oops—we now know more. You can delete the old test because the new
test supersedes it.</p>
<p>Now, note that we are not removing the store. This is because we have nothing
in our optimizer that keeps track of what might have observed the side-effects
of the store. What if the object got <code>escape</code>d? Or someone did a load later on?
We would only be able to remove the store (<code>continue</code>) if we could guarantee it
was not observable.</p>
<p>In our current framework, this only happens in one case: someone is doing a
store of the exact same value that already exists in our compile-time heap.
That is, either the same constant, or the same SSA value. If we see this, then
we can completely skip the second store instruction.</p>
<p>Here's a test case for that, where we have gained information from the load
instruction that we can then use to get rid of the store instruction:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_load_then_store</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">arg1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = load(var0, 0)</span>
<span class="s2">var2 = escape(var1)"""</span>
</pre></div>

<p>Let's make it pass. To do that, first we'll make an equality function that
works for both constants and operations. Constants are equal if their values
are equal, and operations are equal if they are the identical (by
address/pointer) operation.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">eq_value</span><span class="p">(</span><span class="n">left</span><span class="p">:</span> <span class="n">Value</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span>
    <span class="k">return</span> <span class="n">left</span> <span class="ow">is</span> <span class="n">right</span>
</pre></div>

<p>This is a partial equality: if two operations are not equal under <code>eq_value</code>,
it doesn't mean that they are different, only that we don't know that they are
the same.</p>
<p>Then, after that, we need only check if the current value in the compile-time
heap is the same as the value being stored in. If it is, wonderful. No need to
store. <code>continue</code> and don't append the operation to <code>opt_bb</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">store_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">current_value</span> <span class="o">=</span> <span class="n">compile_time_heap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">store_info</span><span class="p">)</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">eq_value</span><span class="p">(</span><span class="n">current_value</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>  <span class="c1"># NEW!</span>
                <span class="k">continue</span>
            <span class="n">compile_time_heap</span> <span class="o">=</span> <span class="c1"># ... as before ...</span>
            <span class="c1"># ...</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="n">load_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">load_info</span> <span class="ow">in</span> <span class="n">compile_time_heap</span><span class="p">:</span>
                <span class="n">op</span><span class="o">.</span><span class="n">make_equal_to</span><span class="p">(</span><span class="n">compile_time_heap</span><span class="p">[</span><span class="n">load_info</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="n">compile_time_heap</span><span class="p">[</span><span class="n">load_info</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>This makes our load-then-store pass and it also makes other tests pass too,
like eliminating a store after another store!</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_store_after_store</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">arg1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = store(var0, 0, 5)"""</span>
</pre></div>

<p>Unfortunately, this only works if the values—constants or SSA values—are
known to be the same. If we store <em>different</em> values, we can't optimize. In the
live stream, we left this an exercise for the viewer:</p>
<div class="code"><pre class="code literal-block"><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">xfail</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_exercise_for_the_reader</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">arg0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = store(var0, 0, 7)</span>
<span class="s2">var2 = escape(7)"""</span>
</pre></div>

<p>We would only be able to optimize this away if we had some notion of a store
being <em>dead</em>. In this case, that is a store in which the value is never read
before being overwritten.</p>
<h3 id="removing-dead-stores">Removing dead stores</h3>
<p>TODO, I suppose. I have not gotten this far yet. If I get around to it, I will
come back and update the post.</p>
<h3 id="in-the-real-world">In the real world</h3>
<p>This small optimization pass may seem silly or fiddly—when would we ever see
something like this in a real IR?—but it's pretty useful. Here's the Ruby
code that got me thinking about it again some years later for ZJIT:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">C</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">initialize</span>
<span class="w">    </span><span class="vi">@a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="vi">@b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="vi">@c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>CRuby has a shape system and ZJIT makes use of it, so we end up optimizing this
code (if it's monomorphic) into a series of shape checks and stores. The HIR
might end up looking something like the mess below, where I've annotated the
shape guards (can be thought of as loads) and stores with asterisks:</p>
<div class="code"><pre class="code literal-block"><span class="n">fn</span><span class="w"> </span><span class="n">initialize</span><span class="p">@</span><span class="n">tmp</span><span class="o">/</span><span class="n">init</span><span class="p">.</span><span class="n">rb</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span>
<span class="cp"># ...</span>
<span class="n">bb2</span><span class="p">(</span><span class="n">v6</span><span class="o">:</span><span class="n">BasicObject</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="nl">v10</span><span class="p">:</span><span class="n">Fixnum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">Value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="nl">v31</span><span class="p">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardType</span><span class="w"> </span><span class="n">v6</span><span class="p">,</span><span class="w"> </span><span class="n">HeapBasicObject</span>
<span class="o">*</span><span class="w"> </span><span class="n">v32</span><span class="o">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardShape</span><span class="w"> </span><span class="n">v31</span><span class="p">,</span><span class="w"> </span><span class="mh">0x400000</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v32</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">@</span><span class="n">a</span><span class="mh">@0x10</span><span class="p">,</span><span class="w"> </span><span class="n">v10</span>
<span class="w">  </span><span class="n">WriteBarrier</span><span class="w"> </span><span class="n">v32</span><span class="p">,</span><span class="w"> </span><span class="n">v10</span>
<span class="w">  </span><span class="nl">v35</span><span class="p">:</span><span class="n">CShape</span><span class="p">[</span><span class="mh">0x40008e</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">CShape</span><span class="p">(</span><span class="mh">0x40008e</span><span class="p">)</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v32</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="n">_shape_id</span><span class="mh">@0x4</span><span class="p">,</span><span class="w"> </span><span class="n">v35</span>
<span class="w">  </span><span class="nl">v16</span><span class="p">:</span><span class="n">Fixnum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">Value</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="w">  </span><span class="nl">v37</span><span class="p">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardType</span><span class="w"> </span><span class="n">v6</span><span class="p">,</span><span class="w"> </span><span class="n">HeapBasicObject</span>
<span class="o">*</span><span class="w"> </span><span class="n">v38</span><span class="o">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardShape</span><span class="w"> </span><span class="n">v37</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40008e</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v38</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">@</span><span class="n">b</span><span class="mh">@0x18</span><span class="p">,</span><span class="w"> </span><span class="n">v16</span>
<span class="w">  </span><span class="n">WriteBarrier</span><span class="w"> </span><span class="n">v38</span><span class="p">,</span><span class="w"> </span><span class="n">v16</span>
<span class="w">  </span><span class="nl">v41</span><span class="p">:</span><span class="n">CShape</span><span class="p">[</span><span class="mh">0x40008f</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">CShape</span><span class="p">(</span><span class="mh">0x40008f</span><span class="p">)</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v38</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="n">_shape_id</span><span class="mh">@0x4</span><span class="p">,</span><span class="w"> </span><span class="n">v41</span>
<span class="w">  </span><span class="nl">v22</span><span class="p">:</span><span class="n">Fixnum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">Value</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">  </span><span class="nl">v43</span><span class="p">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardType</span><span class="w"> </span><span class="n">v6</span><span class="p">,</span><span class="w"> </span><span class="n">HeapBasicObject</span>
<span class="o">*</span><span class="w"> </span><span class="n">v44</span><span class="o">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardShape</span><span class="w"> </span><span class="n">v43</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40008f</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v44</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">@</span><span class="n">c</span><span class="mh">@0x20</span><span class="p">,</span><span class="w"> </span><span class="n">v22</span>
<span class="w">  </span><span class="n">WriteBarrier</span><span class="w"> </span><span class="n">v44</span><span class="p">,</span><span class="w"> </span><span class="n">v22</span>
<span class="w">  </span><span class="nl">v47</span><span class="p">:</span><span class="n">CShape</span><span class="p">[</span><span class="mh">0x400090</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">CShape</span><span class="p">(</span><span class="mh">0x400090</span><span class="p">)</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v44</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="n">_shape_id</span><span class="mh">@0x4</span><span class="p">,</span><span class="w"> </span><span class="n">v47</span>
<span class="w">  </span><span class="n">CheckInterrupts</span>
<span class="w">  </span><span class="n">Return</span><span class="w"> </span><span class="n">v22</span>
</pre></div>

<p>If we had store-load forwarding in ZJIT, we could get rid of the intermediate
shape guards; they would know the shape from the previous <code>StoreField</code>
instruction. If we had dead store elimination, we could get rid of the
intermediate shape writes; they are never read. (And the repeated type guards
to check if it's a heap object still are just silly and need to get removed
eventually.)</p>
<p>This is on the roadmap and will make object initialization even faster than it
is right now.</p>
<h3 id="wrapping-up">Wrapping up</h3>
<p>Thanks for reading the text version of the video that CF and I made a while
back. Now you know how to do load/store elimination on traces.</p>
<p>I think this does not need too much extra work to get it going on full CFGs; a
block is pretty much the same as a trace, so you can do a block-local version
without much fuss. If you want to go global, you need dominator information and
gen-kill sets.</p>
<p>Maybe I will touch on this in a future post...</p>
<h3 id="thank-you">Thank you</h3>
<p>Thank you to CF, who walked me through this live on a stream two years ago!
This blog post wouldn't be possible without you.</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:size">
<p>In this toy optimizer example, we are assuming that all reads and writes
are the same size and different offsets don't overlap at all. This is often
the case for managed runtimes, where object fields are pointer-sized and
all reads/writes are pointed aligned. <a class="footnote-backref" href="../posts/2025/12/toy-load-store.html#fnref:size" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:tbaa">
<p>We could do better. If we had type information, we could also use that
to make alias classes. Writes to a List will never overlap with writes to a
Map, for example. This requires your compiler to have strict aliasing—if
you can freely cast between types, as in C, then this tactic goes out the
window.</p>
<p>This is called <a href="../assets/img/tbaa.pdf">Type-based alias analysis</a> (PDF). <a class="footnote-backref" href="../posts/2025/12/toy-load-store.html#fnref:tbaa" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
</ol>
</div>
    </div>
    </article><article class="h-entry post-rst" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2025/07/pypy-v7320-release.html" class="u-url">PyPy v7.3.20 release</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/mattip.html">mattip</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2025/07/pypy-v7320-release.html" rel="bookmark">
            <time class="published dt-published" datetime="2025-07-04T12:00:00Z" itemprop="datePublished" title="2025-07-04 12:00">2025-07-04 12:00</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <section id="pypy-v7-3-20-release-of-python-2-7-3-11"><h2>PyPy v7.3.20: release of python 2.7, 3.11</h2>
<p>The PyPy team is proud to release version 7.3.20 of PyPy after the previous
release on Feb 26, 2025. The release fixes some subtle bugs in ctypes and
<code class="docutils literal">OrderedDict</code> and makes PyPy3.11 compatible with an upcoming release of
Cython.</p>
<p>The release includes two different interpreters:</p>
<ul class="simple">
<li><p>PyPy2.7, which is an interpreter supporting the syntax and the features of
Python 2.7 including the stdlib for CPython 2.7.18+ (the <code class="docutils literal">+</code> is for
backported security updates)</p></li>
<li><p>PyPy3.11, which is an interpreter supporting the syntax and the features of
Python 3.11, including the stdlib for CPython 3.11.13.</p></li>
</ul>
<p>The interpreters are based on much the same codebase, thus the double
release. This is a micro release, all APIs are compatible with the other 7.3
releases.</p>
<p>We recommend updating. You can find links to download the releases here:</p>
<blockquote>
<p><a class="reference external" href="https://pypy.org/download.html">https://pypy.org/download.html</a></p>
</blockquote>
<p>We would like to thank our donors for the continued support of the PyPy
project. If PyPy is not quite good enough for your needs, we are available for
<a class="reference external" href="https://www.pypy.org/pypy-sponsors.html">direct consulting</a> work. If PyPy is helping you out, we would love to hear
about it and encourage submissions to our <a class="reference external" href="https://pypy.org/blog">blog</a> via a pull request
to <a class="reference external" href="https://github.com/pypy/pypy.org">https://github.com/pypy/pypy.org</a></p>
<p>We would also like to thank our contributors and encourage new people to join
the project. PyPy has many layers and we need help with all of them: bug fixes,
<a class="reference external" href="https://doc.pypy.org/">PyPy</a> and <a class="reference external" href="https://rpython.readthedocs.org">RPython</a> documentation improvements, or general <a class="reference external" href="https://doc.pypy.org/en/latest/project-ideas.html">help</a> with
making RPython's JIT even better.</p>
<p>If you are a python library maintainer and use C-extensions, please consider
making a <a class="reference external" href="https://hpyproject.org/">HPy</a> / <a class="reference external" href="https://cffi.readthedocs.io">CFFI</a> / <a class="reference external" href="https://cppyy.readthedocs.io">cppyy</a> version of your library that would be performant
on PyPy. In any case, <a class="reference external" href="https://github.com/joerick/cibuildwheel">cibuildwheel</a> supports building wheels for PyPy.</p>
<section id="what-is-pypy"><h3>What is PyPy?</h3>
<p>PyPy is a Python interpreter, a drop-in replacement for CPython
It's fast (<a class="reference external" href="https://speed.pypy.org">PyPy and CPython</a> performance
comparison) due to its integrated tracing JIT compiler.</p>
<p>We also welcome developers of other <a class="reference external" href="https://rpython.readthedocs.io/en/latest/examples.html">dynamic languages</a> to see what RPython
can do for them.</p>
<p>We provide binary builds for:</p>
<ul class="simple">
<li><p><strong>x86</strong> machines on most common operating systems
(Linux 32/64 bits, Mac OS 64 bits, Windows 64 bits)</p></li>
<li><p>64-bit <strong>ARM</strong> machines running Linux (<code class="docutils literal">aarch64</code>) and macos (<code class="docutils literal">macos_arm64</code>).</p></li>
</ul>
<p>PyPy supports Windows 32-bit, Linux PPC64 big- and little-endian, Linux ARM
32 bit, RISC-V RV64IMAFD Linux, and s390x Linux but does not release binaries.
Please reach out to us if you wish to sponsor binary releases for those
platforms. Downstream packagers provide binary builds for debian, Fedora,
conda, OpenBSD, FreeBSD, Gentoo, and more.</p>
</section><section id="what-else-is-new"><h3>What else is new?</h3>
<p>For more information about the 7.3.20 release, see the <a class="reference external" href="https://doc.pypy.org/en/latest/release-v7.3.20.html#changelog">full changelog</a>.</p>
<p>Please update, and continue to help us make pypy better.</p>
<p>Cheers,
The PyPy Team</p>
</section></section>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2025/06/rpython-gc-allocation-speed.html" class="u-url">How fast can the RPython GC allocate?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/cf-bolz-tereick.html">CF Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2025/06/rpython-gc-allocation-speed.html" rel="bookmark">
            <time class="published dt-published" datetime="2025-06-15T15:48:30+02:00" itemprop="datePublished" title="2025-06-15 15:48">2025-06-15 15:48</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>While working on a paper about <a href="https://pypy.org/posts/2025/02/pypy-gc-sampling.html">allocation profiling in
VMProf</a> I got curious
about how quickly the RPython GC can allocate an object. I wrote a small
RPython benchmark program to get an idea of the order of magnitude.</p>
<p>The basic idea is to just allocate an instance in a tight loop:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
    <span class="c1"># preliminary idea, see below</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
        <span class="n">a</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span>
</pre></div>

<p>The RPython type inference will find out that instances of <code>A</code> have a single
<code>i</code> field, which is an integer. In addition to that field, every RPython object
needs one word of GC meta-information. Therefore one instance of <code>A</code> needs 16
bytes on a 64-bit architecture.</p>
<p>However, measuring like this is not good enough, because the RPython static
optimizer would remove the allocation since the object isn't used. But we can
confuse the escape analysis sufficiently by always keeping two instances alive
at the same time:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
        <span class="n">a</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c1"># print the instances at the end</span>
</pre></div>

<p>(I confirmed that the allocation isn't being removed by looking at the C code
that the RPython compiler generates from this.)</p>
<p>This is doing a little bit more work than needed, because of the <code>a.i = i</code>
instance attribute write. We can also (optionally) leave the field
uninitialized.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">initialize_field</span><span class="p">,</span> <span class="n">loops</span><span class="p">):</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">initialize_field</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
            <span class="n">a</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c1"># make sure always two objects are alive</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">'s'</span><span class="p">)</span>
    <span class="n">object_size_in_words</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># GC header, one integer field</span>
    <span class="n">mem</span> <span class="o">=</span> <span class="n">loops</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">object_size_in_words</span> <span class="o">/</span> <span class="mf">1024.0</span> <span class="o">/</span> <span class="mf">1024.0</span> <span class="o">/</span> <span class="mf">1024.0</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="s1">'GB'</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mem</span> <span class="o">/</span> <span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">),</span> <span class="s1">'GB/s'</span><span class="p">)</span>
</pre></div>

<p>Then we need to add some RPython scaffolding:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="n">loops</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">with_init</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">with_init</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"with initialization"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"without initialization"</span><span class="p">)</span>
    <span class="n">run</span><span class="p">(</span><span class="n">with_init</span><span class="p">,</span> <span class="n">loops</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">target</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">main</span>
</pre></div>

<p>To build a binary:</p>
<div class="code"><pre class="code literal-block"><span class="go">pypy rpython/bin/rpython targetallocatealot.py</span>
</pre></div>

<p>Which will turn the RPython code into C code and use a C compiler to turn that
into a binary, containing both our code above as well as the RPython garbage
collector.</p>
<p>Then we can run it (all results again from my AMD Ryzen 7 PRO 7840U, running
Ubuntu Linux 24.04.2):</p>
<div class="code"><pre class="code literal-block"><span class="gp">$ </span>./targetallocatealot-c<span class="w"> </span><span class="m">1000000000</span><span class="w"> </span><span class="m">0</span>
<span class="go">without initialization</span>
<span class="go">&lt;A object at 0x7c71ad84cf60&gt; &lt;A object at 0x7c71ad84cf70&gt;</span>
<span class="go">0.433825 s</span>
<span class="go">14.901161 GB</span>
<span class="go">34.348322 GB/s</span>
<span class="gp">$ </span>./targetallocatealot-c<span class="w"> </span><span class="m">1000000000</span><span class="w"> </span><span class="m">1</span>
<span class="go">with initialization</span>
<span class="go">&lt;A object at 0x71b41c82cf60&gt; &lt;A object at 0x71b41c82cf70&gt;</span>
<span class="go">0.501856 s</span>
<span class="go">14.901161 GB</span>
<span class="go">29.692100 GB/s</span>
</pre></div>

<p>Let's compare it with the Boehm GC:</p>
<div class="code"><pre class="code literal-block"><span class="gp">$ </span>pypy<span class="w"> </span>rpython/bin/rpython<span class="w"> </span>--gc<span class="o">=</span>boehm<span class="w"> </span>--output<span class="o">=</span>targetallocatealot-c-boehm<span class="w"> </span>targetallocatealot.py<span class="w"> </span>
<span class="go">...</span>
<span class="gp">$ </span>./targetallocatealot-c-boehm<span class="w"> </span><span class="m">1000000000</span><span class="w"> </span><span class="m">0</span>
<span class="go">without initialization</span>
<span class="go">&lt;A object at 0xffff8bd058a6e3af&gt; &lt;A object at 0xffff8bd058a6e3bf&gt;</span>
<span class="go">9.722585 s</span>
<span class="go">14.901161 GB</span>
<span class="go">1.532634 GB/s</span>
<span class="gp">$ </span>./targetallocatealot-c-boehm<span class="w"> </span><span class="m">1000000000</span><span class="w"> </span><span class="m">1</span>
<span class="go">with initialization</span>
<span class="go">&lt;A object at 0xffff88e1132983af&gt; &lt;A object at 0xffff88e1132983bf&gt;</span>
<span class="go">9.684149 s</span>
<span class="go">14.901161 GB</span>
<span class="go">1.538717 GB/s</span>
</pre></div>

<p>This is not a fair comparison, because the Boehm GC uses conservative stack
scanning, therefore it cannot move objects, which requires much more
complicated allocation.</p>
<h3 id="lets-look-at-perf-stats">Let's look at <code>perf stats</code>
</h3>
<p>We can use <code>perf</code> to get some statistics about the executions:</p>
<div class="code"><pre class="code literal-block"><span class="gp">$ </span>perf<span class="w"> </span>stat<span class="w"> </span>-e<span class="w"> </span>cache-references,cache-misses,cycles,instructions,branches,faults,migrations<span class="w"> </span>./targetallocatealot-c<span class="w"> </span><span class="m">10000000000</span><span class="w"> </span><span class="m">0</span>
<span class="go">without initialization</span>
<span class="go">&lt;A object at 0x7aa260e35980&gt; &lt;A object at 0x7aa260e35990&gt;</span>
<span class="go">4.301442 s</span>
<span class="go">149.011612 GB</span>
<span class="go">34.642245 GB/s</span>

<span class="go"> Performance counter stats for './targetallocatealot-c 10000000000 0':</span>

<span class="go">     7,244,117,828      cache-references                                                      </span>
<span class="go">        23,446,661      cache-misses                     #    0.32% of all cache refs         </span>
<span class="go">    21,074,240,395      cycles                                                                </span>
<span class="go">   110,116,790,943      instructions                     #    5.23  insn per cycle            </span>
<span class="go">    20,024,347,488      branches                                                              </span>
<span class="go">             1,287      faults                                                                </span>
<span class="go">                24      migrations                                                            </span>

<span class="go">       4.303071693 seconds time elapsed</span>

<span class="go">       4.297557000 seconds user</span>
<span class="go">       0.003998000 seconds sys</span>

<span class="gp">$ </span>perf<span class="w"> </span>stat<span class="w"> </span>-e<span class="w"> </span>cache-references,cache-misses,cycles,instructions,branches,faults,migrations<span class="w"> </span>./targetallocatealot-c<span class="w"> </span><span class="m">10000000000</span><span class="w"> </span><span class="m">1</span>
<span class="go">with initialization</span>
<span class="go">&lt;A object at 0x77ceb0235980&gt; &lt;A object at 0x77ceb0235990&gt;</span>
<span class="go">5.016772 s</span>
<span class="go">149.011612 GB</span>
<span class="go">29.702688 GB/s</span>

<span class="go"> Performance counter stats for './targetallocatealot-c 10000000000 1':</span>

<span class="go">     7,571,461,470      cache-references                                                      </span>
<span class="go">       241,915,266      cache-misses                     #    3.20% of all cache refs         </span>
<span class="go">    24,503,497,532      cycles                                                                </span>
<span class="go">   130,126,387,460      instructions                     #    5.31  insn per cycle            </span>
<span class="go">    20,026,280,693      branches                                                              </span>
<span class="go">             1,285      faults                                                                </span>
<span class="go">                21      migrations                                                            </span>

<span class="go">       5.019444749 seconds time elapsed</span>

<span class="go">       5.012924000 seconds user</span>
<span class="go">       0.005999000 seconds sys</span>
</pre></div>

<p>This is pretty cool, we can run this loop with &gt;5 instructions per cycle. Every
allocation takes <code>110116790943 / 10000000000 ≈ 11</code> instructions and
<code>21074240395 / 10000000000 ≈ 2.1</code> cycles, including the loop around it.</p>
<h3 id="how-often-does-the-gc-run">How often does the GC run?</h3>
<p>The RPython GC queries the L2 cache size to determine the size of the nursery.
We can find out what it is by turning on PYPYLOG, selecting the proper logging
categories, and printing to <code>stdout</code> via <code>:-</code>:</p>
<div class="code"><pre class="code literal-block"><span class="gp">$ </span><span class="nv">PYPYLOG</span><span class="o">=</span>gc-set-nursery-size,gc-hardware:-<span class="w"> </span>./targetallocatealot-c<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="go">[f3e6970465723] {gc-set-nursery-size</span>
<span class="go">nursery size: 270336</span>
<span class="go">[f3e69704758f3] gc-set-nursery-size}</span>
<span class="go">[f3e697047b9a1] {gc-hardware</span>
<span class="go">L2cache = 1048576</span>
<span class="go">[f3e69705ced19] gc-hardware}</span>
<span class="go">[f3e69705d11b5] {gc-hardware</span>
<span class="go">memtotal = 32274210816.000000</span>
<span class="go">[f3e69705f4948] gc-hardware}</span>
<span class="go">[f3e6970615f78] {gc-set-nursery-size</span>
<span class="go">nursery size: 4194304</span>
<span class="go">[f3e697061ecc0] gc-set-nursery-size}</span>
<span class="go">with initialization</span>
<span class="go">NULL &lt;A object at 0x7fa7b1434020&gt;</span>
<span class="go">0.000008 s</span>
<span class="go">0.000000 GB</span>
<span class="go">0.001894 GB/s</span>
</pre></div>

<p>So the nursery is 4 MiB. This means that when we allocate 14.9 GiB the GC needs to perform <code>10000000000 * 16 / 4194304 ≈ 38146</code> minor collections. Let's confirm that:</p>
<div class="code"><pre class="code literal-block"><span class="gp">$ </span><span class="nv">PYPYLOG</span><span class="o">=</span>gc-minor:out<span class="w"> </span>./targetallocatealot-c<span class="w"> </span><span class="m">10000000000</span><span class="w"> </span><span class="m">1</span>
<span class="go">with initialization</span>
<span class="go">w&lt;A object at 0x7991e3835980&gt; &lt;A object at 0x7991e3835990&gt;</span>
<span class="go">5.315511 s</span>
<span class="go">149.011612 GB</span>
<span class="go">28.033356 GB/s</span>
<span class="gp">$ </span>head<span class="w"> </span>out
<span class="go">[f3ee482f4cd97] {gc-minor</span>
<span class="go">[f3ee482f53874] {gc-minor-walkroots</span>
<span class="go">[f3ee482f54117] gc-minor-walkroots}</span>
<span class="go">minor collect, total memory used: 0</span>
<span class="go">number of pinned objects: 0</span>
<span class="go">total size of surviving objects: 0</span>
<span class="go">time taken: 0.000029</span>
<span class="go">[f3ee482f67b7e] gc-minor}</span>
<span class="go">[f3ee4838097c5] {gc-minor</span>
<span class="go">[f3ee48380c945] {gc-minor-walkroots</span>
<span class="gp">$ </span>grep<span class="w"> </span><span class="s2">"{gc-minor-walkroots"</span><span class="w"> </span>out<span class="w"> </span><span class="p">|</span><span class="w"> </span>wc<span class="w"> </span>-l
<span class="go">38147</span>
</pre></div>

<p>Each minor collection is very quick, because a minor collection is
O(surviving objects), and in this program only one object survive each time
(the other instance is in the process of being allocated).
Also, the GC root shadow stack is only one entry, so walking that is super
quick as well. The time the minor collections take is logged to the out file:</p>
<div class="code"><pre class="code literal-block"><span class="gp">$ </span>grep<span class="w"> </span><span class="s2">"time taken"</span><span class="w"> </span>out<span class="w"> </span><span class="p">|</span><span class="w"> </span>tail
<span class="go">time taken: 0.000002</span>
<span class="go">time taken: 0.000002</span>
<span class="go">time taken: 0.000002</span>
<span class="go">time taken: 0.000002</span>
<span class="go">time taken: 0.000002</span>
<span class="go">time taken: 0.000002</span>
<span class="go">time taken: 0.000002</span>
<span class="go">time taken: 0.000003</span>
<span class="go">time taken: 0.000002</span>
<span class="go">time taken: 0.000002</span>
<span class="gp">$ </span>grep<span class="w"> </span><span class="s2">"time taken"</span><span class="w"> </span>out<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-o<span class="w"> </span><span class="s2">"0.*"</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>numsum
<span class="go">0.0988160000000011</span>
</pre></div>

<p>(This number is super approximate due to float formatting rounding.)</p>
<p>that means that <code>0.0988160000000011 / 5.315511 ≈ 2%</code> of the time is spent in the GC.</p>
<h3 id="what-does-the-generated-machine-code-look-like">What does the generated machine code look like?</h3>
<p>The allocation fast path of the RPython GC is a simple bump pointer, in Python
pseudo-code it would look roughly like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">result</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span>
<span class="c1"># Move nursery_free pointer forward by totalsize</span>
<span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">totalsize</span>
<span class="c1"># Check if this allocation would exceed the nursery</span>
<span class="k">if</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span> <span class="o">&gt;</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_top</span><span class="p">:</span>
    <span class="c1"># If it does =&gt; collect the nursery and al</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">collect_and_reserve</span><span class="p">(</span><span class="n">totalsize</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">hdr</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GC</span> <span class="n">flags</span> <span class="ow">and</span> <span class="nb">type</span> <span class="nb">id</span> <span class="n">of</span> <span class="n">A</span><span class="o">&gt;</span>
</pre></div>

<p>So we can disassemble the compiled binary <code>targetallocatealot-c</code> and try to
find the equivalent logic in machine code. I'm super bad at reading machine
code, but I tried to annotate what I think is the core loop (the version
without initializing the <code>i</code> field) below:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="nl">cb68</span><span class="p">:</span><span class="w">   </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">rbx</span><span class="p">,</span><span class="o">%</span><span class="n">rdi</span><span class="w"> </span>
<span class="w">    </span><span class="nl">cb6b</span><span class="p">:</span><span class="w">   </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">rdx</span><span class="p">,</span><span class="o">%</span><span class="n">rbx</span>

<span class="w">    </span><span class="cp"># initialize object header of object allocated in previous iteration</span>
<span class="w">    </span><span class="nl">cb6e</span><span class="p">:</span><span class="w">   </span><span class="n">movq</span><span class="w">   </span><span class="n">$0x4c8</span><span class="p">,(</span><span class="o">%</span><span class="n">rbx</span><span class="p">)</span>

<span class="w">    </span><span class="cp"># loop termination check</span>
<span class="w">    </span><span class="nl">cb75</span><span class="p">:</span><span class="w">   </span><span class="n">cmp</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span><span class="p">,</span><span class="o">%</span><span class="n">r12</span>
<span class="w">    </span><span class="nl">cb78</span><span class="p">:</span><span class="w">   </span><span class="n">je</span><span class="w">     </span><span class="n">ccb8</span>

<span class="w">    </span><span class="cp"># load nursery_free</span>
<span class="w">    </span><span class="nl">cb7e</span><span class="p">:</span><span class="w">   </span><span class="n">mov</span><span class="w">    </span><span class="mh">0x33c13</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">rdx</span>

<span class="w">    </span><span class="cp"># increment loop counter</span>
<span class="w">    </span><span class="nl">cb85</span><span class="p">:</span><span class="w">   </span><span class="n">add</span><span class="w">    </span><span class="n">$0x1</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>

<span class="w">    </span><span class="cp"># add 16 (size of object) to nursery_free</span>
<span class="w">    </span><span class="nl">cb89</span><span class="p">:</span><span class="w">   </span><span class="n">lea</span><span class="w">    </span><span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="n">rdx</span><span class="p">),</span><span class="o">%</span><span class="n">rax</span>

<span class="w">    </span><span class="cp"># compare nursery_top with new nursery_free</span>
<span class="w">    </span><span class="nl">cb8d</span><span class="p">:</span><span class="w">   </span><span class="n">cmp</span><span class="w">    </span><span class="o">%</span><span class="n">rax</span><span class="p">,</span><span class="mh">0x33c24</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>

<span class="w">    </span><span class="cp"># store new nursery_free</span>
<span class="w">    </span><span class="nl">cb94</span><span class="p">:</span><span class="w">   </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">rax</span><span class="p">,</span><span class="mh">0x33bfd</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>

<span class="w">    </span><span class="cp"># if new nursery_free exceeds nursery_top, fall through to slow path, if not, start at top</span>
<span class="w">    </span><span class="nl">cb9b</span><span class="p">:</span><span class="w">   </span><span class="n">jae</span><span class="w">    </span><span class="n">cb68</span>

<span class="w">    </span><span class="cp"># slow path from here on:</span>
<span class="w">    </span><span class="cp"># save live object from last iteration to GC shadow stack</span>
<span class="w">    </span><span class="nl">cb9d</span><span class="p">:</span><span class="w">   </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">rbx</span><span class="p">,</span><span class="mh">-0x8</span><span class="p">(</span><span class="o">%</span><span class="n">rcx</span><span class="p">)</span>
<span class="w">    </span><span class="nl">cba1</span><span class="p">:</span><span class="w">   </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">r13</span><span class="p">,</span><span class="o">%</span><span class="n">rdi</span>
<span class="w">    </span><span class="nl">cba4</span><span class="p">:</span><span class="w">   </span><span class="n">mov</span><span class="w">    </span><span class="n">$0x10</span><span class="p">,</span><span class="o">%</span><span class="n">esi</span>
<span class="w">    </span><span class="cp"># do minor collection</span>
<span class="w">    </span><span class="nl">cba9</span><span class="p">:</span><span class="w">   </span><span class="n">call</span><span class="w">   </span><span class="mi">20800</span><span class="w"> </span><span class="o">&lt;</span><span class="n">pypy_g_IncrementalMiniMarkGC_collect_and_reserve</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">...</span>
</pre></div>

<h3 id="running-the-benchmark-as-regular-python-code">Running the benchmark as regular Python code</h3>
<p>So far we ran this code as <em>RPython</em>, i.e. type inference is performed and the
program is translated to a C binary. We can also run it on top of PyPy, as a
regular Python3 program. However, an instance of a user-defined class in regular
Python when run on PyPy is actually a much larger object, due to <a href="https://pypy.org/posts/2010/11/efficiently-implementing-python-objects-3838329944323946932.html">dynamic
typing</a>.
It's at least 7 words, which is 56 bytes.</p>
<p>However, we can simply use <code>int</code> objects instead. Integers are allocated on the
heap and consist of two words, one for the GC and one with the
machine-word-sized integer value, if the integer fits into a signed 64-bit
representation (otherwise a less compact different representation is used,
which can represent arbitrarily large integers).</p>
<p>Therefore, we can simply use this kind of code:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span><span class="o">,</span><span class="w"> </span><span class="nn">time</span>


<span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">i</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c1"># make sure always two objects are alive</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">object_size_in_words</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># GC header, one integer field</span>
    <span class="n">mem</span> <span class="o">=</span> <span class="n">loops</span> <span class="o">*</span> <span class="mi">28</span> <span class="o">/</span> <span class="mf">1024.0</span> <span class="o">/</span> <span class="mf">1024.0</span> <span class="o">/</span> <span class="mf">1024.0</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="s1">'GB'</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mem</span> <span class="o">/</span> <span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">),</span> <span class="s1">'GB/s'</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="n">loops</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">run</span><span class="p">(</span><span class="n">loops</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">))</span>
</pre></div>

<p>In this case we can't really leave the value uninitialized though.</p>
<p>We can run this both with and without the JIT:</p>
<div class="code"><pre class="code literal-block"><span class="gp">$ </span>pypy3<span class="w"> </span>allocatealot.py<span class="w"> </span><span class="m">1000000000</span>
<span class="go">999999998 999999999</span>
<span class="go">14.901161193847656 GB</span>
<span class="go">17.857494904899553 GB/s</span>
<span class="gp">$ </span>pypy3<span class="w"> </span>--jit<span class="w"> </span>off<span class="w"> </span>allocatealot.py<span class="w"> </span><span class="m">1000000000</span>
<span class="go">999999998 999999999</span>
<span class="go">14.901161193847656 GB</span>
<span class="go">0.8275382375297171 GB/s</span>
</pre></div>

<p>This is obviously much less efficient than the C code, the PyPy JIT generates
much less efficient machine code than GCC. Still, "only" twice as slow is kind
of cool anyway.</p>
<p>(Running it with CPython doesn't really make sense for this measurements, since
CPython ints are bigger – <code>sys.getsizeof(5)</code> reports 28 bytes.)</p>
<h3 id="the-machine-code-that-the-jit-generates">The machine code that the JIT generates</h3>
<p>Unfortunately it's a bit of a journey to show the machine code that PyPy's JIT generates for this. First we need to run with all jit logging categories:</p>
<div class="code"><pre class="code literal-block"><span class="gp">$ </span><span class="nv">PYPYLOG</span><span class="o">=</span>jit:out<span class="w"> </span>pypy3<span class="w"> </span>allocatealot.py<span class="w"> </span><span class="m">1000000000</span>
</pre></div>

<p>Then we can read the log file to find the trace IR for the loop under the logging category <code>jit-log-opt</code>:</p>
<div class="code"><pre class="code literal-block"><span class="o">+</span><span class="mi">532</span><span class="p">:</span><span class="w"> </span><span class="n">label</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p6</span><span class="p">,</span><span class="w"> </span><span class="n">p9</span><span class="p">,</span><span class="w"> </span><span class="n">p11</span><span class="p">,</span><span class="w"> </span><span class="n">i34</span><span class="p">,</span><span class="w"> </span><span class="n">p13</span><span class="p">,</span><span class="w"> </span><span class="n">p19</span><span class="p">,</span><span class="w"> </span><span class="n">p21</span><span class="p">,</span><span class="w"> </span><span class="n">p23</span><span class="p">,</span><span class="w"> </span><span class="n">p25</span><span class="p">,</span><span class="w"> </span><span class="n">p29</span><span class="p">,</span><span class="w"> </span><span class="n">p31</span><span class="p">,</span><span class="w"> </span><span class="n">i44</span><span class="p">,</span><span class="w"> </span><span class="n">i35</span><span class="p">,</span><span class="w"> </span><span class="n">descr</span><span class="o">=</span><span class="n">TargetToken</span><span class="p">(</span><span class="mi">137358545605472</span><span class="p">))</span>
<span class="n">debug_merge_point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">'run;/home/cfbolz/projects/gitpypy/allocatealot.py:6-9~#24 FOR_ITER'</span><span class="p">)</span>

<span class="c1"># are we at the end of the loop</span>
<span class="o">+</span><span class="mi">552</span><span class="p">:</span><span class="w"> </span><span class="n">i45</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int_lt</span><span class="p">(</span><span class="n">i44</span><span class="p">,</span><span class="w"> </span><span class="n">i35</span><span class="p">)</span>
<span class="o">+</span><span class="mi">555</span><span class="p">:</span><span class="w"> </span><span class="n">guard_true</span><span class="p">(</span><span class="n">i45</span><span class="p">,</span><span class="w"> </span><span class="n">descr</span><span class="o">=&lt;</span><span class="n">Guard0x7ced4756a160</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p6</span><span class="p">,</span><span class="w"> </span><span class="n">p9</span><span class="p">,</span><span class="w"> </span><span class="n">p11</span><span class="p">,</span><span class="w"> </span><span class="n">p13</span><span class="p">,</span><span class="w"> </span><span class="n">p19</span><span class="p">,</span><span class="w"> </span><span class="n">p21</span><span class="p">,</span><span class="w"> </span><span class="n">p23</span><span class="p">,</span><span class="w"> </span><span class="n">p25</span><span class="p">,</span><span class="w"> </span><span class="n">p29</span><span class="p">,</span><span class="w"> </span><span class="n">p31</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">i44</span><span class="p">,</span><span class="w"> </span><span class="n">i35</span><span class="p">,</span><span class="w"> </span><span class="n">i34</span><span class="p">]</span>
<span class="o">+</span><span class="mi">561</span><span class="p">:</span><span class="w"> </span><span class="n">i47</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int_add</span><span class="p">(</span><span class="n">i44</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">debug_merge_point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">'run;/home/cfbolz/projects/gitpypy/allocatealot.py:6-9~#26 STORE_FAST'</span><span class="p">)</span>
<span class="n">debug_merge_point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">'run;/home/cfbolz/projects/gitpypy/allocatealot.py:6-10~#28 LOAD_FAST'</span><span class="p">)</span>
<span class="n">debug_merge_point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">'run;/home/cfbolz/projects/gitpypy/allocatealot.py:6-10~#30 STORE_FAST'</span><span class="p">)</span>
<span class="n">debug_merge_point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">'run;/home/cfbolz/projects/gitpypy/allocatealot.py:6-11~#32 LOAD_FAST'</span><span class="p">)</span>
<span class="n">debug_merge_point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">'run;/home/cfbolz/projects/gitpypy/allocatealot.py:6-11~#34 STORE_FAST'</span><span class="p">)</span>
<span class="n">debug_merge_point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">'run;/home/cfbolz/projects/gitpypy/allocatealot.py:6-11~#36 JUMP_ABSOLUTE'</span><span class="p">)</span>

<span class="c1"># update iterator object</span>
<span class="o">+</span><span class="mi">565</span><span class="p">:</span><span class="w"> </span><span class="n">setfield_gc</span><span class="p">(</span><span class="n">p25</span><span class="p">,</span><span class="w"> </span><span class="n">i47</span><span class="p">,</span><span class="w"> </span><span class="n">descr</span><span class="o">=&lt;</span><span class="n">FieldS</span><span class="w"> </span><span class="n">pypy</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">__builtin__</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">W_IntRangeIterator</span><span class="o">.</span><span class="n">inst_current</span><span class="w"> </span><span class="mi">8</span><span class="o">&gt;</span><span class="p">)</span>
<span class="o">+</span><span class="mi">569</span><span class="p">:</span><span class="w"> </span><span class="n">guard_not_invalidated</span><span class="p">(</span><span class="n">descr</span><span class="o">=&lt;</span><span class="n">Guard0x7ced4756a1b0</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p6</span><span class="p">,</span><span class="w"> </span><span class="n">p9</span><span class="p">,</span><span class="w"> </span><span class="n">p11</span><span class="p">,</span><span class="w"> </span><span class="n">p19</span><span class="p">,</span><span class="w"> </span><span class="n">p21</span><span class="p">,</span><span class="w"> </span><span class="n">p23</span><span class="p">,</span><span class="w"> </span><span class="n">p25</span><span class="p">,</span><span class="w"> </span><span class="n">p29</span><span class="p">,</span><span class="w"> </span><span class="n">p31</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">i44</span><span class="p">,</span><span class="w"> </span><span class="n">i34</span><span class="p">]</span>

<span class="c1"># check for signals</span>
<span class="o">+</span><span class="mi">569</span><span class="p">:</span><span class="w"> </span><span class="n">i49</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getfield_raw_i</span><span class="p">(</span><span class="mi">137358624889824</span><span class="p">,</span><span class="w"> </span><span class="n">descr</span><span class="o">=&lt;</span><span class="n">FieldS</span><span class="w"> </span><span class="n">pypysig_long_struct_inner</span><span class="o">.</span><span class="n">c_value</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span><span class="p">)</span>
<span class="o">+</span><span class="mi">582</span><span class="p">:</span><span class="w"> </span><span class="n">i51</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int_lt</span><span class="p">(</span><span class="n">i49</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="o">+</span><span class="mi">586</span><span class="p">:</span><span class="w"> </span><span class="n">guard_false</span><span class="p">(</span><span class="n">i51</span><span class="p">,</span><span class="w"> </span><span class="n">descr</span><span class="o">=&lt;</span><span class="n">Guard0x7ced4754db78</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p6</span><span class="p">,</span><span class="w"> </span><span class="n">p9</span><span class="p">,</span><span class="w"> </span><span class="n">p11</span><span class="p">,</span><span class="w"> </span><span class="n">p19</span><span class="p">,</span><span class="w"> </span><span class="n">p21</span><span class="p">,</span><span class="w"> </span><span class="n">p23</span><span class="p">,</span><span class="w"> </span><span class="n">p25</span><span class="p">,</span><span class="w"> </span><span class="n">p29</span><span class="p">,</span><span class="w"> </span><span class="n">p31</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">i44</span><span class="p">,</span><span class="w"> </span><span class="n">i34</span><span class="p">]</span>
<span class="n">debug_merge_point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">'run;/home/cfbolz/projects/gitpypy/allocatealot.py:6-9~#24 FOR_ITER'</span><span class="p">)</span>

<span class="c1"># allocate the integer (allocation sunk to the end of the trace)</span>
<span class="o">+</span><span class="mi">592</span><span class="p">:</span><span class="w"> </span><span class="n">p52</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_with_vtable</span><span class="p">(</span><span class="n">descr</span><span class="o">=&lt;</span><span class="n">SizeDescr</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;</span><span class="p">)</span>
<span class="o">+</span><span class="mi">630</span><span class="p">:</span><span class="w"> </span><span class="n">setfield_gc</span><span class="p">(</span><span class="n">p52</span><span class="p">,</span><span class="w"> </span><span class="n">i34</span><span class="p">,</span><span class="w"> </span><span class="n">descr</span><span class="o">=&lt;</span><span class="n">FieldS</span><span class="w"> </span><span class="n">pypy</span><span class="o">.</span><span class="n">objspace</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">intobject</span><span class="o">.</span><span class="n">W_IntObject</span><span class="o">.</span><span class="n">inst_intval</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">pure</span><span class="o">&gt;</span><span class="p">)</span>
<span class="o">+</span><span class="mi">634</span><span class="p">:</span><span class="w"> </span><span class="n">jump</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p6</span><span class="p">,</span><span class="w"> </span><span class="n">p9</span><span class="p">,</span><span class="w"> </span><span class="n">p11</span><span class="p">,</span><span class="w"> </span><span class="n">i44</span><span class="p">,</span><span class="w"> </span><span class="n">p52</span><span class="p">,</span><span class="w"> </span><span class="n">p19</span><span class="p">,</span><span class="w"> </span><span class="n">p21</span><span class="p">,</span><span class="w"> </span><span class="n">p23</span><span class="p">,</span><span class="w"> </span><span class="n">p25</span><span class="p">,</span><span class="w"> </span><span class="n">p29</span><span class="p">,</span><span class="w"> </span><span class="n">p31</span><span class="p">,</span><span class="w"> </span><span class="n">i47</span><span class="p">,</span><span class="w"> </span><span class="n">i35</span><span class="p">,</span><span class="w"> </span><span class="n">descr</span><span class="o">=</span><span class="n">TargetToken</span><span class="p">(</span><span class="mi">137358545605472</span><span class="p">))</span>
</pre></div>

<p>To find the machine code address of the trace, we need to search for this line:</p>
<div class="code"><pre class="code literal-block"><span class="nx">Loop</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nx">run</span><span class="p">;</span><span class="o">/</span><span class="nx">home</span><span class="o">/</span><span class="nx">cfbolz</span><span class="o">/</span><span class="nx">projects</span><span class="o">/</span><span class="nx">gitpypy</span><span class="o">/</span><span class="nx">allocatealot</span><span class="p">.</span><span class="nx">py</span><span class="p">:</span><span class="mi">6</span><span class="o">-</span><span class="mi">9</span><span class="o">~</span><span class="err">#</span><span class="mi">24</span><span class="w"> </span><span class="nx">FOR_ITER</span><span class="p">)</span><span class="w"> </span>\
<span class="w">    </span><span class="nx">has</span><span class="w"> </span><span class="nx">address</span><span class="w"> </span><span class="mh">0x7ced473ffa0b</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mh">0x7ced473ffbb0</span><span class="w"> </span><span class="p">(</span><span class="nx">bootstrap</span><span class="w"> </span><span class="mh">0x7ced473ff980</span><span class="p">)</span>
</pre></div>

<p>Then we can use a script in the PyPy repo to disassemble the generated machine code:</p>
<div class="code"><pre class="code literal-block"><span class="gp">$ </span>pypy<span class="w"> </span>rpython/jit/backend/tool/viewcode.py<span class="w"> </span>out
</pre></div>

<p>This will dump all the machine code to stdout, and open a <a href="https://pypy.org/posts/2021/04/ways-pypy-graphviz.html">pygame-based
graphviz cfg</a>. In there
we can search for the address and see this:</p>
<p><img alt="Graphviz based visualization of the machine code the JIT generates" src="../images/2025-allocatealot-machine-code.png"></p>
<p>Here's an annotated version with what I think this code does:</p>
<div class="code"><pre class="code literal-block"><span class="x"># increment the profile counter</span>
<span class="x">7ced473ffb40:   48 ff 04 25 20 9e 33    incq   0x38339e20</span>
<span class="x">7ced473ffb47:   38 </span>

<span class="x"># check whether the loop is done</span>
<span class="x">7ced473ffb48:   4c 39 fe                cmp    %r15,%rsi</span>
<span class="x">7ced473ffb4b:   0f 8d 76 01 00 00       jge    0x7ced473ffcc7</span>

<span class="x"># increment iteration variable</span>
<span class="x">7ced473ffb51:   4c 8d 66 01             lea    0x1(%rsi),%r12</span>

<span class="x"># update iterator object</span>
<span class="x">7ced473ffb55:   4d 89 61 08             mov    %r12,0x8(%r9)</span>

<span class="x"># check for ctrl-c/thread switch</span>
<span class="x">7ced473ffb59:   49 bb e0 1b 0b 4c ed    movabs $0x7ced4c0b1be0,%r11</span>
<span class="x">7ced473ffb60:   7c 00 00 </span>
<span class="x">7ced473ffb63:   49 8b 0b                mov    (%r11),%rcx</span>
<span class="x">7ced473ffb66:   48 83 f9 00             cmp    $0x0,%rcx</span>
<span class="x">7ced473ffb6a:   0f 8c 8f 01 00 00       jl     0x7ced473ffcff</span>

<span class="x"># load nursery_free pointer</span>
<span class="x">7ced473ffb70:   49 8b 8b d8 30 f6 fe    mov    -0x109cf28(%r11),%rcx</span>

<span class="x"># add size (16)</span>
<span class="x">7ced473ffb77:   48 8d 51 10             lea    0x10(%rcx),%rdx</span>

<span class="x"># compare against nursery top</span>
<span class="x">7ced473ffb7b:   49 3b 93 f8 30 f6 fe    cmp    -0x109cf08(%r11),%rdx</span>

<span class="x"># jump to slow path if nursery is full</span>
<span class="x">7ced473ffb82:   0f 87 41 00 00 00       ja     0x7ced473ffbc9</span>

<span class="x"># store new value of nursery free</span>
<span class="x">7ced473ffb88:   49 89 93 d8 30 f6 fe    mov    %rdx,-0x109cf28(%r11)</span>

<span class="x"># initialize GC header</span>
<span class="x">7ced473ffb8f:   48 c7 01 30 11 00 00    movq   $0x1130,(%rcx)</span>

<span class="x"># initialize integer field</span>
<span class="x">7ced473ffb96:   48 89 41 08             mov    %rax,0x8(%rcx)</span>
<span class="x">7ced473ffb9a:   48 89 f0                mov    %rsi,%rax</span>
<span class="x">7ced473ffb9d:   48 89 8d 60 01 00 00    mov    %rcx,0x160(%rbp)</span>
<span class="x">7ced473ffba4:   4c 89 e6                mov    %r12,%rsi</span>
<span class="x">7ced473ffba7:   e9 94 ff ff ff          jmp    0x7ced473ffb40</span>
<span class="x">7ced473ffbac:   0f 1f 40 00             nopl   0x0(%rax)</span>
</pre></div>

<h3 id="conclusion">Conclusion</h3>
<p>The careful design of the RPython GC's allocation fast path gives pretty good
allocation rates. This technique isn't really new, it's a pretty typical way to
design a GC. Apart from that, my main conclusion would be that computers are
fast or something? Indeed, when we ran the same code on my colleague's
two-year-old AMD, we got quite a bit worse results, so a lot of the speed seems
to be due to the hard work of CPU architects.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2025/04/prospero-in-rpython.html" class="u-url">Doing the Prospero-Challenge in RPython</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/cf-bolz-tereick.html">CF Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2025/04/prospero-in-rpython.html" rel="bookmark">
            <time class="published dt-published" datetime="2025-04-09T15:07:09Z" itemprop="datePublished" title="2025-04-09 15:07">2025-04-09 15:07</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>Recently I had a lot of fun playing with the <a href="https://www.mattkeeter.com/projects/prospero/">Prospero
Challenge</a> by <a href="https://www.mattkeeter.com/">Matt
Keeter</a>. The challenge is to render a 1024x1024 image of
a quote from The Tempest by Shakespeare. The input is a mathematical formula
with 7866 operations, which is evaluated once per pixel.</p>
<p>What made the challenge particularly enticing for me personally was the fact
that the formula is basically a trace in
<a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">SSA-form</a> – a
linear sequence of operations, where every variable is assigned exactly once.
The challenge is to evaluate the formula as fast as possible. I tried a number
of ideas how to speed up execution and will talk about them in this somewhat
meandering post. Most of it follows Matt's implementation
<a href="https://github.com/mkeeter/fidget">Fidget</a> very closely. There are two points
of difference:</p>
<ul>
<li>I tried to add more peephole optimizations, but they didn't end up helping
  much.</li>
<li>I implemented a "demanded information" optimization that removes a lot of
  operations by only keeping the sign of the result. This optimization ended up
  being useful.</li>
</ul>
<p>Most of the prototyping in this post was done in RPython (a statically typable
subset of Python2, that can be compiled to C), but I later rewrote the program
in C to get better performance. All the code <a href="https://github.com/cfbolz/pyfidget/">can be found on
Github</a>.</p>
<h3 id="input-program">Input program</h3>
<p>The input program is a sequence of operations, like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">_0</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="mf">2.95</span>
<span class="n">_1</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">x</span>
<span class="n">_2</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="mf">8.13008</span>
<span class="n">_3</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="n">_1</span><span class="w"> </span><span class="n">_2</span>
<span class="n">_4</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">_0</span><span class="w"> </span><span class="n">_3</span>
<span class="n">_5</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="mf">3.675</span>
<span class="n">_6</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">_5</span><span class="w"> </span><span class="n">_3</span>
<span class="n">_7</span><span class="w"> </span><span class="n">neg</span><span class="w"> </span><span class="n">_6</span>
<span class="n">_8</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="n">_4</span><span class="w"> </span><span class="n">_7</span>
<span class="o">...</span>
</pre></div>

<p>The first column is the name of the result variable, the second column is the
operation, and the rest are the arguments to the operation. <code>var-x</code> is a
special operation that returns the x-coordinate of the pixel being rendered,
and equivalently for <code>var-y</code> the y-coordinate. The sign of the result gives the
color of the pixel, the absolute value is not important.</p>
<h3 id="a-baseline-interpreter">A baseline interpreter</h3>
<p>To run the program, I first parse them and replace the register names with
indexes, to avoid any dictionary lookups at runtime.
Then I implemented a simple interpreter for the SSA-form
input program. The interpreter is a simple register machine, where every
operation is executed in order. The result of the operation is stored into a
list of results, and the next operation is executed. This was the slow baseline
implementation of the interpreter but it's very useful to compare against the optimized
versions.</p>
<p>This is roughly what the code looks like</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">DirectFrame</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">program</span> <span class="o">=</span> <span class="n">program</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run_floats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setxyz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">setxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">program</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span>
        <span class="n">num_ops</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">num_operations</span><span class="p">()</span>
        <span class="n">floatvalues</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ops</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ops</span><span class="p">):</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">get_func_and_args</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">const</span><span class="p">:</span>
                <span class="n">floatvalues</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">consts</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="n">farg0</span> <span class="o">=</span> <span class="n">floatvalues</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span>
            <span class="n">farg1</span> <span class="o">=</span> <span class="n">floatvalues</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">var_x</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">var_y</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">var_z</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">add</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">farg0</span><span class="p">,</span> <span class="n">farg1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">sub</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">farg0</span><span class="p">,</span> <span class="n">farg1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">mul</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">farg0</span><span class="p">,</span> <span class="n">farg1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">farg0</span><span class="p">,</span> <span class="n">farg1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">farg0</span><span class="p">,</span> <span class="n">farg1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">square</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">farg0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">sqrt</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">farg0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">exp</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">farg0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">neg</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">farg0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">abs</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">farg0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="mi">0</span>
            <span class="n">floatvalues</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floatvalues</span><span class="p">[</span><span class="n">num_ops</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg0</span> <span class="o">+</span> <span class="n">arg1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg0</span> <span class="o">-</span> <span class="n">arg1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg0</span> <span class="o">*</span> <span class="n">arg1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">arg0</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">*</span><span class="n">val</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">neg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">arg0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
</pre></div>

<p>Running the naive interpreter on the prospero image file is super slow, since
it performs 7866 * 1024 * 1024 float operations, plus the interpretation overhead.</p>
<h3 id="using-quadtrees-to-render-the-picture">Using Quadtrees to render the picture</h3>
<p>The approach that Matt describes in his really excellent
<a href="https://www.youtube.com/watch?v=UxGxsGnbyJ4">talk</a> is to use
<a href="https://en.wikipedia.org/wiki/Quadtree">quadtrees</a>: recursively subdivide the
image into quadrants, and evaluate the formula in each quadrant. For every
quadrant you can simplify the formula by doing a range analysis. After a few
recursion steps, the formula becomes significantly smaller, often only a few
hundred or a few dozen operations.</p>
<p>At the bottom of the recursion you either reach a square where the range
analysis reveals that the sign for all pixels is determined, then you can fill
in all the pixels of the quadrant. Or you can evaluate the (now much simpler)
formula in the quadrant by executing it for every pixel.</p>
<p>This is an interesting use case of JIT compiler/optimization techniques,
requiring the optimizer itself to execute really quickly since it is an essential
part of the performance of the algorithm. The optimizer runs literally hundreds
of times to render a single image. If the algorithm is used for 3D models
it becomes even more crucial.</p>
<h3 id="writing-a-simple-optimizer">Writing a simple optimizer</h3>
<p>Implementing the quadtree recursion is straightforward. Since the program has
no control flow the optimizer is very simple to write. I've written a couple of
blog posts on how to easily write optimizers for linear sequences of
operations, and I'm using the approach described in these <a href="https://pypy.org/categories/toy-optimizer.html">Toy
Optimizer</a> posts. The interval
analysis is basically an <a href="https://pypy.org/posts/2024/08/toy-knownbits.html">abstract
interpretation</a> of the
operations. The optimizer does a sequential forward pass over the input
program. For every operation, the output interval is computed. The optimizer
also performs optimizations based on the computed intervals, which helps in
reducing the number of operations executed (I'll talk about this further down).</p>
<p>Here's a sketch of the Python code that does the optimization:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Optimizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">program</span> <span class="o">=</span> <span class="n">program</span>
        <span class="n">num_operations</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">num_operations</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resultops</span> <span class="o">=</span> <span class="n">ProgramBuilder</span><span class="p">(</span><span class="n">num_operations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span> <span class="o">=</span> <span class="n">IntervalFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">program</span><span class="p">)</span>
        <span class="c1"># old index -&gt; new index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opreplacements</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_operations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_replacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opreplacements</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">newop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">arg0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arg1</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultops</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">newconst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">const</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultops</span><span class="o">.</span><span class="n">add_const</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span><span class="o">.</span><span class="n">minvalues</span><span class="p">[</span><span class="n">const</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span><span class="o">.</span><span class="n">maxvalues</span><span class="p">[</span><span class="n">const</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1">#self.seen_consts[value] = const</span>
        <span class="k">return</span> <span class="n">const</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="n">program</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span><span class="o">.</span><span class="n">setxyz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">numops</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">num_operations</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numops</span><span class="p">):</span>
            <span class="n">newop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_op</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opreplacements</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">newop</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opreplacements</span><span class="p">[</span><span class="n">numops</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="n">program</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span>
        <span class="n">intervalframe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">get_func_and_args</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">arg0</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">arg1</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">var_x</span><span class="p">:</span>
            <span class="n">minimum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">minx</span>
            <span class="n">maximum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">maxx</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_default</span><span class="p">(</span><span class="n">OPS</span><span class="o">.</span><span class="n">var_x</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">var_y</span><span class="p">:</span>
            <span class="n">minimum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">miny</span>
            <span class="n">maximum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">maxy</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_default</span><span class="p">(</span><span class="n">OPS</span><span class="o">.</span><span class="n">var_y</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">var_z</span><span class="p">:</span>
            <span class="n">minimum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">minz</span>
            <span class="n">maximum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">maxz</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_default</span><span class="p">(</span><span class="n">OPS</span><span class="o">.</span><span class="n">var_z</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">const</span><span class="p">:</span>
            <span class="n">const</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">consts</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newconst</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
        <span class="n">arg0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_replacement</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
        <span class="n">arg1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_replacement</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">arg0</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">arg1</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="n">arg0minimum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">minvalues</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span>
        <span class="n">arg0maximum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">maxvalues</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span>
        <span class="n">arg1minimum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">minvalues</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span>
        <span class="n">arg1maximum</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">maxvalues</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">neg</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_neg</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_min</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">,</span> <span class="n">arg1minimum</span><span class="p">,</span> <span class="n">arg1maximum</span><span class="p">)</span>
        <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">opt_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">arg0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arg1</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">newop</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newop</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">opt_neg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">):</span>
        <span class="c1"># peephole rules go here, see below</span>
        <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span><span class="o">.</span><span class="n">_neg</span><span class="p">(</span><span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_default</span><span class="p">(</span><span class="n">OPS</span><span class="o">.</span><span class="n">neg</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">arg0</span><span class="p">)</span>

    <span class="nd">@symmetric</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">opt_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">,</span> <span class="n">arg1minimum</span><span class="p">,</span> <span class="n">arg1maximum</span><span class="p">):</span>
        <span class="c1"># peephole rules go here, see below</span>
        <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span><span class="o">.</span><span class="n">_max</span><span class="p">(</span><span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">,</span> <span class="n">arg1minimum</span><span class="p">,</span> <span class="n">arg1maximum</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_default</span><span class="p">(</span><span class="n">OPS</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>

    <span class="o">...</span>
</pre></div>

<p>The resulting optimized traces are then simply interpreted at the bottom of the
quadtree recursion. Matt talks about also generating machine code from them,
but when I tried to use PyPy's JIT for that it was way too slow at
producing machine code.</p>
<h3 id="testing-soundness-of-the-interval-abstract-domain">Testing soundness of the interval abstract domain</h3>
<p>To make sure that my interval computation in the optimizer is correct, I
implemented a hypothesis-based property based test. It checks the abstract
transfer functions of the interval domain for soundness. It does so by
generating random concrete input values for an operation and random intervals that
surround the random concrete values, then performs the concrete operation to
get the concrete output, and finally checks that the abstract transfer function applied
to the input intervals gives an interval that contains the concrete output.</p>
<p>For example, the random test for the <code>square</code> operation would look like this:</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span><span class="w"> </span><span class="nn">hypothesis</span><span class="w"> </span><span class="kn">import</span> <span class="n">given</span><span class="p">,</span> <span class="n">strategies</span><span class="p">,</span> <span class="n">assume</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyfidget.vm</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntervalFrame</span><span class="p">,</span> <span class="n">DirectFrame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="n">regular_floats</span> <span class="o">=</span> <span class="n">strategies</span><span class="o">.</span><span class="n">floats</span><span class="p">(</span><span class="n">allow_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_infinity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">make_range_and_contained_float</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>

<span class="n">frame</span> <span class="o">=</span> <span class="n">DirectFrame</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="n">intervalframe</span> <span class="o">=</span> <span class="n">IntervalFrame</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

<span class="n">range_and_contained_float</span> <span class="o">=</span> <span class="n">strategies</span><span class="o">.</span><span class="n">builds</span><span class="p">(</span><span class="n">make_range_and_contained_float</span><span class="p">,</span> <span class="n">regular_floats</span><span class="p">,</span> <span class="n">regular_floats</span><span class="p">,</span> <span class="n">regular_floats</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">contains</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmin</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmax</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">rmin</span> <span class="o">&lt;=</span> <span class="n">res</span> <span class="o">&lt;=</span> <span class="n">rmax</span>


<span class="nd">@given</span><span class="p">(</span><span class="n">range_and_contained_float</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_square</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">val</span>
    <span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span> <span class="o">=</span> <span class="n">intervalframe</span><span class="o">.</span><span class="n">_square</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">contains</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">)</span>
</pre></div>

<p>This test generates a random float <code>b</code>, and two other floats <code>a</code> and <code>c</code> such
that the interval <code>[a, c]</code> contains <code>b</code>. The test then checks that the result
of the <code>square</code> operation on <code>b</code> is contained in the interval <code>[rmin, rmax]</code>
returned by the abstract transfer function for the <code>square</code> operation.</p>
<h3 id="peephole-rewrites">Peephole rewrites</h3>
<p>The only optimization that Matt does in his implementation is a peephole
optimization rule that removes <code>min</code> and <code>max</code> operations where the intervals
of the arguments don't overlap. In that case, the optimizer statically can know
which of the arguments will be the result of the operation. I implemented this
peephole optimization in my implementation as well, but I also added a few more
peephole optimizations that I thought would be useful.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Optimizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">opt_neg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">):</span>
        <span class="c1"># new: add peephole rule --x =&gt; x</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">arg0arg0</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultops</span><span class="o">.</span><span class="n">get_func_and_args</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">neg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arg0arg0</span>
        <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span><span class="o">.</span><span class="n">_neg</span><span class="p">(</span><span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_default</span><span class="p">(</span><span class="n">OPS</span><span class="o">.</span><span class="n">neg</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">arg0</span><span class="p">)</span>

    <span class="nd">@symmetric</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">opt_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">,</span> <span class="n">arg1minimum</span><span class="p">,</span> <span class="n">arg1maximum</span><span class="p">):</span>
        <span class="c1"># Matt's peephole rule</span>
        <span class="k">if</span> <span class="n">arg0maximum</span> <span class="o">&lt;</span> <span class="n">arg1minimum</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arg0</span> <span class="c1"># we can use the intervals to decide which argument will be returned</span>
        <span class="c1"># new one by me: min(x, x) =&gt; x </span>
        <span class="k">if</span> <span class="n">arg0</span> <span class="o">==</span> <span class="n">arg1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arg0</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">arg0arg0</span><span class="p">,</span> <span class="n">arg0arg1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultops</span><span class="o">.</span><span class="n">get_func_and_args</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
        <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalframe</span><span class="o">.</span><span class="n">_max</span><span class="p">(</span><span class="n">arg0minimum</span><span class="p">,</span> <span class="n">arg0maximum</span><span class="p">,</span> <span class="n">arg1minimum</span><span class="p">,</span> <span class="n">arg1maximum</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_default</span><span class="p">(</span><span class="n">OPS</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>

    <span class="o">...</span>
</pre></div>

<p>However, it turns out that all my attempts at adding other peephole
optimization rules were not very useful. Most rules never fired, and the ones
that did only had a small effect on the performance of the program. The only
peephole optimization that I found to be useful was the one that Matt describes
in his talk. Matt's <code>min</code>/<code>max</code> optimization were 96% of all rewrites that my
peephole optimizer applied for the <code>prospero.vm</code> input. The remaining 4% of
rewrites were (the percentages are of that 4%):</p>
<div class="code"><pre class="code literal-block">--x =&gt; x                          4.65%
(-x)**2 =&gt; x ** 2                 0.99%
min(x, x) =&gt; x                   20.86%
min(x, min(x, y)) =&gt;  min(x, y)  52.87%
max(x, x) =&gt; x                   16.40%
max(x, max(x, y)) =&gt; max(x, y)    4.23%
</pre></div>

<p>In the end it turned out that having these extra optimization rules made the
total runtime of the system go up. Checking for the rewrites isn't free, and
since they apply so rarely they don't pay for their own cost in terms of
improved performance.</p>
<p>There are some further rules that I tried that never fired at all:</p>
<div class="code"><pre class="code literal-block">a <span class="gs">* 0 =&gt; 0</span>
<span class="gs">a *</span> 1 =&gt; a
a <span class="gs">* a =&gt; a *</span>* 2
a <span class="gs">* -1 =&gt; -a</span>
<span class="gs">a + 0 =&gt; a</span>
<span class="gs">a - 0 =&gt; a</span>
<span class="gs">x - x =&gt; 0</span>
<span class="gs">abs(known positive number x) =&gt; x</span>
<span class="gs">abs(known negative number x) =&gt; -x</span>
<span class="gs">abs(-x) =&gt; abs(x)</span>
<span class="gs">(-x) *</span>* 2 =&gt; x ** 2
</pre></div>

<p>This investigation is clearly way too focused on a single program and should be
re-done with a larger set of example inputs, if this were an actually serious
implementation.</p>
<h3 id="demanded-information-optimization">Demanded Information Optimization</h3>
<p>LLVM has an static analysis pass called 'demanded bits'. It is a backwards analysis that
allows you to determine which bits of a value are actually used in the final
result. This information can then be used in peephole optimizations. For
example, if you have an expression that computes a value, but only the last
byte of that value is used in the final result, you can optimize the expression
to only compute the last byte.</p>
<p>Here's an example. Let's say we first byte-swap a 64-bit int, and then mask off the last byte:</p>
<div class="code"><pre class="code literal-block"><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">byteswap_then_mask</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">byteswap</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>In this case, the "demanded bits" of the <code>byteswap(a)</code> expression are
<code>0b0...011111111</code>, which inversely means that we don't care about the upper 56
bits. Therefore the whole expression can be optimized to <code>a &gt;&gt; 56</code>.</p>
<p>For the Prospero challenge, we can observe that for the resulting pixel values, the value of
the result is not used at all, only its sign. Essentially, every program ends
implicitly with a <code>sign</code> operation that returns <code>0.0</code> for negative values and
<code>1.0</code> for positive values. For clarity, I will show this <code>sign</code> operation in
the rest of the section, even if it's not actually in the real code.</p>
<p>This makes it possible to simplify certain min/max
operations further. Here is an example of a program, together with the
intervals of the variables:</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">x</span><span class="w">     </span><span class="c1"># [0.1, 1]</span>
<span class="n">y</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">y</span><span class="w">     </span><span class="c1"># [-1, 1]</span>
<span class="n">m</span><span class="w"> </span><span class="nb">min</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="c1"># [-1, 1]</span>
<span class="n">out</span><span class="w"> </span><span class="nb">sign</span><span class="w"> </span><span class="n">m</span>
</pre></div>

<p>This program can be optimized to:</p>
<div class="code"><pre class="code literal-block"><span class="n">y</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">y</span>
<span class="n">out</span><span class="w"> </span><span class="nb">sign</span><span class="w"> </span><span class="n">m</span>
</pre></div>

<p>Because that expression has the same result as the original expression: if <code>x &gt;
0.1</code>, for the result of <code>min(x, y)</code> to be negative then <code>y</code> needs to be negative.</p>
<p>Another, more complex, example is this:</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">x</span><span class="w">        </span><span class="c1"># [1, 100]</span>
<span class="n">y</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">y</span><span class="w">        </span><span class="c1"># [-10, 10]</span>
<span class="n">z</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">z</span><span class="w">        </span><span class="c1"># [-100, 100]</span>
<span class="n">m1</span><span class="w"> </span><span class="nb">min</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w">     </span><span class="c1"># [-10, 10]</span>
<span class="n">m2</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">out</span><span class="w">   </span><span class="c1"># [-10, 100]</span>
<span class="n">out</span><span class="w"> </span><span class="nb">sign</span><span class="w"> </span><span class="n">m2</span>
</pre></div>

<p>Which can be optimized to this:</p>
<div class="code"><pre class="code literal-block"><span class="n">y</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">y</span>
<span class="n">z</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">z</span>
<span class="n">m2</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">y</span>
<span class="n">out</span><span class="w"> </span><span class="nb">sign</span><span class="w"> </span><span class="n">m2</span>
</pre></div>

<p>This is because the sign of <code>min(x, y)</code> is the same as the sign of <code>y</code> if <code>x &gt;
0</code>, and the sign of <code>max(z, min(x, y))</code> is thus the same as the sign of <code>max(z,
y)</code>.</p>
<p>To implement this optimization, I do a backwards pass over the program after
the peephole optimization forward pass. For every <code>min</code> call I encounter, where
one of the arguments is positive, I can optimize the <code>min</code> call away and
replace it with the other argument. For <code>max</code> calls I simplify their arguments
recursively.</p>
<p>The code looks roughly like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">work_backwards</span><span class="p">(</span><span class="n">resultops</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">minvalues</span><span class="p">,</span> <span class="n">maxvalues</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">demand_sign_simplify</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">=</span> <span class="n">resultops</span><span class="o">.</span><span class="n">get_func_and_args</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="n">narg0</span> <span class="o">=</span> <span class="n">demand_sign_simplify</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">narg0</span> <span class="o">!=</span> <span class="n">arg0</span><span class="p">:</span>
                <span class="n">resultops</span><span class="o">.</span><span class="n">setarg</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">narg0</span><span class="p">)</span>
            <span class="n">narg1</span> <span class="o">=</span> <span class="n">demand_sign_simplify</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">narg1</span> <span class="o">!=</span> <span class="n">arg1</span><span class="p">:</span>
                <span class="n">resultops</span><span class="o">.</span><span class="n">setarg</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">narg1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">minvalues</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">demand_sign_simplify</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">minvalues</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">demand_sign_simplify</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
            <span class="n">narg0</span> <span class="o">=</span> <span class="n">demand_sign_simplify</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">narg0</span> <span class="o">!=</span> <span class="n">arg0</span><span class="p">:</span>
                <span class="n">resultops</span><span class="o">.</span><span class="n">setarg</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">narg0</span><span class="p">)</span>
            <span class="n">narg1</span> <span class="o">=</span> <span class="n">demand_sign_simplify</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">narg1</span> <span class="o">!=</span> <span class="n">arg1</span><span class="p">:</span>
                <span class="n">resultops</span><span class="o">.</span><span class="n">setarg</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">narg1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span>
    <span class="k">return</span> <span class="n">demand_sign_simplify</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>

<p>In my experiment, this optimization lets me remove 25% of all operations in
prospero, at the various levels of my octree. I'll briefly look at performance
results further down.</p>
<h3 id="further-ideas-about-the-demanded-sign-simplification">Further ideas about the demanded sign simplification</h3>
<p>There is another idea how to short-circuit the evaluation of expressions that I
tried briefly but didn't pursue to the end. Let's go back to the first example
of the previous subsection, but with different intervals:</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">x</span><span class="w">     </span><span class="c1"># [-1, 1]</span>
<span class="n">y</span><span class="w"> </span><span class="k">var</span><span class="o">-</span><span class="n">y</span><span class="w">     </span><span class="c1"># [-1, 1]</span>
<span class="n">m</span><span class="w"> </span><span class="nb">min</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w">   </span><span class="c1"># [-1, 1]</span>
<span class="n">out</span><span class="w"> </span><span class="nb">sign</span><span class="w"> </span><span class="n">m</span>
</pre></div>

<p>Now we can't use the "demanded sign" trick in the optimizer, because neither
<code>x</code> nor <code>y</code> are known positive. However, during <em>execution</em> of the program, if
<code>x</code> turns out to be negative we can end the execution of this trace
immediately, since we know that the result must be negative.</p>
<p>So I experimented with adding <code>return_early_if_neg</code> flags to all operations
with this property. The interpreter then checks whether the flag is set on an
operation and if the result is negative, it stops the execution of the program
early:</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span><span class="w"> </span><span class="nf">var</span><span class="o">-</span><span class="n">x</span><span class="o">[</span><span class="n">return_early_if_neg</span><span class="o">]</span>
<span class="n">y</span><span class="w"> </span><span class="nf">var</span><span class="o">-</span><span class="n">y</span><span class="o">[</span><span class="n">return_early_if_neg</span><span class="o">]</span>
<span class="n">m</span><span class="w"> </span><span class="nf">min</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span>
<span class="k">out</span><span class="w"> </span><span class="nf">sign</span><span class="w"> </span><span class="n">m</span>
</pre></div>

<p>This looked pretty promising, but it's also a trade-off because the cost of
checking the flag and the value isn't zero. Here's a sketch to the change in the interpreter:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">DirectFrame</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">program</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">program</span>
        <span class="n">num_ops</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">num_operations</span><span class="p">()</span>
        <span class="n">floatvalues</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ops</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ops</span><span class="p">):</span>
            <span class="o">...</span>
            <span class="k">if</span> <span class="n">func</span> <span class="o">==</span> <span class="n">OPS</span><span class="o">.</span><span class="n">var_x</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
            <span class="o">...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">program</span><span class="o">.</span><span class="n">get_flags</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OPS</span><span class="o">.</span><span class="n">should_return_if_neg</span> <span class="ow">and</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="n">floatvalues</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floatvalues</span><span class="p">[</span><span class="n">num_ops</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>

<p>I implemented this in the RPython
version, but didn't end up porting it to C, because it interferes with SIMD.</p>
<h3 id="dead-code-elimination">Dead code elimination</h3>
<p>Matt performs dead code elimination in his implementation by doing a single
backwards pass over the program. This is a very simple and effective
optimization, and I implemented it in my implementation as well. The dead code
elimination pass is very simple: It starts by marking the result operation as
used. Then it goes backwards over the program. If the current operation is
used, its arguments are marked as used as well. Afterwards, all the operations
that are not marked as used are removed from the program. The PyPy JIT actually
performs dead code elimination on traces in exactly the same way (and I don't
think we ever explained how this works on the blog), so I thought it was worth
mentioning.</p>
<p>Matt also performs register allocation as part of the backwards pass, but I
didn't implement it because I wasn't too interested in that aspect.</p>
<h3 id="random-testing-of-the-optimizer">Random testing of the optimizer</h3>
<p>To make sure I didn't break anything in the optimizer, I implemented a
test that generates random input programs and checks that the output of the
optimizer is equivalent to the input program. The test generates random
operations, random intervals for the operations and a random input value within
that interval. It then runs the optimizer on the input program and checks that
the output program has the same result as the input program. This is again
implemented with <code>hypothesis</code>. Hypothesis' test case minimization feature is
super useful for finding optimizer bugs. It's just not fun to analyze a problem
on a many-thousand-operation input file, but Hypothesis often generated reduced
test cases that were only a few operations long.</p>
<h3 id="visualizing-programs">Visualizing programs</h3>
<p>It's actually surprisingly annoying to visualize <code>prospero.vm</code> well, because
it's quite a bit too large to just feed it into Graphviz. I made the problem
slightly easier by grouping several operations together, where only the first
operation in a group is used as the argument for more than one operation
further in the program. This made it slightly more manageable for Graphviz. But
it still wasn't a big enough improvement to be able to visualize all of
<code>prospero.vm</code> in its unoptimized form at the top of the octree.</p>
<p>Here's a visualization of the optimized <code>prospero.vm</code> at one of the octree
levels:</p>
<p><img alt="graph visualization of a part of the input program" src="../images/2025-image-prospero-dataflow.png"></p>
<p>The result is on top, every node points to its arguments. The <code>min</code> and <code>max</code>
operations form a kind of "spine" of the expression tree, because they are
unions and intersection in the constructive solid geometry sense.</p>
<p>I also wrote a function to visualize the octree recursion itself, the output
looks like this:</p>
<p><img alt="graph visualization of the octree recursion, zoomed out" src="../images/2025-image-octree-zoomed-out.png"></p>
<p><img alt="graph visualization of the octree recursion, zoomed in" src="../images/2025-image-octree-zoomed-in.png"></p>
<p>Green nodes are where the interval analysis determined that the output must be
entirely outside the shape. Yellow nodes are where the octree recursion
bottomed out.</p>
<h3 id="c-implementation">C implementation</h3>
<p>To achieve even faster performance, I decided to rewrite the implementation in
C. While RPython is great for prototyping, it can be challenging to control
low-level aspects of the code. The rewrite in C allowed me to experiment with
several techniques I had been curious about:</p>
<ul>
<li>
<a href="https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html"><code>musttail</code> optimization</a> for the interpreter.</li>
<li>SIMD (Single Instruction, Multiple Data): Using Clang's
  <a href="https://clang.llvm.org/docs/LanguageExtensions.html#vectors-and-extended-vectors"><code>ext_vector_type</code></a>, I process eight pixels at once using AVX (or some other
  SIMD magic that I don't properly understand).</li>
<li>Efficient struct packing: I packed the operations struct into just 8
  bytes by limiting the maximum number of operations to 65,536, with the idea
  of making the optimizer faster.</li>
</ul>
<p>I didn't rigorously study the performance impact of each of these techniques
individually, so it's possible that some of them might not have contributed
significantly. However, the rewrite was a fun exercise for me to explore these
techniques. The code can be found
<a href="https://github.com/cfbolz/pyfidget/blob/main/pyfidget/experiments.c">here</a>.</p>
<h3 id="testing-the-c-implementation">Testing the C implementation</h3>
<p>At various points I had bugs in the C implementation, leading to a fun glitchy
version of prospero:</p>
<p><img alt="glitchy prospero" src="../images/2025-glitchy-prospero.png"></p>
<p>To find these bugs, I used the same random testing approach as in the
RPython version. I generated random input programs as strings in Python and
checked that the output of the C implementation was equivalent to the output of
the RPython implementation (simply by calling out to the shell and reading the
generated image, then comparing pixels). This helped ensure that the C
implementation was
correct and didn't introduce any bugs. It was surprisingly tricky to get this
right, for reasons that I didn't expect. At lot of them are related to the fact
that in C I used <code>float</code> and Python uses <code>double</code> for its (Python) <code>float</code>
type. This made the random tester find weird floating point corner cases where
rounding behaviour between the widths was different.</p>
<p>I solved those by using <code>double</code> in C when running the random tests by means of
an <code>IFDEF</code>.</p>
<p>It's super fun to watch the random program generator produce random images, here are a few:</p>
<iframe width="560" height="560" src="https://www.youtube.com/embed/VqU5n3zzOjc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

<h3 id="performance">Performance</h3>
<p>Some very rough performance results on my laptop (an AMD Ryzen 7 PRO 7840U with
32 GiB RAM running Ubuntu 24.04), comparing the RPython version, the C version
(with and without demanded info), and Fidget (in <code>vm</code> mode, its JIT made things
worse for me), both for 1024x1024 and 4096x4096 images:</p>
<table>
<thead><tr>
<th>Implementation</th>
<th>1024x1024</th>
<th>4096x4096</th>
</tr></thead>
<tbody>
<tr>
<td>RPython</td>
<td>26.8ms</td>
<td>75.0ms</td>
</tr>
<tr>
<td>C (no demanded info)</td>
<td>24.5ms</td>
<td>45.0ms</td>
</tr>
<tr>
<td>C (demanded info)</td>
<td>18.0ms</td>
<td>37.0ms</td>
</tr>
<tr>
<td>Fidget</td>
<td>10.8ms</td>
<td>57.8ms</td>
</tr>
</tbody>
</table>
<p>The demanded info seem to help quite a bit, which was nice to see.</p>
<h3 id="conclusion">Conclusion</h3>
<p>That's it! I had lots of fun with the challenge and have a whole bunch of other
ideas I want to try out, thanks Matt for this interesting puzzle.</p>
    </div>
    </article><article class="h-entry post-rst" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2025/02/pypy-v7319-release.html" class="u-url">PyPy v7.3.19 release</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/mattip.html">mattip</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2025/02/pypy-v7319-release.html" rel="bookmark">
            <time class="published dt-published" datetime="2025-02-26T12:00:00Z" itemprop="datePublished" title="2025-02-26 12:00">2025-02-26 12:00</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <section id="pypy-v7-3-19-release-of-python-2-7-3-10-and-3-11-beta"><h2>PyPy v7.3.19: release of python 2.7, 3.10 and 3.11 beta</h2>
<p>The PyPy team is proud to release version 7.3.19 of PyPy. This is primarily a
bug-fix release fixing JIT-related problems and follows quickly on the heels of
the previous release on Feb 6, 2025.</p>
<p>This release includes a python 3.11 interpreter. There were bugs in the first
beta that could prevent its wider use, so we are continuing to call this
release "beta". In the next release we will drop 3.10 and remove the "beta"
label.</p>
<p>The release includes three different interpreters:</p>
<ul class="simple">
<li><p>PyPy2.7, which is an interpreter supporting the syntax and the features of
Python 2.7 including the stdlib for CPython 2.7.18+ (the <code class="docutils literal">+</code> is for
backported security updates)</p></li>
<li><p>PyPy3.10, which is an interpreter supporting the syntax and the features of
Python 3.10, including the stdlib for CPython 3.10.16.</p></li>
<li><p>PyPy3.11, which is an interpreter supporting the syntax and the features of
Python 3.11, including the stdlib for CPython 3.11.11.</p></li>
</ul>
<p>The interpreters are based on much the same codebase, thus the triple
release. This is a micro release, all APIs are compatible with the other 7.3
releases. It follows after 7.3.17 release on August 28, 2024.</p>
<p>We recommend updating. You can find links to download the releases here:</p>
<blockquote>
<p><a class="reference external" href="https://pypy.org/download.html">https://pypy.org/download.html</a></p>
</blockquote>
<p>We would like to thank our donors for the continued support of the PyPy
project. If PyPy is not quite good enough for your needs, we are available for
<a class="reference external" href="https://www.pypy.org/pypy-sponsors.html">direct consulting</a> work. If PyPy is helping you out, we would love to hear
about it and encourage submissions to our <a class="reference external" href="https://pypy.org/blog">blog</a> via a pull request
to <a class="reference external" href="https://github.com/pypy/pypy.org">https://github.com/pypy/pypy.org</a></p>
<p>We would also like to thank our contributors and encourage new people to join
the project. PyPy has many layers and we need help with all of them: bug fixes,
<a class="reference external" href="https://doc.pypy.org/">PyPy</a> and <a class="reference external" href="https://rpython.readthedocs.org">RPython</a> documentation improvements, or general <a class="reference external" href="https://doc.pypy.org/en/latest/project-ideas.html">help</a> with
making RPython's JIT even better.</p>
<p>If you are a python library maintainer and use C-extensions, please consider
making a <a class="reference external" href="https://hpyproject.org/">HPy</a> / <a class="reference external" href="https://cffi.readthedocs.io">CFFI</a> / <a class="reference external" href="https://cppyy.readthedocs.io">cppyy</a> version of your library that would be performant
on PyPy. In any case, both <a class="reference external" href="https://github.com/joerick/cibuildwheel">cibuildwheel</a> and the <a class="reference external" href="https://github.com/matthew-brett/multibuild">multibuild system</a> support
building wheels for PyPy.</p>
<section id="what-is-pypy"><h3>What is PyPy?</h3>
<p>PyPy is a Python interpreter, a drop-in replacement for CPython
It's fast (<a class="reference external" href="https://speed.pypy.org">PyPy and CPython</a> performance
comparison) due to its integrated tracing JIT compiler.</p>
<p>We also welcome developers of other <a class="reference external" href="https://rpython.readthedocs.io/en/latest/examples.html">dynamic languages</a> to see what RPython
can do for them.</p>
<p>We provide binary builds for:</p>
<ul class="simple">
<li><p><strong>x86</strong> machines on most common operating systems
(Linux 32/64 bits, Mac OS 64 bits, Windows 64 bits)</p></li>
<li><p>64-bit <strong>ARM</strong> machines running Linux (<code class="docutils literal">aarch64</code>) and macos (<code class="docutils literal">macos_arm64</code>).</p></li>
</ul>
<p>PyPy supports Windows 32-bit, Linux PPC64 big- and little-endian, Linux ARM
32 bit, RISC-V RV64IMAFD Linux, and s390x Linux but does not release binaries.
Please reach out to us if you wish to sponsor binary releases for those
platforms. Downstream packagers provide binary builds for debian, Fedora,
conda, OpenBSD, FreeBSD, Gentoo, and more.</p>
</section><section id="what-else-is-new"><h3>What else is new?</h3>
<p>For more information about the 7.3.19 release, see the <a class="reference external" href="https://doc.pypy.org/en/latest/release-v7.3.19.html#changelog">full changelog</a>.</p>
<p>Please update, and continue to help us make pypy better.</p>
<p>Cheers,
The PyPy Team</p>
</section></section>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2025/02/pypy-gc-sampling.html" class="u-url">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/christoph-jung.html">Christoph Jung</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2025/02/pypy-gc-sampling.html" rel="bookmark">
            <time class="published dt-published" datetime="2025-02-25T10:16:00Z" itemprop="datePublished" title="2025-02-25 10:16">2025-02-25 10:16</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <h3 id="introduction">Introduction</h3>
<p>There are many time-based statistical profilers around (like VMProf or py-spy
just to name a few). They allow the user to pick a trade-off between profiling
precision and runtime overhead.</p>
<p>On the other hand there are memory profilers
such as <a href="https://github.com/bloomberg/memray">memray</a>. They can be handy for
finding leaks or for discovering functions that allocate a lot of memory.
Memory profilers typlically save every single allocation a program does. This
results in precise profiling, but larger overhead.</p>
<p>In this post we describe our experimental approach to low overhead statistical
memory profiling. Instead of saving every single allocation a program does, it
only saves every nth allocated byte. We have tightly integrated VMProf and the
PyPy Garbage Collector to achieve this. The main technical insight is that the
check whether an allocation should be sampled can be made free. This is done by
folding it into the bump pointer allocator check that the PyPy’s GC uses to
find out if it should start a minor collection. In this way the fast path with
and without memory sampling are exactly the same.</p>
<h3 id="background">Background</h3>
<p>To get an insight how the profiler and GC interact, lets take a brief look at
both of them first.</p>
<h4 id="vmprof">VMProf</h4>
<p><a href="https://github.com/vmprof/vmprof-python">VMProf</a> is a statistical time-based profiler for PyPy. VMProf samples the stack of currently running Python functions a certain user-configured number of times per second. By adjusting
this number, the overhead of profiling can be modified to pick the correct trade-off between overhead and precision of the profile. In the resulting profile, functions with huge runtime stand out the most, functions with shorter runtime less so. If you want to get a little more introduction to VMProf and how to use it with PyPy, you may look
at <a href="https://pypy.org/posts/2024/05/vmprof-firefox-converter.html">this blog post</a></p>
<h4 id="pypys-gc">PyPy’s GC</h4>
<p>PyPy uses a generational incremental copying collector. That means there are two spaces for allocated objects, the nursery and the old-space. Freshly allocated objects will be allocated into the nursery. When the nursery is full at some point, it will be collected and all objects that survive will be tenured i.e. moved into the old-space. The old-space is much larger than the nursery and is collected less frequently and <a href="../posts/2024/03/fixing-bug-incremental-gc.html">incrementally</a> (not completely
collected in one go, but step-by-step). The old space collection is not relevant for the rest of the post though. We will now take a look at nursery allocations and how the nursery is collected.</p>
<h4 id="bump-pointer-allocation-in-the-nursery">Bump Pointer Allocation in the Nursery</h4>
<p>The nursery (a small continuous memory area) utilizes two pointers to keep track from where on the nursery is free and where it ends. They are called <code>nursery_free</code> and <code>nursery_top</code>. When memory is allocated, the GC checks if there is enough space in the nursery left. If there is enough space, the <code>nursery_free</code> pointer will be returned as the start address for the newly allocated memory, and <code>nursery_free</code> will be moved forward by the amount of allocated memory.</p>
<p><img src="../images/2025_02_allocation_sampling_images/nursery_allocation.svg"></p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="n">totalsize</span><span class="p">):</span>
  <span class="c1"># Save position, where the object will be allocated to as result</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span>
  <span class="c1"># Move nursery_free pointer forward by totalsize</span>
  <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">totalsize</span>
  <span class="c1"># Check if this allocation would exceed the nursery</span>
  <span class="k">if</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span> <span class="o">&gt;</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_top</span><span class="p">:</span>
      <span class="c1"># If it does =&gt; collect the nursery and allocate afterwards</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">collect_and_reserve</span><span class="p">(</span><span class="n">totalsize</span><span class="p">)</span>
  <span class="c1"># result is a pointer into the nursery, obj will be allocated there</span>
  <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span><span class="w"> </span><span class="nf">collect_and_reserve</span><span class="p">(</span><span class="n">size_of_allocation</span><span class="p">):</span>
    <span class="c1"># do a minor collection and return the start of the nursery afterwards</span>
    <span class="n">minor_collection</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span>
</pre></div>

<p>Understanding this is crucial for our allocation sampling approach, so let us go through this step-by-step.</p>
<p>We already saw an example on how an allocation into a non-full nursery will look like. But what happens, if the nursery is (too) full?</p>
<p><img src="../images/2025_02_allocation_sampling_images/nursery_full.svg"></p>
<p>As soon as an object doesn't fit into the nursery anymore, it will be collected. A nursery collection will move all surviving objects into the old-space, so that the nursery is free afterwards, and the requested allocation can be made.</p>
<p><img src="../images/2025_02_allocation_sampling_images/nursery_collected.svg"></p>
<p>(Note that this is still a bit of a simplification.)</p>
<h3 id="sampling-approach">Sampling Approach</h3>
<p>The last section described how the nursery allocation works normally. Now we'll talk how we integrate the new allocation sampling approach into it.</p>
<p>To decide whether the GC should trigger a sample, the sampling logic is integrated into the bump pointer allocation logic. Usually, when there is not enough space in the nursery left to fulfill an allocation request, the nursery will be collected and the allocation will be done afterwards. We reuse that mechanism for sampling, by introducing a new pointer called <code>sample_point</code> that is calculated by <code>sample_point = nursery_free + sample_n_bytes</code> where <code>sample_n_bytes</code> is the number of bytes allocated before a sample is made (i.e. our sampling rate).</p>
<p>Imagine we'd have a nursery of 2MB and want to sample every 512KB allocated, then you could imagine our nursery looking like that:</p>
<p><img src="../images/2025_02_allocation_sampling_images/nursery_sampling.svg"></p>
<p>We use the sample point as <code>nursery_top</code>, so that allocating a chunk of 512KB would exceed the nursery top and start a nursery collection. But of course we don't want to do a minor collection just then, so before starting a collection, we need to check if the nursery is actually full or if that is just an exceeded sample point. The latter will then trigger a VMprof stack sample. Afterwards we don't actually do a minor collection, but change <code>nursery_top</code> and immediately return to the caller.</p>
<p>The last picture is a conceptual simplification. Only one sampling point exists at any given time. After we created the sampling point, it will be used as nursery top, if exceeded at some point, we will just add <code>sample_n_bytes</code> to that sampling point, i.e. move it forward.</p>
<p>Here's how the updated <code>collect_and_reserve</code> function looks like:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">collect_and_reserve</span><span class="p">(</span><span class="n">size_of_allocation</span><span class="p">):</span>
    <span class="c1"># Check if we exceeded a sample point or if we need to do a minor collection</span>
    <span class="k">if</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_top</span> <span class="o">==</span> <span class="n">gc</span><span class="o">.</span><span class="n">sample_point</span><span class="p">:</span>
        <span class="c1"># One allocation could exceed multiple sample points</span>
        <span class="c1"># Sample, move sample_point forward</span>
        <span class="n">vmprof</span><span class="o">.</span><span class="n">sample_now</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">sample_point</span> <span class="o">+=</span> <span class="n">sample_n_bytes</span>

        <span class="c1"># Set sample point as new nursery_top if it fits into the nursery</span>
        <span class="k">if</span> <span class="n">sample_point</span> <span class="o">&lt;=</span> <span class="n">gc</span><span class="o">.</span><span class="n">real_nursery_top</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">nursery_top</span> <span class="o">=</span> <span class="n">sample_point</span>
        <span class="c1"># Or use the real nursery top if it does not fit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">nursery_top</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">real_nursery_top</span>

        <span class="c1"># Is there enough memory left inside the nursery</span>
        <span class="k">if</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span> <span class="o">+</span> <span class="n">size_of_allocation</span> <span class="o">&lt;=</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_top</span><span class="p">:</span>
            <span class="c1"># Yes =&gt; move nursery_free forward</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span> <span class="o">+=</span> <span class="n">size_of_allocation</span>
            <span class="k">return</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span>

    <span class="c1"># We did not exceed a sampling point and must do a minor collection, or</span>
    <span class="c1"># we exceeded a sample point but we needed to do a minor collection anyway</span>
    <span class="n">minor_collection</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">gc</span><span class="o">.</span><span class="n">nursery_free</span>
</pre></div>

<h3 id="why-is-the-overhead-low">Why is the Overhead ‘low’</h3>
<p>The most important property of our approach is that the bump-pointer fast path is not changed at all. If sampling is turned off, the slow path in <code>collect_and_reserve</code> has three extra instructions for the if at the beginning, but are only a very small amount of overhead, compared to doing a minor collection.</p>
<p>When sampling is on, the extra logic in <code>collect_and_reserve</code> gets executed. Every time an allocation exceeds the <code>sample_point</code>, <code>collect_and_reserve</code> will sample the Python functions currently executing. The resulting overhead is directly controlled by <code>sample_n_bytes</code>. After sampling, the <code>sample_point</code> and <code>nursery_top</code> must be set accordingly. This will be done once after sampling in <code>collect_and_reserve</code>. At some point a nursery collection will free the nursery and set the new <code>sample_point</code> afterwards.</p>
<p>That means that the overhead mostly depends on the sampling rate and the rate at which the user program allocates memory, as the combination of those two factors determines the amount of samples.</p>
<p>Since the sampling rate can be adjusted from as low as 64 Byte to a theoretical maximum of ~4 GB (at the moment), the tradeoff between number of samples (i.e. profiling precision) and overhead can be completely adjusted.</p>
<p>We also suspect linkage between user program stack depth and overhead (a deeper stack takes longer to walk, leading to higher overhead), especially when walking the C call stack to.</p>
<h3 id="sampling-rates-bigger-than-the-nursery-size">Sampling rates bigger than the nursery size</h3>
<p>The nursery usually has a size of a few megabytes, but profiling long-runningor larger applications with tons of allocations could result in very high number of samples per second (and thus overhead). To combat that it is possible to use sampling rates higher than the nursery size.</p>
<p>The sampling point is not limited by the nursery size, but if it is 'outside' the nursery (e.g. because <code>sample_n_bytes</code> is set to twice the nursery size) it won't be used as <code>nursery_top</code> until it 'fits' into the nursery.</p>
<p><img src="../images/2025_02_allocation_sampling_images/nursery_sampling_larger_than_nursery.svg"></p>
<p>After every nursery collection, we'd usually set the <code>sample_point</code> to <code>nursery_free + sample_n_bytes</code>, but if it is larger than the nursery, then the amount of collected memory during the last nursery collection is subtracted from <code>sample_point</code>.</p>
<p><img src="../images/2025_02_allocation_sampling_images/nursery_sampling_larger_than_nursery_post_minor.svg"></p>
<p>At some point the <code>sample_point</code> will be smaller than the nursery size, then it will be used as <code>nursery_top</code> again to trigger a sample when exceeded.</p>
<h3 id="differences-to-time-based-sampling">Differences to Time-Based Sampling</h3>
<p>As mentioned in the introduction, time-based sampling ‘hits’ functions with high runtime, and allocation-sampling ‘hits’ functions allocating much memory. But are those always different functions? The answer is: sometimes. There can be functions allocating lots of memory, that do not have a (relative) high runtime.</p>
<p>Another difference to time-based sampling is that the profiling overhead does not solely depend on the sampling rate (if we exclude a potential stack-depth - overhead correlation for now) but also on the amount of memory the user code allocates.</p>
<p>Let us look at an example:</p>
<p>If we’d sample every 1024 Byte and some program A allocates 3 MB and runs for 5 seconds, and program B allocates 6 MB but also runs for 5 seconds, there will be ~3000 samples when profiling A, but ~6000 samples when profiling B. That means we cannot give a ‘standard’ sampling rate like time-based profilers use to do (e.g. vmprof uses ~1000 samples/s for time sampling), as the number of resulting samples, and thus overhead, depends on sampling rate and amount of memory allocated by the program.</p>
<p>For testing and benchmarking, we usually started with a sampling rate of 128Kb and then halved or doubled that (multiple times) depending on sample counts, our need for precision (and size of the profile).</p>
<h3 id="evaluation">Evaluation</h3>
<h4 id="overhead">Overhead</h4>
<p>Now let us take a look at the allocation sampling overhead, by profiling some benchmarks. </p>
<p>The x-axis shows the sampling rate, while the y-axis shows the overhead, which is computed as <code>runtime_with_sampling / runtime_without_sampling</code>.</p>
<p>All benchmarks were executed five times on a PyPy with JIT and native profiling enabled, so that every dot in the plot is one run of a benchmark.</p>
<p><img src="../images/2025_02_allocation_sampling_images/as_overhead.png"></p>
<p>As you probably expected, the Overhead drops with higher allocation sampling rates.
Reaching from as high as ~390% for 32kb allocation sampling to as low as &lt; 10% for 32mb.</p>
<p>Let me give one concrete example: One run of the microbenchmark at 32kb sampling took 15.596 seconds and triggered 822050 samples.
That makes a ridiculous amount of <code>822050 / 15.596 = ~52709</code> samples per second. </p>
<p>There is probably no need for that amount of samples per second, so that for 'real' application profiling a much higher sampling rate would be sufficient.</p>
<p>Let us compare that to time sampling.</p>
<p>This time we ran those benchmarks with 100, 1000 and 2000 samples per second.</p>
<p><img src="../images/2025_02_allocation_sampling_images/ts_overhead.png"></p>
<p>The overhead varies with the sampling rate. Both with allocation and time sampling, you can reach any amount of overhead and any level of profiling precision you want. The best approach probably is to just try out a sampling rate and choose what gives you the right tradeoff between precision and overhead (and disk usage).</p>
<p>The benchmarks used are:</p>
<p>microbenchmark </p>
<ul>
<li><a href="https://github.com/Cskorpion/microbenchmark">https://github.com/Cskorpion/microbenchmark</a></li>
<li><code>pypy microbench.py 65536</code></li>
</ul>
<p>gcbench </p>
<ul>
<li><a href="https://github.com/pypy/pypy/blob/main/rpython/translator/goal/gcbench.py">https://github.com/pypy/pypy/blob/main/rpython/translator/goal/gcbench.py</a></li>
<li>print statements removed</li>
<li><code>pypy gcbench.py 1</code></li>
</ul>
<p>pypy translate step</p>
<ul>
<li>first step of the pypy translation (annotation step)</li>
<li><code>pypy path/to/rpython --opt=0 --cc=gcc --dont-write-c-files --gc=incminimark --annotate path/to/pypy/goal/targetpypystandalone.py</code></li>
</ul>
<p>interpreter pystone</p>
<ul>
<li>pystone benchmark on top of an interpreted pypy on top of a translated pypy</li>
<li><code>pypy path/to/pypy/bin/pyinteractive.py -c "import test.pystone; test.pystone.main(1)"</code></li>
</ul>
<p>All benchmarks executed on:</p>
<ul>
<li>Kubuntu 24.04</li>
<li>AMD Ryzen 7 5700U</li>
<li>24gb DDR4 3200MHz (dual channel)</li>
<li>
<p>SSD benchmarking at read: 1965 MB/s, write: 227 MB/s</p>
<ul>
<li>Sequential 1MB 1 Thread 8 Queues</li>
</ul>
</li>
<li>
<p>Self built PyPy with allocation sampling features</p>
<ul>
<li><a href="https://github.com/Cskorpion/pypy/tree/gc_allocation_sampling_u_2.7">https://github.com/Cskorpion/pypy/tree/gc_allocation_sampling_u_2.7</a></li>
</ul>
</li>
<li>
<p>Modified VMProf with allocation sampling support</p>
<ul>
<li><a href="https://github.com/Cskorpion/vmprof-python/tree/pypy_gc_allocation_sampling">https://github.com/Cskorpion/vmprof-python/tree/pypy_gc_allocation_sampling</a></li>
</ul>
</li>
</ul>
<h4 id="example">Example</h4>
<p>We have also modified <a href="https://github.com/Cskorpion/vmprof-firefox-converter/tree/allocation_sampling">vmprof-firefox-converter</a> to show the allocation samples in the Firefor Profiler UI. With the techniques from this post, the output looks like this:</p>
<p><img src="../images/2025_02_allocation_sampling_images/allocation_sampling_call_tree.png"></p>
<p>While this view is interesting, it would be even better if we could also see what types of objects are being allocated in these functions. We will take about how to do this in a future blog post.</p>
<h3 id="conclusion">Conclusion</h3>
<p>In this blog post we introduced allocation sampling for PyPy by going through the technical aspects and the corresponding overhead. In a future blog post, we are going to dive into the actual usage of allocation sampling with VMProf, and show an example case study. That will be accompanied by some new improvements and additional features, like extracting the type of an object that triggered a sample.</p>
<p>So far all this work is still experimental and happening on PyPy branches but
we hope to get the technique stable enough to merge it to main and ship it with
PyPy eventually.</p>
<p>-- Christoph Jung and CF Bolz-Tereick</p>
    </div>
    </article><article class="h-entry post-rst" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2025/02/pypy-v7318-release.html" class="u-url">PyPy v7.3.18 release</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/mattip.html">mattip</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2025/02/pypy-v7318-release.html" rel="bookmark">
            <time class="published dt-published" datetime="2025-02-06T12:00:00Z" itemprop="datePublished" title="2025-02-06 12:00">2025-02-06 12:00</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <section id="pypy-v7-3-18-release-of-python-2-7-3-10-and-3-11-beta"><h2>PyPy v7.3.18: release of python 2.7, 3.10 and 3.11 beta</h2>
<p>The PyPy team is proud to release version 7.3.18 of PyPy.</p>
<p>This release includes a python 3.11 interpreter. We are labelling it "beta"
because it is the first one. In the next release we will drop 3.10 and remove
the "beta" label. There are a particularly large set of bugfixes in this
release thanks to @devdanzin using fusil on the 3.10 builds, originally written
by Victor Stinner. Other significant changes:</p>
<ul class="simple">
<li><p>We have updated libffi shipped in our portable builds. We also now statically
link to libffi where possible which reduces the number of
shared object dependencies.</p></li>
<li><p>We have added code to be able to show the native function names when
profiling with VMProf. So far only Linux supports this feature.</p></li>
<li><p>We have added a <a class="reference external" href="https://peps.python.org/pep-0768/">PEP 768</a>-inspired remote debugging facility.</p></li>
<li><p>The HPy backend has been updated to latest HPy HEAD</p></li>
</ul>
<p>The release includes three different interpreters:</p>
<ul class="simple">
<li><p>PyPy2.7, which is an interpreter supporting the syntax and the features of
Python 2.7 including the stdlib for CPython 2.7.18+ (the <code class="docutils literal">+</code> is for
backported security updates)</p></li>
<li><p>PyPy3.10, which is an interpreter supporting the syntax and the features of
Python 3.10, including the stdlib for CPython 3.10.16.</p></li>
<li><p>PyPy3.11, which is an interpreter supporting the syntax and the features of
Python 3.11, including the stdlib for CPython 3.11.11.</p></li>
</ul>
<p>The interpreters are based on much the same codebase, thus the triple
release. This is a micro release, all APIs are compatible with the other 7.3
releases. It follows after 7.3.17 release on August 28, 2024.</p>
<p>We recommend updating. You can find links to download the releases here:</p>
<blockquote>
<p><a class="reference external" href="https://pypy.org/download.html">https://pypy.org/download.html</a></p>
</blockquote>
<p>We would like to thank our donors for the continued support of the PyPy
project. If PyPy is not quite good enough for your needs, we are available for
<a class="reference external" href="https://www.pypy.org/pypy-sponsors.html">direct consulting</a> work. If PyPy is helping you out, we would love to hear
about it and encourage submissions to our <a class="reference external" href="https://pypy.org/blog">blog</a> via a pull request
to <a class="reference external" href="https://github.com/pypy/pypy.org">https://github.com/pypy/pypy.org</a></p>
<p>We would also like to thank our contributors and encourage new people to join
the project. PyPy has many layers and we need help with all of them: bug fixes,
<a class="reference external" href="https://doc.pypy.org/">PyPy</a> and <a class="reference external" href="https://rpython.readthedocs.org">RPython</a> documentation improvements, or general <a class="reference external" href="https://doc.pypy.org/en/latest/project-ideas.html">help</a> with
making RPython's JIT even better.</p>
<p>If you are a python library maintainer and use C-extensions, please consider
making a <a class="reference external" href="https://hpyproject.org/">HPy</a> / <a class="reference external" href="https://cffi.readthedocs.io">CFFI</a> / <a class="reference external" href="https://cppyy.readthedocs.io">cppyy</a> version of your library that would be performant
on PyPy. In any case, both <a class="reference external" href="https://github.com/joerick/cibuildwheel">cibuildwheel</a> and the <a class="reference external" href="https://github.com/matthew-brett/multibuild">multibuild system</a> support
building wheels for PyPy.</p>
<section id="vmprof-native-symbol-names"><h3>VMProf Native Symbol Names</h3>
<p>When running VMProf profiling with native profiling enabled, PyPy did so far
not produce function names for C functions. The output looked like this:</p>
<pre class="literal-block">pypy -m vmprof ~/projects/gitpypy/lib-python/2.7/test/pystone.py
Pystone(1.1) time for 50000 passes = 0.0109887
This machine benchmarks at 4.55011e+06 pystones/second
 vmprof output:
 %:      name:                location:
 100.0%  entry_point          &lt;builtin&gt;/app_main.py:874
 100.0%  run_command_line     &lt;builtin&gt;/app_main.py:601
 100.0%  run_toplevel         &lt;builtin&gt;/app_main.py:93
 100.0%  _run_module_as_main  /home/user/bin/pypy-c-jit-170203-99a72243b541-linux64/lib-python/2.7/runpy.py:150
 100.0%  _run_code            /home/user/bin/pypy-c-jit-170203-99a72243b541-linux64/lib-python/2.7/runpy.py:62
 100.0%  &lt;module&gt;             /home/user/bin/pypy-c-jit-170203-99a72243b541-linux64/site-packages/vmprof/__main__.py:1
 100.0%  main                 /home/user/bin/pypy-c-jit-170203-99a72243b541-linux64/site-packages/vmprof/__main__.py:30
 100.0%  run_path             /home/user/bin/pypy-c-jit-170203-99a72243b541-linux64/lib-python/2.7/runpy.py:238
 100.0%  _run_module_code     /home/user/bin/pypy-c-jit-170203-99a72243b541-linux64/lib-python/2.7/runpy.py:75
 100.0%  &lt;module&gt;             /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:3
 100.0%  main                 /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:60
 100.0%  pystones             /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:67
 100.0%  Proc0                /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:79
 76.9%   &lt;unknown code&gt;
 69.2%   &lt;unknown code&gt;
 53.8%   &lt;unknown code&gt;
 53.8%   &lt;unknown code&gt;
 46.2%   &lt;unknown code&gt;
 46.2%   &lt;unknown code&gt;
 38.5%   &lt;unknown code&gt;
 38.5%   Proc8                /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:212
 30.8%   &lt;unknown code&gt;
 ...</pre>
<p>We can now symbolify these C functions and give function names and which
shared library they come from, at least on Linux:</p>
<pre class="literal-block">Pystone(1.1) time for 50000 passes = 0.218967
This machine benchmarks at 228345 pystones/second
 vmprof output:
 %:      name:                                           location:
 100.0%  entry_point                                     &lt;builtin&gt;/app_main.py:889
 100.0%  run_command_line                                &lt;builtin&gt;/app_main.py:616
 100.0%  run_toplevel                                    &lt;builtin&gt;/app_main.py:95
 100.0%  _run_module_as_main                             /home/user/projects/gitpypy/lib-python/2.7/runpy.py:150
 100.0%  _run_code                                       /home/user/projects/gitpypy/lib-python/2.7/runpy.py:62
 100.0%  &lt;module&gt;                                        /home/user/projects/gitpypy/site-packages/vmprof/__main__.py:1
 100.0%  main                                            /home/user/projects/gitpypy/site-packages/vmprof/__main__.py:30
 100.0%  run_module                                      /home/user/projects/gitpypy/lib-python/2.7/runpy.py:179
 100.0%  _run_module_code                                /home/user/projects/gitpypy/lib-python/2.7/runpy.py:75
 100.0%  &lt;module&gt;                                        /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:3
 100.0%  main                                            /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:60
 100.0%  pystones                                        /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:67
 100.0%  Proc0                                           /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:79
 95.5%   n:pypy_g_execute_frame:0:pypy-c
 91.4%   n:pypy_g_PyFrame_dispatch:0:pypy-c
 63.8%   n:pypy_g_PyFrame_dispatch_bytecode:0:pypy-c
 49.8%   Proc1                                           /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:137
 17.6%   copy                                            /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:53
 13.6%   n:pypy_g_PyFrame_CALL_FUNCTION:0:pypy-c
 10.4%   Proc8                                           /home/user/projects/gitpypy/lib-python/2.7/test/pystone.py:212
 8.6%    n:pypy_g_STORE_ATTR_slowpath:0:pypy-c</pre>
<p>This becomes even more useful when using the <a class="reference external" href="https://github.com/Cskorpion/vmprof-firefox-converter/">VMProf Firefox converter</a>, which
uses the Firefox Profiler Web UI to visualize profiling output:</p>
<img alt="/images/2025-vmprof-firefox.png" src="../images/2025-vmprof-firefox.png"></section><section id="what-is-pypy"><h3>What is PyPy?</h3>
<p>PyPy is a Python interpreter, a drop-in replacement for CPython
It's fast (<a class="reference external" href="https://speed.pypy.org">PyPy and CPython</a> performance
comparison) due to its integrated tracing JIT compiler.</p>
<p>We also welcome developers of other <a class="reference external" href="https://rpython.readthedocs.io/en/latest/examples.html">dynamic languages</a> to see what RPython
can do for them.</p>
<p>We provide binary builds for:</p>
<ul class="simple">
<li><p><strong>x86</strong> machines on most common operating systems
(Linux 32/64 bits, Mac OS 64 bits, Windows 64 bits)</p></li>
<li><p>64-bit <strong>ARM</strong> machines running Linux (<code class="docutils literal">aarch64</code>) and macos (<code class="docutils literal">macos_arm64</code>).</p></li>
</ul>
<p>PyPy supports Windows 32-bit, Linux PPC64 big- and little-endian, Linux ARM
32 bit, RISC-V RV64IMAFD Linux, and s390x Linux but does not release binaries.
Please reach out to us if you wish to sponsor binary releases for those
platforms. Downstream packagers provide binary builds for debian, Fedora,
conda, OpenBSD, FreeBSD, Gentoo, and more.</p>
</section><section id="what-else-is-new"><h3>What else is new?</h3>
<p>For more information about the 7.3.18 release, see the <a class="reference external" href="https://doc.pypy.org/en/latest/release-v7.3.18.html#changelog">full changelog</a>.</p>
<p>Please update, and continue to help us make pypy better.</p>
<p>Cheers,
The PyPy Team</p>
</section></section>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2025/01/musings-tracing.html" class="u-url">Musings on Tracing in PyPy</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/cf-bolz-tereick.html">CF Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2025/01/musings-tracing.html" rel="bookmark">
            <time class="published dt-published" datetime="2025-01-05T17:01:09Z" itemprop="datePublished" title="2025-01-05 17:01">2025-01-05 17:01</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>Last summer, <a href="https://cs.brown.edu/~sk/">Shriram Krishnamurthi</a> <a href="https://twitter.com/ShriramKMurthi/status/1818009884484583459">asked on
Twitter</a>:</p>
<blockquote>
<p>"I'm curious what the current state of tracing JITs is. They used to be all the
rage for a while, then I though I heard they weren't so effective, then I
haven't heard of them at all. Is the latter because they are ubiquitous, or
because they proved to not work so well?"</p>
</blockquote>
<p>I replied with my personal (pretty subjective) opinions about the
question in a lengthy Twitter thread (which also spawned an even lengthier
discussion). I wanted to turn what I wrote there into a blog post to make it
more widely available (Twitter is no longer easily consumable without an
account), and also because I'm mostly not using Twitter anymore. The blog post
i still somewhat terse, I've written a small background section and tried to at
least add links to further information. Please ask in the comments if something
is particularly unclear.</p>
<h3 id="background">Background</h3>
<p>I'll explain a few of the central terms of the rest of the post. <em>JIT compilers</em>
are compilers that do their work at runtime, interleaved (or concurrent with)
the execution of the program. There are (at least) two common general styles of
JIT compiler architectures. The most common one is that of a method-based JIT,
which will compile one method or function at a time. Then there are tracing JIT
compilers, which generate code by tracing the execution of the user's program.
They often focus on loops as their main unit of compilation.</p>
<p>Then there is the distinction between a "regular" JIT compiler and that of a
<em>meta-JIT</em>. A regular JIT is built to compile one specific source language to
machine code. A meta-JIT is a framework for building JIT compilers for a
variety of different languages, reusing as much machinery as possible between
the different implementation.</p>
<h3 id="personal-and-project-context">Personal and Project Context</h3>
<p>Some personal context: my perspective is informed by nearly <a href="https://mail.python.org/archives/list/pypy-dev@python.org/thread/TZM37YJ733G445R6JGTV26333RQEPLRX/">two
decades</a>
of work on PyPy. PyPy's implementation language, <a href="https://rpython.readthedocs.io/">RPython</a>, has support for a
meta-JIT, which allows it to reuse its JIT infrastructure for the various
Python versions that we support (currently we do releases of PyPy2.7 and
PyPy3.10 together). Our meta-JIT infrastructure has been used for some
experimental different languages like:</p>
<ul>
<li>PyPy's <a href="https://pypy.org/posts/2010/11/pypy-14-ouroboros-in-practice-5437628000869417542.html#more-highlights">regular expression engine</a>
</li>
<li>
<a href="https://github.com/SOM-st/PySOM">RPySom</a>, a tiny Smalltalk</li>
<li><a href="https://github.com/topazproject/topaz">Ruby</a></li>
<li><a href="https://github.com/hippyvm/hippyvm">PHP</a></li>
<li>
<a href="https://dl.acm.org/doi/10.1145/1836089.1836102">Prolog</a>,</li>
<li>
<a href="https://dl.acm.org/doi/10.1145/2784731.2784740">Racket</a>,</li>
<li>a <a href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol056-ecoop2016/LIPIcs.ECOOP.2016.4/LIPIcs.ECOOP.2016.4.pdf">database (SQLite)</a>
</li>
<li>
<a href="https://www.youtube.com/watch?v=fZj3uljJl_k">Lox</a>, the language of <a href="https://craftinginterpreters.com/">Crafting Interpreters</a>
</li>
<li>an <a href="https://docs.pydrofoil.org/en/latest/">ARM and RISC-V emulator</a>
</li>
<li>and many more</li>
</ul>
<p>Those implementations had various degrees of maturity and many of them are
research software and aren't maintained any more.</p>
<p>PyPy gives itself the goal to try to be extremely compatible with all the
quirks of the Python language. We don't change the Python language to make
things easier to compile and we support the introspection and debugging
features of Python. We try very hard to have no opinions on language design.
The CPython core developers come up with the semantics, we somehow deal with
them.</p>
<h3 id="meta-tracing">Meta-tracing</h3>
<p>PyPy started using a <a href="https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation">tracing
JIT</a> approach
<em>not</em> because we thought method-based just-in-time compilers are bad.
Historically we <a href="https://foss.heptapod.net/pypy/extradoc/-/blob/branch/extradoc/eu-report/D08.2_JIT_Compiler_Architecture-2007-05-01.pdf">had
tried</a>
to implement a method-based meta-JIT that was using partial evaluation (we wrote
three or four method-based prototypes that all weren't as good as we hoped).
After all those <a href="https://pypy.org/posts/2008/10/sprint-discussions-jit-generator-3301578822967655604.html">experiments
failed</a>
we switched to the <a href="https://dl.acm.org/doi/10.1145/1565824.1565827">tracing
approach</a>, and only at this
point did our meta-JIT start producing interesting performance.</p>
<p>In the meta-JIT context tracing has good properties, because tracing has
relatively understandable behavior and its easy(ish) to tweak how things work
<a href="https://dl.acm.org/doi/10.1145/2069172.2069181">with extra annotations in the interpreter
source</a>.</p>
<p>Another reason why meta-tracing often works well for PyPy is that it can often
slice through the complicated layers of Python quite effectively and remove a
lot of overhead. Python is often described as simple, but I think that's
actually a misconception. On the implementation level it's a very big and
complicated language, and it is also continuously getting new features every
year (the language is quite a bit more complicated than Javascript, for
example<sup id="fnref:help"><a class="footnote-ref" href="../posts/2025/01/musings-tracing.html#fn:help">1</a></sup>).</p>
<h4 id="truffle">Truffle</h4>
<p>Later <a href="https://dl.acm.org/doi/abs/10.1145/2509578.2509581">Truffle</a> came along
and made a method-based meta-JIT using partial evaluation work. However Truffle
(and <a href="https://www.oracle.com/java/graalvm/">Graal</a>) has had significantly more people working on it and much more
money invested. In addition, it at first required a quite specific style of
<a href="https://dl.acm.org/doi/10.1145/2384577.2384587">AST-based interpreters</a> (in
the last few years they have also added support for bytecode-based
interpreters).</p>
<p>It's still my impression that getting similar results with Truffle is <a href="https://stefan-marr.de/downloads/oopsla15-marr-ducasse-meta-tracing-vs-partial-evaluation.pdf">more
work for language
implementers</a>
than with RPython, and the <a href="https://arxiv.org/pdf/1602.00602">warmup</a> of
Truffle can often pretty bad. But Truffle is definitely an existence proof that
meta-JITs don't <em>have</em> to be based on tracing.</p>
<h3 id="tracing-the-good">Tracing, the good</h3>
<p>Let's now actually get to he heart of Shriram's question and discuss some of
the advantages of tracing that go beyond the ease of using tracing for a
meta-JIT.</p>
<p>Tracing allows for doing very aggressive <a href="https://www.cs.fsu.edu/~xyuan/INTERACT-15/papers/paper11.pdf">partial
inlining</a>,
Following just the hot path through lots of layers of abstraction is obviously
often really useful for generating fast code.</p>
<p>It's definitely possible to achieve the same effect in a method-based context
with <a href="https://dl.acm.org/doi/pdf/10.1145/117954.117955">path splitting</a>. But it
requires a lot more implementation work and is not trivial, because the path
<a href="https://dl.acm.org/doi/10.1145/504282.504295">execution counts</a> of inlined
functions can often be very call-site dependent. Tracing, on the other hand,
gives you call-site dependent path splitting "for free".</p>
<p>(The aggressive partial inlining and path splitting is even more important in
the meta-tracing context of PyPy, where some of inlined layers are a part of
the language runtime, and where rare corner cases that are never executed in
practice are everywhere.)</p>
<p>Another advantage of tracing is that it makes a number of optimizations
really easy to implement, because there are (to first approximation) no control
flow merges. This makes all the optimizations that we do (super-)<a href="https://en.wikipedia.org/wiki/Optimizing_compiler#Local_vs._global_scope">local
optimizations</a>,
that operate on a single (very long) basic block. This allows the JIT to do the
optimizations in exactly one forwards and one backwards pass. An example is our
<a href="https://dl.acm.org/doi/10.1145/1929501.1929508">allocation removal</a>/partial
escape analysis pass, which is <a href="https://pypy.org/posts/2022/10/toy-optimizer-allocation-removal.html">quite
simple</a>,
whereas the <a href="https://ssw.jku.at/Teaching/PhDTheses/Stadler/Thesis_Stadler_14.pdf">version for general control
flow</a> has
a lot more complexity, particularly in its handling of loops.</p>
<p>This ease of implementation of optimizations allowed us to implement some
pretty decent optimizations. Our allocation removal, the way PyPy's JIT can
reason about the heap, about dictionary accesses, about properties of functions
of the runtime, about the range and <a href="https://pypy.org/posts/2024/08/toy-knownbits.html">known bits of integer
variables</a> is all quite
solid.</p>
<h3 id="tracing-the-bad">Tracing, the bad</h3>
<p>Tracing also comes with a significant number of downsides. Probably the biggest
one is that it tends to have big performance cliffs (PyPy certainly has them,
and other tracing JITs such as TraceMonkey had them too). In my experience the
'good' cases of tracing are really good, but if something goes wrong you are
annoyed and performance can become a lot slower. With a simple method JIT the
performance is often much more "even".</p>
<p>Another set of downsides is that tracing has a number of corner cases and
"weird" behaviour in certain situations. Questions such as:
- When do you stop inlining?
- What happens when you <a href="https://mail.python.org/archives/list/pypy-dev@python.org/thread/GQQ7ABUFHGEAHWN7RQZM6D54CDROQINR/">trace recursion</a>?
- What happens if your traces are <a href="https://pypy.org/posts/2021/09/jit-auto-generated-code.html">consistently too long, even without inlining</a>?
- and so on...</p>
<p>Some of these problems can be solved by adding heuristics to the tracing JIT,
but doing so loses a lot of the simplicity of tracing again.</p>
<p>There are also some classes of programs that tend to generally perform quite
poorly when they are executed by a tracing JIT, bytecode interpreters in
particularly, and other extremely unpredictably branchy code. This is because
the core assumption of the tracing jit "loops take similar control flow paths"
is just really wrong in the case of interpreters.</p>
<h3 id="discussion">Discussion</h3>
<p>The Twitter thread spawned quite a bit of discussion, please look at the
original thread for all of the comments. Here are three that I wanted to
highlight:</p>
<blockquote>
<p>"This is a really great summary. Meta-tracing is probably the one biggest
success story. I think it has to do with how big and branchy the bytecode
implementations are for typical dynamic languages; the trace captures latent
type feedback naturally.</p>
<p>There is an upper limit, tho."</p>
</blockquote>
<p><a href="https://twitter.com/TitzerBL/status/1818385622203298265">Ben Titzer</a></p>
<p>I agree with this completely. The complexity of Python bytecodes is a big
factor for why meta tracing works well for us. But also in Python there are
many builtin types (collection types, types that form the <a href="https://en.wikipedia.org/wiki/Metaobject#Metaobject_protocol">meta-object
protocol</a> of
Python, standard library modules implemented in C/RPython) and tracing
operations on them is very important too, for good performance.</p>
<hr>
<blockquote>
<p>"I think Mozilla had a blog post talking more about the difficulty with
TraceMonkey, could only find this one:
https://blog.mozilla.org/nnethercote/category/jagermonkey/"</p>
</blockquote>
<p><a href="https://twitter.com/smarr/status/1818600052752797990">Stefan Marr</a></p>
<blockquote>
<p>"imo doing tracing for JS is really hard mode, because the browser is so
incredibly warmup-sensitive. IIRC tracemonkey used a really low loop trip count
(single-digit?) to decide when to start tracing (pypy uses &gt;1000). the JS
interpreters of the time were also quite slow."</p>
</blockquote>
<p><a href="https://twitter.com/cfbolz/status/1818609594219811245">me</a></p>
<p>In the meantime there were some more reminiscences about tracing in Javascript
by <a href="https://www.youtube.com/live/_VF3pISRYRc?t=24797s">Shu-Yu Guo in a panel
discussion</a> and by <a href="https://kfogel.org/notice/AngH0uqyJl231yLLOa">Jason
Orendorff on Mastodon</a>.</p>
<hr>
<blockquote>
<p>"There are a number of corner cases you have to deal with in a tracing JIT. It's
unfortunately not as simple and easy as the initial papers would have you
believe. One example is how would you deal with a loop inside a loop? Is your
tracing now recursive?</p>
<p>There's been some research work on trace stitching to deal with trace explosion
but it does add complexity. With the increase in complexity, I think most
industrial VM developers would rather pick tried-and-true method-based JITs
that are well understood."</p>
</blockquote>
<p><a href="https://twitter.com/Love2Code/status/1818292516753383644">Maxime Chevalier</a></p>
<h3 id="conclusion">Conclusion</h3>
<p>Given access to enough developers and in the context of "normal" jitting (ie
not meta-jitting) it's very unclear to me that you should use tracing. It makes
more sense to rather spend effort on a solid control-flow-graph-based baseline
and then try to get some of the good properties of tracing on top (path
splitting, partial inlining, partial escape analysis, etc).</p>
<p>For PyPy with its meta-JIT (and the fact that we don't have particularly much
funding nor people) I still think tracing was/is a relatively pragmatic choice.
When I talked with <a href="https://samth.github.io/">Sam Tobin-Hochstadt</a> about this
topic recently he characterized it like this: "tracing is a labor-saving device
for compiler authors".</p>
<p>Performance-wise PyPy is still quite hard to beat in the cases where it works
well (i.e. pure Python code that doesn't use too many C modules, which are
<a href="https://pypy.org/posts/2018/09/inside-cpyext-why-emulating-cpython-c-8083064623681286567.html">supported but slow in
PyPy</a>).
In general, there are very few JITs for Python (particularly with the
constraint of not being "allowed" to change the language), the most competitive
other ones are <a href="https://www.graalvm.org/python/">GraalPy</a>, also based on a
meta-JIT approach. Instagram is running on
<a href="https://github.com/facebookincubator/cinder/">Cinder</a> and also CPython has
<a href="https://tonybaloney.github.io/posts/python-gets-a-jit.html">grown a JIT
recently</a> which
was part of the recent <a href="https://docs.python.org/3.13/whatsnew/3.13.html#an-experimental-just-in-time-jit-compiler">3.13 release, but only as an off-by-default build
option</a>,
so I'm very excited about how Python's performance will develop in the next
years!</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:help">
<p>(A side point: people who haven't worked on Python tend to
underestimate its complexity and pace of development. A pet peeve of mine
is C++ compiler devs/static analysis/Javascript people/other well-meaning
communities coming with statements like "why don't you just..."  🤷‍♀️) <a class="footnote-backref" href="../posts/2025/01/musings-tracing.html#fnref:help" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
</ol>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2025/01/towards-pypy311-an-update.html" class="u-url">Towards PyPy3.11 - an update</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/mattip.html">mattip</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2025/01/towards-pypy311-an-update.html" rel="bookmark">
            <time class="published dt-published" datetime="2025-01-04T13:29:11Z" itemprop="datePublished" title="2025-01-04 13:29">2025-01-04 13:29</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <div>
<p>We<sup id="fnref:0"><a class="footnote-ref" href="../posts/2025/01/towards-pypy311-an-update.html#fn:0">1</a></sup> are steadily working towards a Python 3.11 interpreter, which will be part
of the upcoming PyPy 7.3.18 release. Along with that, we also recently updated 
<a href="https://speed.pypy.org">speed.pypy.org</a> to compare PyPy's performance to CPython
3.11 (it used to be CPython 3.7). </p>
<p class="more"><a href="../posts/2025/01/towards-pypy311-an-update.html">Read more…</a></p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2024/11/guest-post-final-encoding-in-rpython.html" class="u-url">Guest Post: Final Encoding in RPython Interpreters</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/corbin.html">Corbin</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2024/11/guest-post-final-encoding-in-rpython.html" rel="bookmark">
            <time class="published dt-published" datetime="2024-11-14T08:42:36Z" itemprop="datePublished" title="2024-11-14 08:42">2024-11-14 08:42</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <h3 id="introduction">Introduction</h3>
<p>This post started as a quick note summarizing a recent experiment I carried
out upon a small RPython interpreter by rewriting it in an uncommon style. It
is written for folks who have already written some RPython and want to take a
deeper look at interpreter architecture.</p>
<p>Some experiments are about finding solutions to problems. This experiment is
about taking a solution which is already well-understood and applying it in
the context of RPython to find a new approach. As we will see, there is no
real change in functionality or the number of clauses in the interpreter; it's
more like a comparison between endo- and exoskeletons, a different arrangement
of equivalent bones and plates.</p>
<h3 id="overview">Overview</h3>
<p>An RPython interpreter for a programming language generally does three or four
things, in order:</p>
<ol>
<li>Read and parse input programs</li>
<li>Encode concrete syntax as abstract syntax</li>
<li>
<em>Optionally</em>, optimize or reduce the abstract syntax</li>
<li>Evaluate the abstract syntax: read input data, compute, print output data,
   etc.</li>
</ol>
<p>Today we'll look at abstract syntax. Most programming languages admit a
<a href="https://en.wikipedia.org/wiki/Parse_tree">concrete parse tree</a> which is
readily abstracted to provide an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax
tree</a> (AST). The AST is
usually encoded with the <em>initial</em> style of encoding. An initial encoding can
be transformed into any other encoding for the same AST, looks like a
hierarchy of classes, and is implemented as a static structure on the heap.</p>
<p>In contrast, there is also a <em>final</em> encoding. A final encoding can be
transformed into by any other encoding, looks like an interface for the
actions of the interpreter, and is implemented as an unwinding structure on
the stack. From the RPython perspective, Python builtin modules like <code>os</code> or
<code>sys</code> are final encodings for features of the operating system; the underlying
implementation is different when translated or untranslated, but the interface
used to access those features does not change.</p>
<p>In RPython, an initial encoding is built from a hierarchy of classes. Each
class represents a type of tree nodes, corresponding to a parser production in
the concrete parse tree. Each class instance therefore represents an
individual tree node. The fields of a class, particularly those filled during
<code>.__init__()</code>, store pre-computed properties of each node; methods can be used
to compute node properties on demand. This seems like an obvious and simple
approach; what other approaches could there be? We need an example.</p>
<h3 id="final-encoding-of-brainfuck">Final Encoding of Brainfuck</h3>
<p>We will consider <a href="https://esolangs.org/wiki/Brainfuck">Brainfuck</a>, a simple
Turing-complete programming language. An example Brainfuck program might be:</p>
<div class="code"><pre class="code literal-block"><span class="k">[</span><span class="nb">-</span><span class="k">]</span>
</pre></div>

<p>This program is built from a loop and a decrement, and sets a cell to zero. In
an initial encoding which follows the <a href="https://esolangs.org/wiki/Algebraic_Brainfuck">algebraic semantics of
Brainfuck</a>, the program could
be expressed by applying class constructors to build a structure on the heap:</p>
<div class="code"><pre class="code literal-block"><span class="n">Loop</span><span class="p">(</span><span class="n">Plus</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>

<p>A final encoding is similar, except that class constructors are replaced by
methods, the structure is built on the stack, and we are parameterized over
the choice of class:</p>
<div class="code"><pre class="code literal-block"><span class="k">lambda</span> <span class="bp">cls</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">loop</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>

<p>In ordinary Python, transforming between these would be trivial, and mostly is
a matter of passing around the appropriate class. Indeed, initial and final
encodings are equivalent; we'll return to that fact later. However, in RPython,
all of the types must line up, and classes must be determined before
translation. We'll need to monomorphize our final encodings, using some
RPython tricks later on. Before that, let's see what an actual Brainfuck
interface looks like, so that we can cover all of the difficulties with final
encoding.</p>
<p>Before we embark, please keep in mind that local code doesn't know what <code>cls</code>
is. There's no type-safe way to inspect an arbitrary semantic domain. In the
initial-encoded version, we can ask <code>isinstance(bf, Loop)</code> to see whether an
AST node is a loop, but there simply isn't an equivalent for final-encoded
ASTs. So, there is an implicit challenge to think about: how do we evaluate a
program in an arbitrary semantic domain? For bonus points, how do we optimize
a program without inspecting the types of its AST nodes?</p>
<p>What follows is a dissection of
<a href="https://github.com/rpypkgs/rpypkgs/blob/d439d225b79ac82e009a5f1cd1c670f00356464c/bf/bf.py">this</a>
module at the given revision. Readers may find it satisfying to read the
entire interpreter top to bottom first; it is less than 300 lines.</p>
<h4 id="core-functionality">Core Functionality</h4>
<p>Final encoding is given as methods on an interface. These five methods
correspond precisely to the summands of the algebra of Brainfuck.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">BF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Other methods elided</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bfs</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>

<p>Note that the <code>.loop()</code> method takes another program as an argument.
Initial-encoded ASTs have other initial-encoded ASTs as fields on class
instances; final-encoded ASTs have other final-encoded ASTs as parameters
to interface methods. RPython infers all of the types, so the reader has to
know that <code>i</code> is usually an integer while <code>bfs</code> is a sequence of Brainfuck
operations.</p>
<p>We're using a class to implement this functionality. Later, we'll treat it as
a mixin, rather than a superclass, to avoid typing problems.</p>
<h4 id="monoid">Monoid</h4>
<p>In order to optimize input programs, we'll need to represent the underlying
<a href="https://en.wikipedia.org/wiki/Monoid">monoid</a> of Brainfuck programs. To do
this, we add the signature for a monoid:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">BF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Other methods elided</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>

<p>This is technically a <a href="https://en.wikipedia.org/wiki/Magma_(algebra)">unital
magma</a>, since RPython doesn't
support algebraic laws, but we will enforce the algebraic laws later on during
optimization. We also want to make use of the folklore that <a href="https://en.wikipedia.org/wiki/Free_monoid">free
monoids</a> are lists, allowing
callers to pass a list of actions which we'll reduce with recursion:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">BF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Other methods elided</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">joinList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bfs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bfs</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bfs</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joinList</span><span class="p">(</span><span class="n">bfs</span><span class="p">[:</span><span class="n">i</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">joinList</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="n">i</span><span class="p">:]))</span>
</pre></div>

<p><code>.joinList()</code> is a little bulky to implement, but Wirth's principle applies:
the interpreter is shorter with it than without it.</p>
<h4 id="idioms">Idioms</h4>
<p>Finally, our interface includes a few high-level idioms, like the zero program
shown earlier, which are defined in terms of low-level behaviors. In an
initial encoding, these could be defined as module-level functions; here, we
define them on the mixin class <code>BF</code>.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">BF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Other methods elided</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalemove</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">move2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalemove2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scalemove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joinList</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">)]))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scalemove2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joinList</span><span class="p">([</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="o">-</span><span class="n">j</span><span class="p">)]))</span>
</pre></div>

<h3 id="interface-oriented-architecture">Interface-oriented Architecture</h3>
<h4 id="applying-interfaces">Applying Interfaces</h4>
<p>Now, we hack at RPython's object model until everything translates. First,
consider the task of pretty-printing. For Brainfuck, we'll simply regurgitate
the input program as a Python string:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">AsStr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">import_from_mixin</span><span class="p">(</span><span class="n">BF</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s2">""</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="s1">'+'</span> <span class="o">*</span> <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">'-'</span> <span class="o">*</span> <span class="o">-</span><span class="n">i</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="s1">'&gt;'</span> <span class="o">*</span> <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">'&lt;'</span> <span class="o">*</span> <span class="o">-</span><span class="n">i</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bfs</span><span class="p">):</span> <span class="k">return</span> <span class="s1">'['</span> <span class="o">+</span> <span class="n">bfs</span> <span class="o">+</span> <span class="s1">']'</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s1">','</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s1">'.'</span>
</pre></div>

<p>Via <code>rlib.objectmodel.import_from_mixin</code>, no stressing with covariance of
return types is required. Instead, we shift from a Java-esque view of classes
and objects, to an OCaml-ish view of prebuilt classes and constructors.
<code>AsStr</code> is monomorphic, and any caller of it will have to create their own
covariance somehow. For example, here are the first few lines of the parsing
function:</p>
<div class="code"><pre class="code literal-block"><span class="nd">@specialize</span><span class="o">.</span><span class="n">argtype</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">parse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">domain</span><span class="o">.</span><span class="n">unit</span><span class="p">()]</span>
    <span class="c1"># Parser elided to preserve the reader's attention</span>
</pre></div>

<p>By invoking <code>rlib.objectmodel.specialize.argtype</code>, we make copies of the
parsing function, up to one per call site, based on our choice of semantic
domain. <a href="https://okmij.org/ftp/tagless-final/">Oleg</a> calls these "symantics"
but I prefer "domain" in code. Also, note how the parsing stack starts with
the unit of the monoid, which corresponds to the empty input string; the
parser will repeatedly use the monoidal join to build up a parsed expression
without inspecting it. Here's a small taste of that:</p>
<div class="code"><pre class="code literal-block"><span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">char</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">'+'</span><span class="p">:</span> <span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">domain</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">'-'</span><span class="p">:</span> <span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">domain</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># and so on</span>
</pre></div>

<p>The reader may feel justifiably mystified; what breaks if we don't add these
magic annotations? Well, the translator will throw <code>UnionError</code> because the
low-level types don't match. RPython only wants to make one copy of functions
like <code>parse()</code> in its low-level representation, and each copy of <code>parse()</code>
will be compiled to monomorphic machine code. In this interpreter, in order to
support parsing to an optimized string and also parsing to an evaluator, we
need two copies of <code>parse()</code>. <strong>It is okay to not fully understand this at
first.</strong></p>
<h4 id="composing-interfaces">Composing Interfaces</h4>
<p>Earlier, we noted that an interpreter can optionally optimize input programs
after parsing. To support this, we'll precompose a <a href="https://en.wikipedia.org/wiki/Peephole_optimization">peephole
optimizer</a> onto an
arbitrary domain. We could also postcompose with a parser instead, but that
sounds more difficult. Here are the relevant parts:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">makePeephole</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">stripDomain</span><span class="p">(</span><span class="n">bfs</span><span class="p">):</span> <span class="k">return</span> <span class="n">domain</span><span class="o">.</span><span class="n">joinList</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">bfs</span><span class="p">])</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Peephole</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="n">import_from_mixin</span><span class="p">(</span><span class="n">BF</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="p">[]</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span>
        <span class="c1"># Actual definition elided... for now...</span>
    <span class="k">return</span> <span class="n">Peephole</span><span class="p">,</span> <span class="n">stripDomain</span>
</pre></div>

<p>Don't worry about the actual optimization yet. What's important here is the
pattern of initialization of semantic domains. <code>makePeephole</code> is an
<a href="https://en.wikipedia.org/wiki/Standard_ML">SML</a>-style functor on semantic
domains: given a final encoding of Brainfuck, it produces another final
encoding of Brainfuck which incorporates optimizations. The helper
<code>stripDomain</code> is a finalizer which performs the extraction from the
optimizer's domain to the underlying <code>cls</code> that was passed in at translation
time. For example, let's optimize pretty-printing:</p>
<div class="code"><pre class="code literal-block"><span class="n">AsStr</span><span class="p">,</span> <span class="n">finishStr</span> <span class="o">=</span> <span class="n">makePeephole</span><span class="p">(</span><span class="n">AsStr</span><span class="p">)</span>
</pre></div>

<p>Now, it only takes one line to parse and print an optimized AST without ever
building it on the heap. To be pedantic, fragments of the output string will
be heap-allocated, but the AST's node structure will only ever be
stack-allocated. Further, to be shallow, the parser is written to prevent
malicious input from causing a stack overflow, and this forces it to maintain
a heap-allocated RPython list of intermediate operations inside loops.</p>
<div class="code"><pre class="code literal-block"><span class="nb">print</span> <span class="n">finishStr</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">AsStr</span><span class="p">()))</span>
</pre></div>

<h3 id="performance">Performance</h3>
<p>But is it fast? Yes. It's faster than the prior version, which was
initial-encoded, and also faster than Andrew Brown's classic version (<a href="https://pypy.org/posts/2011/04/tutorial-writing-interpreter-with-pypy-3785910476193156295.html">part
1</a>,
<a href="https://pypy.org/posts/2011/04/tutorial-part-2-adding-jit-8121732841568309472.html">part
2</a>).
Since Brown's interpreter does not perform much optimization, we will focus on
how final encoding can outperform initial encoding.</p>
<h4 id="jit">JIT</h4>
<p>First, why is it faster than the same interpreter with initial encoding? Well,
it still has initial encoding from the JIT's perspective! There is an <code>Op</code>
class with a hierarchy of subclasses implementing individual behaviors. A
sincere tagless-final student, or those who remember <a href="https://pyvideo.org/pycon-us-2012/stop-writing-classes.html">Stop Writing Classes
(2012, Pycon
US)</a>, will
recognize that the following classes could be plain functions, and should
think of the classes as a concession to RPython's lack of support for lambdas
with closures rather than an initial encoding. We aren't ever going to
directly typecheck any <code>Op</code>, but the JIT will generate typechecking guards
anyway, so we effectively get a fully-promoted AST inlined into each JIT
trace. First, some simple behaviors:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Op</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="n">_immutable_</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_Input</span><span class="p">(</span><span class="n">Op</span><span class="p">):</span>
    <span class="n">_immutable_</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">runOn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tape</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">tape</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">position</span>
<span class="n">Input</span> <span class="o">=</span> <span class="n">_Input</span><span class="p">()</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_Output</span><span class="p">(</span><span class="n">Op</span><span class="p">):</span>
    <span class="n">_immutable_</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">runOn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tape</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">chr</span><span class="p">(</span><span class="n">tape</span><span class="p">[</span><span class="n">position</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">position</span>
<span class="n">Output</span> <span class="o">=</span> <span class="n">_Output</span><span class="p">()</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Add</span><span class="p">(</span><span class="n">Op</span><span class="p">):</span>
    <span class="n">_immutable_</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_immutable_fields_</span> <span class="o">=</span> <span class="s2">"imm"</span><span class="p">,</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imm</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">imm</span> <span class="o">=</span> <span class="n">imm</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">runOn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tape</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">tape</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imm</span>
        <span class="k">return</span> <span class="n">position</span>
</pre></div>

<p>The JIT does technically have less information than before; it no longer knows
that a sequence of immutable operations is immutable enough to be worth
unrolling, but a bit of <code>rlib.jit.unroll_safe</code> fixes that:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Seq</span><span class="p">(</span><span class="n">Op</span><span class="p">):</span>
    <span class="n">_immutable_</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_immutable_fields_</span> <span class="o">=</span> <span class="s2">"ops[*]"</span><span class="p">,</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span>
    <span class="nd">@unroll_safe</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">runOn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tape</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span> <span class="n">position</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">runOn</span><span class="p">(</span><span class="n">tape</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">position</span>
</pre></div>

<p>Finally, the JIT entry point is at the head of each loop, just like with prior
interpreters. Since Brainfuck doesn't support mid-loop jumps, there's no
penalty for only allowing merge points at the head of the loop.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Loop</span><span class="p">(</span><span class="n">Op</span><span class="p">):</span>
    <span class="n">_immutable_</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_immutable_fields_</span> <span class="o">=</span> <span class="s2">"op"</span><span class="p">,</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">runOn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tape</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span>
        <span class="k">while</span> <span class="n">tape</span><span class="p">[</span><span class="n">position</span><span class="p">]:</span>
            <span class="n">jitdriver</span><span class="o">.</span><span class="n">jit_merge_point</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">tape</span><span class="o">=</span><span class="n">tape</span><span class="p">)</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">runOn</span><span class="p">(</span><span class="n">tape</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">position</span>
</pre></div>

<p>That's the end of the implicit challenge. There's no secret to it; just
evaluate the AST. Here's part of the semantic domain for evaluation, as well
as the "functor" to optimize it. In <code>AsOps.join()</code> are the <em>only</em>
<code>isinstance()</code> calls in the entire interpreter! This is acceptable because
<code>Seq</code> is effectively a type wrapper for an RPython list, so that a list of
operations is also an operation; its list is initial-encoded and available for
inspection.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">AsOps</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">import_from_mixin</span><span class="p">(</span><span class="n">BF</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">Shift</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">Seq</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Seq</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Seq</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">ops</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">Seq</span><span class="p">):</span> <span class="k">return</span> <span class="n">Seq</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">ops</span> <span class="o">+</span> <span class="p">[</span><span class="n">r</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Seq</span><span class="p">):</span> <span class="k">return</span> <span class="n">Seq</span><span class="p">([</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Seq</span><span class="p">([</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">])</span>
    <span class="c1"># Other methods elided!</span>

<span class="n">AsOps</span><span class="p">,</span> <span class="n">finishOps</span> <span class="o">=</span> <span class="n">makePeephole</span><span class="p">(</span><span class="n">AsOps</span><span class="p">)</span>
</pre></div>

<p>And finally here is the actual top-level code to evaluate the input program.
As before, once everything is composed, the actual invocation only takes one
line.</p>
<div class="code"><pre class="code literal-block"><span class="n">tape</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span> <span class="o">*</span> <span class="n">cells</span><span class="p">)</span>
<span class="n">finishOps</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">AsOps</span><span class="p">()))</span><span class="o">.</span><span class="n">runOn</span><span class="p">(</span><span class="n">tape</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>

<h4 id="peephole-optimization">Peephole Optimization</h4>
<p>Our peephole optimizer is an <a href="https://en.wikipedia.org/wiki/Abstract_interpretation">abstract
interpreter</a> with one
instruction of lookahead/rewrite buffer. It implements the aforementioned
algebraic laws of the Brainfuck monoid. It also implements idiom recognition
for loops. First, the abstract interpreter. The abstract domain has six
elements:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">AbstractDomain</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>
<span class="n">meh</span><span class="p">,</span> <span class="n">aLoop</span><span class="p">,</span> <span class="n">aZero</span><span class="p">,</span> <span class="n">theIdentity</span><span class="p">,</span> <span class="n">anAdd</span><span class="p">,</span> <span class="n">aRight</span> <span class="o">=</span> <span class="p">[</span><span class="n">AbstractDomain</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
</pre></div>

<p>We'll also tag everything with an integer, so that <code>anAdd</code> or <code>aRight</code> can be
exact annotations. <em>This</em> is the actual <code>Peephole.join()</code> method:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span> <span class="k">return</span> <span class="n">r</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:]</span>
    <span class="n">bfHead</span><span class="p">,</span> <span class="n">adHead</span><span class="p">,</span> <span class="n">immHead</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">bf</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">imm</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ad</span> <span class="ow">is</span> <span class="n">theIdentity</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">adHead</span> <span class="ow">is</span> <span class="n">aLoop</span> <span class="ow">and</span> <span class="n">ad</span> <span class="ow">is</span> <span class="n">aLoop</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">adHead</span> <span class="ow">is</span> <span class="n">theIdentity</span><span class="p">:</span>
            <span class="n">bfHead</span><span class="p">,</span> <span class="n">adHead</span><span class="p">,</span> <span class="n">immHead</span> <span class="o">=</span> <span class="n">bf</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">imm</span>
        <span class="k">elif</span> <span class="n">adHead</span> <span class="ow">is</span> <span class="n">anAdd</span> <span class="ow">and</span> <span class="n">ad</span> <span class="ow">is</span> <span class="n">aZero</span><span class="p">:</span>
            <span class="n">bfHead</span><span class="p">,</span> <span class="n">adHead</span><span class="p">,</span> <span class="n">immHead</span> <span class="o">=</span> <span class="n">bf</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">imm</span>
        <span class="k">elif</span> <span class="n">adHead</span> <span class="ow">is</span> <span class="n">anAdd</span> <span class="ow">and</span> <span class="n">ad</span> <span class="ow">is</span> <span class="n">anAdd</span><span class="p">:</span>
            <span class="n">immHead</span> <span class="o">+=</span> <span class="n">imm</span>
            <span class="k">if</span> <span class="n">immHead</span><span class="p">:</span> <span class="n">bfHead</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="n">immHead</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rv</span><span class="p">:</span> <span class="n">bfHead</span><span class="p">,</span> <span class="n">adHead</span><span class="p">,</span> <span class="n">immHead</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bfHead</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                <span class="n">adHead</span> <span class="o">=</span> <span class="n">theIdentity</span>
        <span class="k">elif</span> <span class="n">adHead</span> <span class="ow">is</span> <span class="n">aRight</span> <span class="ow">and</span> <span class="n">ad</span> <span class="ow">is</span> <span class="n">aRight</span><span class="p">:</span>
            <span class="n">immHead</span> <span class="o">+=</span> <span class="n">imm</span>
            <span class="k">if</span> <span class="n">immHead</span><span class="p">:</span> <span class="n">bfHead</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">immHead</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rv</span><span class="p">:</span> <span class="n">bfHead</span><span class="p">,</span> <span class="n">adHead</span><span class="p">,</span> <span class="n">immHead</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bfHead</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                <span class="n">adHead</span> <span class="o">=</span> <span class="n">theIdentity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">bfHead</span><span class="p">,</span> <span class="n">adHead</span><span class="p">,</span> <span class="n">immHead</span><span class="p">))</span>
            <span class="n">bfHead</span><span class="p">,</span> <span class="n">adHead</span><span class="p">,</span> <span class="n">immHead</span> <span class="o">=</span> <span class="n">bf</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">imm</span>
    <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">bfHead</span><span class="p">,</span> <span class="n">adHead</span><span class="p">,</span> <span class="n">immHead</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rv</span>
</pre></div>

<p>If this were to get much longer, then <a href="https://pypy.org/posts/2024/10/jit-peephole-dsl.html">implementing a
DSL</a> would be worth it,
but this is a short-enough method to inline. The abstract interpretation is
assumed by induction for the left-hand side of the join, save for the final
instruction, which is loaded into a rewrite register. Each instruction on the
right-hand side is inspected exactly once. The logic for <code>anAdd</code> followed by
<code>anAdd</code> is exactly the same as for <code>aRight</code> followed by <code>aRight</code> because they
both have underlying <a href="https://en.wikipedia.org/wiki/Abelian_group">Abelian
groups</a> given by the integers.
The rewrite register is carefully pushed onto and popped off from the
left-hand side in order to cancel out <code>theIdentity</code>, which itself is merely a
unifier for <code>anAdd</code> or <code>aRight</code> of 0.</p>
<p>Note that we generate a lot of garbage. For example, parsing a string of <em>n</em>
'+' characters will cause the peephole optimizer to allocate <em>n</em> instances of
the underlying <code>domain.plus()</code> action, from <code>domain.plus(1)</code> up to
<code>domain.plus(n)</code>. An older initial-encoded version of this interpreter used
<a href="https://en.wikipedia.org/wiki/Hash_consing">hash consing</a> to avoid ever
building an op more than once, even loops. It appears more efficient to
generate lots of immutable garbage than to repeatedly hash inputs and search
mutable hash tables, at least for optimizing Brainfuck incrementally during
parsing.</p>
<p>Finally, let's look at idiom recognition. RPython lists are initial-coded, so
we can dispatch based on the length of the list, and then inspect the abstract
domains of each action.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">isConstAdd</span><span class="p">(</span><span class="n">bf</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="n">bf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">anAdd</span> <span class="ow">and</span> <span class="n">bf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span>

<span class="k">def</span><span class="w"> </span><span class="nf">oppositeShifts</span><span class="p">(</span><span class="n">bf1</span><span class="p">,</span> <span class="n">bf2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bf1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">bf2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">aRight</span> <span class="ow">and</span> <span class="n">bf1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="n">bf2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">oppositeShifts2</span><span class="p">(</span><span class="n">bf1</span><span class="p">,</span> <span class="n">bf2</span><span class="p">,</span> <span class="n">bf3</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">bf1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">bf2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">bf3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">aRight</span> <span class="ow">and</span>
            <span class="n">bf1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">bf2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">bf3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bfs</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">bf</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">imm</span> <span class="o">=</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ad</span> <span class="ow">is</span> <span class="n">anAdd</span> <span class="ow">and</span> <span class="n">imm</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="n">aZero</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isConstAdd</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">bfs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">anAdd</span> <span class="ow">and</span>
            <span class="n">oppositeShifts</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">3</span><span class="p">])):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">domain</span><span class="o">.</span><span class="n">scalemove</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">aLoop</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isConstAdd</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">anAdd</span> <span class="ow">and</span>
            <span class="n">oppositeShifts</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">domain</span><span class="o">.</span><span class="n">scalemove</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">aLoop</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isConstAdd</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">bfs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">anAdd</span> <span class="ow">and</span>
            <span class="n">oppositeShifts2</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">5</span><span class="p">])):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">domain</span><span class="o">.</span><span class="n">scalemove2</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                                       <span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                                       <span class="n">bfs</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">aLoop</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isConstAdd</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">anAdd</span> <span class="ow">and</span>
            <span class="n">oppositeShifts2</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">4</span><span class="p">])):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">domain</span><span class="o">.</span><span class="n">scalemove2</span><span class="p">(</span><span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                                       <span class="n">bfs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">bfs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                                       <span class="n">bfs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">aLoop</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[(</span><span class="n">domain</span><span class="o">.</span><span class="n">loop</span><span class="p">(</span><span class="n">stripDomain</span><span class="p">(</span><span class="n">bfs</span><span class="p">)),</span> <span class="n">aLoop</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
</pre></div>

<p>This ends the bonus question. How do we optimize an unknown semantic domain?
We must maintain an abstract context which describes elements of the domain.
In initial encoding, we ask an AST about itself. In final encoding, we already
know everything relevant about the AST.</p>
<p>The careful reader will see that I didn't really answer that opening question
in the JIT section. Because the JIT still ranges over the same operations as
before, it can't really be slower; but why is it now faster? Because the
optimizer is now slightly better in a few edge cases. It performs the same
optimizations as before, but the rigor of abstract interpretation causes it to
emit slightly better operations to the JIT backend.</p>
<p>Concretely, improving the optimizer can shorten pretty-printed programs. The
<a href="https://bbgauge.info/">Busy Beaver Gauge</a> measures the length of programs
which search for solutions to mathematical problems. After implementing and
debugging the final-encoded interpreter, I found that two of my entries on the
<a href="https://bbgauge.info/brainfuck.html">Busy Beaver Gauge for Brainfuck</a> had
become shorter by about 2%. (Most other entries are already hand-optimized
according to the standard algebra and have no optimization opportunities.)</p>
<h3 id="discussion">Discussion</h3>
<p>Given that initial and final encodings are equivalent, and noting that
RPython's toolchain is written to prefer initial encodings, what did we
actually gain? Did we gain anything?</p>
<p>One obvious downside to final encoding in RPython is interpreter size. The
example interpreter shown here is a rewrite of an initial-encoded interpreter
which can be seen
<a href="https://github.com/rpypkgs/rpypkgs/blob/659c8a26d428a1e04fdff614b28e464a50d4647b/bf/bf.py">here</a>
for comparison. Final encoding adds about 20% more code in this case.</p>
<p>Final encoding is not necessarily more code than initial encoding, though. All
AST encodings in interpreters are subject to the <a href="https://en.wikipedia.org/wiki/Expression_problem">Expression
Problem</a>, which states that
there is generally a quadratic amount of code required to implement multiple
behaviors for an AST with multiple types of nodes; specifically, <em>n</em> behaviors
for <em>m</em> types of nodes require <em>n</em> × <em>m</em> methods. Initial encodings improve the
cost of adding new types of nodes; final encodings improve the cost of adding
new behaviors. Final encoding may tend to win in large codebases for mature
languages, where the language does not change often but new behaviors are added
frequently and maintained for long periods.</p>
<p>Optimizations in final encoding require a bit of planning. The
abstract-interpretation approach is solid but relies upon the monoid and its
algebraic laws. In the worst case, an entire class hierarchy could be required
to encode the abstraction.</p>
<p>It is remarkable to find <strong>a 2% improvement in residual program size</strong> merely
by reimplementing an optimizer as an abstract interpreter respecting the
algebraic laws. This could be the most important lesson for compiler
engineers, if it happens to generalize.</p>
<p>Final encoding was popularized via the tagless-final movement in OCaml and
Scala, including famously in a series of tutorials by <a href="https://okmij.org/ftp/tagless-final/">Kiselyov et
al</a>. A "tag", in this jargon, is a
runtime identifier for an object's type or class; a tagless encoding
effectively doesn't allow <code>isinstance()</code> at all. In the above presentation,
tags could be hacked in, but were not materially relevant to most steps. Tags
were required for the final evaluation step, though, and the tagless-final
insight is that certain type systems can express type-safe evaluation without
those tags. We won't go further in this direction because tags also
communicate valuable information to the JIT.</p>
<h4 id="summarizing-table">Summarizing Table</h4>
<table>
<thead><tr>
<th>Initial Encoding</th>
<th>Final Encoding</th>
</tr></thead>
<tbody>
<tr>
<td>hierarchy of classes</td>
<td>signature of interfaces</td>
</tr>
<tr>
<td>class constructors</td>
<td>method calls</td>
</tr>
<tr>
<td>built on the heap</td>
<td>built on the stack</td>
</tr>
<tr>
<td>traversals allocate stack</td>
<td>traversals allocate heap</td>
</tr>
<tr>
<td>tags are available with <code>isinstance()</code>
</td>
<td>tags are only available through hacks</td>
</tr>
<tr>
<td>cost of adding a new AST node: one class</td>
<td>cost of adding a new AST node: one method on every other class</td>
</tr>
<tr>
<td>cost of adding a new behavior: one method on every other class</td>
<td>cost of adding a new behavior: one class</td>
</tr>
</tbody>
</table>
<h3 id="credits">Credits</h3>
<p>Thanks to folks in <code>#pypy</code> on Libera Chat: arigato for the idea, larstiq for
pushing me to write it up, and cfbolz and mattip for reviewing and finding
mistakes. The original IRC discussion leading to this blog post is available
<a href="https://gist.github.com/MostAwesomeDude/fd86ad2d2e38af7aa67b6e548aabe008">here</a>.</p>
<p>This interpreter is part of the <a href="https://github.com/rpypkgs/rpypkgs">rpypkgs</a>
suite, a Nix flake for RPython interpreters. Readers with Nix installed can
run this interpreter directly from the flake:</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>nix-prefetch-url<span class="w"> </span>https://github.com/MG-K/pypy-tutorial-ko/raw/refs/heads/master/mandel.b
$<span class="w"> </span>nix<span class="w"> </span>run<span class="w"> </span>github:rpypkgs/rpypkgs#bf<span class="w"> </span>--<span class="w"> </span>/nix/store/ngnphbap9ncvz41d0fkvdh61n7j2bg21-mandel.b
</pre></div>
    </div>
    </article>
</div>
</div>
<div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/12/toy-load-store.html" class="listtitle">Load and store forwarding in the Toy Optimizer</a>
      </li>
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (9)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (6)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div></div>
</main>
</div>
<div style="clear: both; width: 75%; margin: 1em auto;">
        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="index-45.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
         
                 <footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    © 2026 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
     
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
     
    Last built 2026-01-17T00:22
  </div>
  <div style="margin-left: auto">
  <a href="../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../assets/js/styles.js"></script></footer>
</body>
</html>