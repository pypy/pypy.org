<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="A Faster Python">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>PyPy (old posts, page 16) | PyPy</title>
<link href="../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../rss.xml">
<link rel="canonical" href="https://www.pypy.org/blog/index-16.html">
<link rel="icon" href="../favicon2.ico" sizes="16x16">
<link rel="icon" href="../favicon32x32.ico" sizes="32x32">
<link rel="prev" href="index-17.html" type="text/html">
<link rel="next" href="index-15.html" type="text/html">
<!--[if lt IE 9]><script src="../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../assets/css/tipuesearch.css">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../index.html">
                    <image id="toplogo" src="../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../compat.html">Compatibility</a> </li>  
                    <li> <a href="../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href=".">Index</a> </li>  
                    <li> <a href="../categories/">Tags</a> </li>  
                    <li> <a href="../archive.html">Archive by year</a> </li>  
                    <li> <a href="../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Searchâ€¦" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><div class="post">
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/12/leysin-winter-sprint-8115212435349091722.html" class="u-url">Leysin Winter sprint</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/armin-rigo.html">Armin Rigo</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/12/leysin-winter-sprint-8115212435349091722.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-12-08T17:52:00Z" itemprop="datePublished" title="2010-12-08 17:52">2010-12-08 17:52</time></a>
            </p>
                <p class="commentline">3 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Hi all,</p>

<table border="0"><tr>
<td>

<p>The <a href="https://codespeak.net/svn/pypy/extradoc/sprintinfo/leysin-winter-2011/announcement.txt">next sprint</a> will be in Leysin, Switzerland, during the week of the 16th-22nd of January 2011.</p>

<p>Now that we have released 1.4, and plan to release 1.4.1 soon, the sprint is going to be mainly working on fixing issues reported by various users.  Of course this does not prevent people from showing up with a more precise interest in mind.</p>

<p>As usual, the break day on the sprint will likely be a day of skiing :-)</p>

<p>Hoping to see you there.</p>

</td>
<td>
<img height="200" src="https://www.ermina.ch/assets/images/chalet2/chalet2_003.JPG" width="320">
</td>
</tr></table>
<p>Update: there are actually a number of branches that we want to polish and merge into trunk: at least <a href="https://codespeak.net/pipermail/pypy-dev/2010q3/006295.html">fast-forward</a>, <a href="https://codespeak.net/pipermail/pypy-svn/2010-September/043309.html">jit-unroll-loops</a>, <a href="https://codespeak.net/pipermail/pypy-svn/2010-September/043305.html">arm-backend</a> and <a href="https://codespeak.net/pipermail/pypy-svn/2010-November/044621.html">jitypes2</a>.  For more details, see the <a href="https://codespeak.net/svn/pypy/extradoc/sprintinfo/leysin-winter-2011/announcement.txt">announcement</a>.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-4434927350399891987">
        <div class="comment-header">
          <a name="comment-4434927350399891987"></a>
            <span class="author">Victor</span> wrote on <span class="date">2010-12-10 10:24</span>:
        </div>
        <div class="comment-content">
          <p>Armin,<br>Don't forget to ping pypy-sprint about this to avoid people getting confused again ;)</p>
        </div>
      </div>
      <div class="comment comment-8746986008101017991">
        <div class="comment-header">
          <a name="comment-8746986008101017991"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2010-12-10 16:28</span>:
        </div>
        <div class="comment-content">
          <p>Victor: sorry, I don't get you.  Do you mean, to tell people about the updates I did to the blog post?  Or just to send the announcement to pypy-sprint too (I only sent it to pypy-dev so far)?</p>
        </div>
      </div>
      <div class="comment comment-4633403652171194849">
        <div class="comment-header">
          <a name="comment-4633403652171194849"></a>
            <span class="author">Victor</span> wrote on <span class="date">2010-12-10 22:12</span>:
        </div>
        <div class="comment-content">
          <p>I meant just to send the announcement to pypy-sprint too. IIRC, someone looked there for the last sprint and got confused by the announcement of a sprint in the same month of last year.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/12/pypy-14-release-aftermath-2979780282210978576.html" class="u-url">PyPy 1.4 release aftermath</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/12/pypy-14-release-aftermath-2979780282210978576.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-12-01T14:16:00Z" itemprop="datePublished" title="2010-12-01 14:16">2010-12-01 14:16</time></a>
            </p>
                <p class="commentline">8 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>A couple days have passed since the announcement of the 1.4 release, and this
is a short summary of what happened afterwards. Let's start with
numbers:</p>
<ul class="simple">
<li>16k visits to the <a class="reference external" href="../posts/2010/11/pypy-14-ouroboros-in-practice-5437628000869417542.html">release announcement</a> on our blog</li>
<li>we don't have download statistics unfortunately</li>
<li>10k visits to <a class="reference external" href="https://speed.pypy.org">speed center</a>
</li>
<li>most traffic comes from referring sites, reddit alone creating above a third
of our traffic</li>
</ul>
<p>Not too bad for a project that doesn't have a well-established user base.</p>
<p>Lessons learned:</p>
<ul class="simple">
<li>Releases are very important. They're still the major way projects communicate
with community, even if we have nightly builds that are mostly stable.</li>
<li>No segfaults were reported, no incompatibilities between JIT and normal
interpretation. We think that proves (or at least provides a lot of
experimental evidence) that our write-once-and-then-transform method is
effective.</li>
<li>A lot of people complained about their favorite module in C not working, we
should have made it clearer that CPyExt is in <strong>alpha</strong> state.  Indeed, we
would like to know which C extension modules <strong>do</strong> work :-).</li>
<li>Some people reported massive speedups, other reported slowdowns compared
to CPython. Most of those slowdowns relate to modules being inefficient
(or doing happy nonsense), like ctypes. This is expected, given that
not all modules are even jitted (although having them jitted is usually
a matter of a couple of minutes).</li>
<li>Nobody complained about a lack of some stdlib module. We implemented the ones
which are used more often, but this makes us wonder if less used stdlib modules
have any users at all.</li>
</ul>
<p>In general feedback has been overwhelmingly positive and we would like to
thank everyone trying (and especially those reporting problems)</p>
<p>Cheers,<br>
fijal</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-7127708864487798220">
        <div class="comment-header">
          <a name="comment-7127708864487798220"></a>
            <span class="author">Bryan Murphy</span> wrote on <span class="date">2010-12-01 14:26</span>:
        </div>
        <div class="comment-content">
          <p>I love what you guys are doing.  Keep up the good work!</p>
        </div>
      </div>
      <div class="comment comment-451562739049034003">
        <div class="comment-header">
          <a name="comment-451562739049034003"></a>
            <span class="author">Leonardo Santagada</span> wrote on <span class="date">2010-12-01 17:07</span>:
        </div>
        <div class="comment-content">
          <p>There was a complain about the lack of ssl module by someone trying to use pg8000 with pypy. I wonder if pypy should focus on openssl or on the ssl module.</p>
        </div>
      </div>
      <div class="comment comment-947219114092529620">
        <div class="comment-header">
          <a name="comment-947219114092529620"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-12-01 20:47</span>:
        </div>
        <div class="comment-content">
          <p>pyglet actually seems to use the MacOS module to create some windows.</p>
        </div>
      </div>
      <div class="comment comment-7517960623519747436">
        <div class="comment-header">
          <a name="comment-7517960623519747436"></a>
            <span class="author">Paul Boddie</span> wrote on <span class="date">2010-12-02 00:16</span>:
        </div>
        <div class="comment-content">
          <p>I'm very impressed with what you've all achieved!<br><br>I've been testing PyPy 1.4 with some code I'm working on which only depends on two pure-Python non-stdlib libraries, and although the result was a 50% longer running time than with Python 2.5, it's remarkable that the code behaves in the same way and produces the same results. When trying to produce a fully compatible implementation of something, it's no trivial task to get identical behaviour (even though I'm not really using "exotic" or "frivolous" language features): some corner case usually comes along and makes things difficult. To see a non-trivial example work just like "normal Python" is surely evidence that PyPy is ready for a wider audience.<br><br>As for my code, I've been doing some profiling generally - it uses things like the array and bisect modules substantially - and will attempt to see how profile-directed improvements affect PyPy's performance.<br><br>Keep up the good work!</p>
        </div>
      </div>
      <div class="comment comment-2718573845492626498">
        <div class="comment-header">
          <a name="comment-2718573845492626498"></a>
            <span class="author">The Cannon Family</span> wrote on <span class="date">2010-12-03 07:11</span>:
        </div>
        <div class="comment-content">
          <p>A lot of the standard library looks like it has volumes of _legacy_ code depending on it, even if the current bleeding edge people use it less. In my mind supporting essentially all the standard library is a good long term goal, but as pointed out, parts of it can wait. Eventually I would like to see Tkinter support, and I would surmise that it is the most used of the stuff that is not implemented. We use it in a couple items (+/- 10% of total code, not likely to change). I would guess that the situations where these obscure parts of the standard library are being used are the parts were speed is maybe not the most important thing, supporting an existing workflow or parsing legacy data is the key.</p>
        </div>
      </div>
      <div class="comment comment-7628296706973898988">
        <div class="comment-header">
          <a name="comment-7628296706973898988"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-12-05 08:09</span>:
        </div>
        <div class="comment-content">
          <p>@The Cannon Family<br><br>The question is why those legacy people would move to PyPy? PyPy is bleeding edge in a way.<br><br>Besides a lot of those modules are like audioop or ossaudiodev. I don't see legitimate usecase for those, even in legacy code.</p>
        </div>
      </div>
      <div class="comment comment-3728644191428748792">
        <div class="comment-header">
          <a name="comment-3728644191428748792"></a>
            <span class="author">Richard Jones</span> wrote on <span class="date">2010-12-09 04:02</span>:
        </div>
        <div class="comment-content">
          <p>I'm very, very impressed and can't wait to use pypy in a real project. I'm blocked at the moment because I need pyglet on OS X (no MacOS module).<br><br>I gave an introduction to cython at the local Python user group and for a lark I ran the original pure-Python code up against the cython version. <br><br>cpython: 1.4s<br>cython: 0.2s<br>pypy: 0.2s<br><br>Hmm :-)</p>
        </div>
      </div>
      <div class="comment comment-4861136967481051838">
        <div class="comment-header">
          <a name="comment-4861136967481051838"></a>
            <span class="author">Xavier Combelle</span> wrote on <span class="date">2010-12-15 16:36</span>:
        </div>
        <div class="comment-content">
          <p>I don't know how it is representative but for this usecase<br>there is a factor 7 between pypy and cpython 2.7<br><br>cpython 2.7<br>&gt;&gt;&gt; timeit.Timer('sum(x for x in xrange(100000))').repeat(10,100)<br>[1.3338480523322112, 1.5916376967269201, 1.5959533140645483, 1.8427266639818676,<br> 1.3473615220676294, 1.842070271069737, 1.3346074032759319, 1.5859678554627408,<br>1.8533299541683306, 1.5872797264355398]<br><br>pypy 1.4<br>&gt;&gt;&gt;&gt; timeit.Timer('sum(x for x in xrange(100000))').repeat(10,100)<br>[7.5079355199007978, 7.9444552948765477, 7.2710836043080178, 7.5406516611307666,<br> 7.5192312421594352, 7.4927645588612677, 7.5075613773735768, 7.5201248774020826,<br> 7.7839006757141931, 7.5898334809973278]<br><br>but maybe it is not representative</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/12/we-are-not-heroes-just-very-patient-7114408885070101720.html" class="u-url">We are not heroes, just very patient</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/12/we-are-not-heroes-just-very-patient-7114408885070101720.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-12-01T10:34:00Z" itemprop="datePublished" title="2010-12-01 10:34">2010-12-01 10:34</time></a>
            </p>
                <p class="commentline">7 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Inspired by some of the comments to the release that said "You are heroes", I though a bit about the longish history of PyPy and hunted around for some of the mailing list posts that started the project. Then I put all this information together into the following timeline:</p>
<div id="content" style="height: 550px;">
   <a href="https://cfbolz.de/timeline.html">timeline</a> 
</div>
<p>There is also a <a href="https://cfbolz.de/pypy-timeline/timeline.html">larger version of the timeline</a>. Try to click on some of the events, the links usually go to the sprint descriptions. I also tried to find pictures for the sprints but succeeded for only half of them, if anybody still has some, I would be interested. It's kind of fun to browse around in some of the old sprint descriptions to see how PyPy evolved. Some of the current ideas have been around for a long time, some are new. In the description of the releases I put estimates for the speed of the release.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-468837942487796083">
        <div class="comment-header">
          <a name="comment-468837942487796083"></a>
            <span class="author">Symbol</span> wrote on <span class="date">2010-12-01 14:37</span>:
        </div>
        <div class="comment-content">
          <p>Many promising projects bite the dust not due to lack of talent, interest, need or support, but perseverance. <br><br>Not only do I believe that pypy has yet to realize it's full potential, I believe that it will actually achieve it. And then some.<br><br>So again, keep up the good work!!<br>p.s<br>(my flattr account is not yet operational ;-&lt;)</p>
        </div>
      </div>
      <div class="comment comment-885511769146963368">
        <div class="comment-header">
          <a name="comment-885511769146963368"></a>
            <span class="author">Symbol</span> wrote on <span class="date">2010-12-01 14:41</span>:
        </div>
        <div class="comment-content">
          <p>Question,<br>What do the funds(EU, eurostars) cover?<br><br>I see that there had been a burst of activity during the EU period.<br><br>Does this mean that funding is a bottleneck to this project? Would the end of the current eurostars funding be an obstacle?</p>
        </div>
      </div>
      <div class="comment comment-1425065722642835875">
        <div class="comment-header">
          <a name="comment-1425065722642835875"></a>
            <span class="author">Skandalfo</span> wrote on <span class="date">2010-12-01 19:16</span>:
        </div>
        <div class="comment-content">
          <p>Then you are just very patient heroes :-D</p>
        </div>
      </div>
      <div class="comment comment-2918386304952541647">
        <div class="comment-header">
          <a name="comment-2918386304952541647"></a>
            <span class="author">holger krekel</span> wrote on <span class="date">2010-12-01 22:16</span>:
        </div>
        <div class="comment-content">
          <p>Sure, funding does make a difference.  There are couple of people currently (Anto, Armin, Carl Friedrich, partially Maciej, me ...) who get some money through the Eurostars project.  This does make a difference in terms of how much time can be devoted. I guess there should be a clarifying blog post on this and maybe also some opinions and views on how things can continue after the funding period (which ends second half next year).</p>
        </div>
      </div>
      <div class="comment comment-1704127545737735497">
        <div class="comment-header">
          <a name="comment-1704127545737735497"></a>
            <span class="author">Nik Haldimann</span> wrote on <span class="date">2010-12-02 03:28</span>:
        </div>
        <div class="comment-content">
          <p>Amazing how far you have come. Congrats!<br><br>I found myself in 3 of those old sprint pictures, and I remember all of them as very good times that overall probably taught me more than the school I was attending during that time.</p>
        </div>
      </div>
      <div class="comment comment-1795533920028593512">
        <div class="comment-header">
          <a name="comment-1795533920028593512"></a>
            <span class="author">glyph</span> wrote on <span class="date">2010-12-02 07:21</span>:
        </div>
        <div class="comment-content">
          <p>This timeline sort of makes the point.  You <i>are</i> heroes ;).  Patience is harder than a few nights of crazy hacking and brilliant ideas.</p>
        </div>
      </div>
      <div class="comment comment-6890136284347858203">
        <div class="comment-header">
          <a name="comment-6890136284347858203"></a>
            <span class="author">Martijn Faassen</span> wrote on <span class="date">2010-12-10 12:21</span>:
        </div>
        <div class="comment-content">
          <p>Yeah, you have more heroic patience than I tended to display <br>cheerleading/criticizing the project. <br><br>Currently there's nothing left to criticize for me -- I think everything's being done pretty much right (communication, releases, even work on C-module support!).<br><br>But that might change once I start to use the project seriously. :)</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/11/pypy-14-ouroboros-in-practice-5437628000869417542.html" class="u-url">PyPy 1.4: Ouroboros in practice</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/11/pypy-14-ouroboros-in-practice-5437628000869417542.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-11-26T18:18:00Z" itemprop="datePublished" title="2010-11-26 18:18">2010-11-26 18:18</time></a>
            </p>
                <p class="commentline">28 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>We're pleased to announce the 1.4 release of PyPy. This is a major breakthrough
in our long journey, as PyPy 1.4 is the first PyPy release that can translate
itself faster than CPython.  Starting today, we are using PyPy more for
our every-day development.  So may you :) You can download it here:</p>
<p><a class="reference external" href="https://pypy.org/download.html">https://pypy.org/download.html</a></p>
<div class="section" id="what-is-pypy">
<h2>What is PyPy</h2>
<p>PyPy is a very compliant Python interpreter, almost a drop-in replacement
for CPython. It is fast (<a class="reference external" href="https://speed.pypy.org/comparison/?exe=2%2B35,1%2B172&amp;ben=1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20&amp;env=1&amp;hor=false&amp;bas=2%2B35&amp;chart=normal+bars">pypy 1.4 and cpython 2.6</a> comparison).</p>
<h2>New Features</h2>
<p>Among its new features, this release includes numerous performance improvements
(which made fast self-hosting possible), a 64-bit JIT backend, as well
as serious stabilization. As of now, we can consider the 32-bit and 64-bit
linux versions of PyPy stable enough to run <a class="reference external" href="../posts/2010/11/running-large-radio-telescope-software-7600337209616168504.html">in production</a>.</p>
<p>Numerous speed achievements are described on <a class="reference external" href="https://morepypy.blogspot.com">our blog</a>. Normalized speed
charts comparing <a class="reference external" href="https://speed.pypy.org/comparison/?exe=1%2B41,1%2B172&amp;ben=1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20&amp;env=1&amp;hor=false&amp;bas=1%2B41&amp;chart=normal+bars">pypy 1.4 and pypy 1.3</a> as well as <a class="reference external" href="https://speed.pypy.org/comparison/?exe=2%2B35,1%2B172&amp;ben=1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20&amp;env=1&amp;hor=false&amp;bas=2%2B35&amp;chart=normal+bars">pypy 1.4 and cpython 2.6</a>
are available on the benchmark website. For the impatient: yes, we got a lot faster!</p>
</div>
<div class="section" id="more-highlights">
<h2>More highlights</h2>
<ul class="simple">
<li>PyPy's built-in Just-in-Time compiler is fully transparent and
automatically generated; it now also has very reasonable memory
requirements.  The total memory used by a very complex and
long-running process (translating PyPy itself) is within 1.5x to
at most 2x the memory needed by CPython, for a speed-up of 2x.</li>
<li>More compact instances.  All instances are as compact as if
they had <tt class="docutils literal">__slots__</tt>.  This can give programs a big gain in
memory.  (In the example of translation above, we already have
carefully placed <tt class="docutils literal">__slots__</tt>, so there is no extra win.)</li>
<li>
<a class="reference external" href="../posts/2010/08/using-virtualenv-with-pypy-7238942727709530503.html">Virtualenv support</a>: now PyPy is fully compatible with <a class="reference external" href="https://pypi.python.org/pypi/virtualenv">virtualenv</a>: note that
to use it, you need a recent version of virtualenv (&gt;= 1.5).</li>
<li>Faster (and JITted) regular expressions - huge boost in speeding up
the <cite>re</cite> module.</li>
<li>Other speed improvements, like JITted calls to functions like map().</li>
</ul>
<p>Cheers,<br>
Carl Friedrich Bolz, Antonio Cuni, Maciej Fijalkowski,
Amaury Forgeot d'Arc, Armin Rigo and the PyPy team</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-5698466964793523657">
        <div class="comment-header">
          <a name="comment-5698466964793523657"></a>
            <span class="author">ipc</span> wrote on <span class="date">2010-11-26 18:42</span>:
        </div>
        <div class="comment-content">
          <p>congratulations!</p>
        </div>
      </div>
      <div class="comment comment-5791392568430504954">
        <div class="comment-header">
          <a name="comment-5791392568430504954"></a>
            <span class="author">why</span> wrote on <span class="date">2010-11-26 18:47</span>:
        </div>
        <div class="comment-content">
          <p>This is unacceptable. Christmas is not until next month!!!</p>
        </div>
      </div>
      <div class="comment comment-722476048703864347">
        <div class="comment-header">
          <a name="comment-722476048703864347"></a>
            <span class="author">Tim Parkin</span> wrote on <span class="date">2010-11-26 19:09</span>:
        </div>
        <div class="comment-content">
          <p>Massive congratulations - exciting!</p>
        </div>
      </div>
      <div class="comment comment-3705068970749865896">
        <div class="comment-header">
          <a name="comment-3705068970749865896"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2010-11-26 19:18</span>:
        </div>
        <div class="comment-content">
          <p>Sweet! Keep up the great work !</p>
        </div>
      </div>
      <div class="comment comment-4203257578008139771">
        <div class="comment-header">
          <a name="comment-4203257578008139771"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-26 19:41</span>:
        </div>
        <div class="comment-content">
          <p>Woohoo!!</p>
        </div>
      </div>
      <div class="comment comment-1408048261428934149">
        <div class="comment-header">
          <a name="comment-1408048261428934149"></a>
            <span class="author">Martijn Faassen</span> wrote on <span class="date">2010-11-26 20:07</span>:
        </div>
        <div class="comment-content">
          <p>Awesome!</p>
        </div>
      </div>
      <div class="comment comment-3870809624353869471">
        <div class="comment-header">
          <a name="comment-3870809624353869471"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-26 20:59</span>:
        </div>
        <div class="comment-content">
          <p>Hip hip hooooraaaay!!!!</p>
        </div>
      </div>
      <div class="comment comment-951090356443865918">
        <div class="comment-header">
          <a name="comment-951090356443865918"></a>
            <span class="author">ipc</span> wrote on <span class="date">2010-11-26 22:51</span>:
        </div>
        <div class="comment-content">
          <p>all I want for Christmas is stackless support in a 64-bit pypy-c-jit :) 'two greenlets switching and a partridge in a pear tree!'</p>
        </div>
      </div>
      <div class="comment comment-4733237727036697301">
        <div class="comment-header">
          <a name="comment-4733237727036697301"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2010-11-26 23:14</span>:
        </div>
        <div class="comment-content">
          <p>Congratulations. I hope the PPA is going to be updated soon. Too lazy to build it myself, right now. (:</p>
        </div>
      </div>
      <div class="comment comment-4192494673907111895">
        <div class="comment-header">
          <a name="comment-4192494673907111895"></a>
            <span class="author">Paul Boddie</span> wrote on <span class="date">2010-11-26 23:29</span>:
        </div>
        <div class="comment-content">
          <p>Is there a -j &lt;number-of-cores&gt; option for the translation process? It's a bit unfortunate that 15 cores on the nice machine I'm using can't be put to use making it translate faster. (Or unfortunate that I didn't read the documentation, maybe.)</p>
        </div>
      </div>
      <div class="comment comment-7554705722283024875">
        <div class="comment-header">
          <a name="comment-7554705722283024875"></a>
            <span class="author">ipc</span> wrote on <span class="date">2010-11-26 23:54</span>:
        </div>
        <div class="comment-content">
          <p>--make-jobs=N only some parts of the translation process is parallel.</p>
        </div>
      </div>
      <div class="comment comment-1636083846112497188">
        <div class="comment-header">
          <a name="comment-1636083846112497188"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-27 00:10</span>:
        </div>
        <div class="comment-content">
          <p>Eta until numpy scipy?</p>
        </div>
      </div>
      <div class="comment comment-92656516061829693">
        <div class="comment-header">
          <a name="comment-92656516061829693"></a>
            <span class="author">Paul Boddie</span> wrote on <span class="date">2010-11-27 01:00</span>:
        </div>
        <div class="comment-content">
          <p>The report of 2.4GB usage on x86-64 is accurate, but it took about 7800s on a 2.33GHz Xeon. Next time I'll try and exercise some of the other cores, though.</p>
        </div>
      </div>
      <div class="comment comment-7445643193147870364">
        <div class="comment-header">
          <a name="comment-7445643193147870364"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-27 04:54</span>:
        </div>
        <div class="comment-content">
          <p>so pypy on average is now about 2x faster than cpython?<br><br>and unladen swallows goal was being 5x faster? was that totally unrealistic?</p>

        </div>
      </div>
      <div class="comment comment-1290209146996411185">
        <div class="comment-header">
          <a name="comment-1290209146996411185"></a>
            <span class="author">Leonard Ritter</span> wrote on <span class="date">2010-11-27 10:59</span>:
        </div>
        <div class="comment-content">
          <p>You are my heroes!</p>
        </div>
      </div>
      <div class="comment comment-6925973227211165478">
        <div class="comment-header">
          <a name="comment-6925973227211165478"></a>
            <span class="author">Symbol</span> wrote on <span class="date">2010-11-27 11:37</span>:
        </div>
        <div class="comment-content">
          <p>Just Awesome!!!<br><br>KUTGW!</p>
        </div>
      </div>
      <div class="comment comment-4839942260189704462">
        <div class="comment-header">
          <a name="comment-4839942260189704462"></a>
            <span class="author">Daivd</span> wrote on <span class="date">2010-11-27 12:02</span>:
        </div>
        <div class="comment-content">
          <p>Does this release include the -free branch that was mentioned in the previous post? The 2x memory requirements lead me to believe so.</p>
        </div>
      </div>
      <div class="comment comment-8879169283039384811">
        <div class="comment-header">
          <a name="comment-8879169283039384811"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-27 13:45</span>:
        </div>
        <div class="comment-content">
          <p>@Daivd<br>yes, it does<br><br>@Anonymous<br>5x improvement is not a well defined goal, however it's a good marketing thing. PyPy is 2x faster on translation, 60x faster on some benchmarks while slower on other. What does it mean to be 5x faster?</p>
        </div>
      </div>
      <div class="comment comment-822013367645640566">
        <div class="comment-header">
          <a name="comment-822013367645640566"></a>
            <span class="author">Christian S. Perone</span> wrote on <span class="date">2010-11-27 14:23</span>:
        </div>
        <div class="comment-content">
          <p>Sounds great, great work, great thanks !</p>
        </div>
      </div>
      <div class="comment comment-1744594714317463681">
        <div class="comment-header">
          <a name="comment-1744594714317463681"></a>
            <span class="author">scientist</span> wrote on <span class="date">2010-11-27 14:34</span>:
        </div>
        <div class="comment-content">
          <p>Do you know why the purely numerical benchmarks nbody and spectral-norm are still so much slower in PyPy compared to e.g. LuaJIT?</p>
        </div>
      </div>
      <div class="comment comment-3730884410847514072">
        <div class="comment-header">
          <a name="comment-3730884410847514072"></a>
            <span class="author">tobami</span> wrote on <span class="date">2010-11-27 14:44</span>:
        </div>
        <div class="comment-content">
          <p>This is awesome. PyPy 1.4 addresses the 2 slowest benchmarks, slowspitfire and spambayes. There is no benchmark anymore where PyPy is much slower than CPython.<br><br>To me, this marks the first time you can say that PyPy is ready for general "consumption". Congratulations!<br><br>PS: The best comparison to appreciate how much of an improvement 1.4 has been is:<br>https://speed.pypy.org/comparison/?exe=2%2B35,1%2B41,1%2B172&amp;ben=1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20&amp;env=1&amp;hor=false&amp;bas=2%2B35&amp;chart=normal+bars</p>
        </div>
      </div>
      <div class="comment comment-7147388927731491992">
        <div class="comment-header">
          <a name="comment-7147388927731491992"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-27 17:37</span>:
        </div>
        <div class="comment-content">
          <p>@scientist<br><br>Sure, because LuaJIT is crazy when it comes to optimizations :-) We'll get there eventually, but purely numerical stuff is not as high on our list as other things.</p>
        </div>
      </div>
      <div class="comment comment-8688771517665790721">
        <div class="comment-header">
          <a name="comment-8688771517665790721"></a>
            <span class="author">Luis</span> wrote on <span class="date">2010-11-27 18:37</span>:
        </div>
        <div class="comment-content">
          <p>@maciej: in an old thread (have tracing compilers won?) you replied to Mike Pall saying that pypy was in a way middle ground, that it didn't offer as much opportunities for micro optimizations as luajit.<br><br>You were discussing about keeping high level constructions from the user program to perform more tricks.<br><br>Has the situation changed?<br>Do you really think now that you'll get there?<br><br>Anyway, let me tell you that you are all already my super heroes :-)</p>
        </div>
      </div>
      <div class="comment comment-9096092562087906640">
        <div class="comment-header">
          <a name="comment-9096092562087906640"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-27 18:46</span>:
        </div>
        <div class="comment-content">
          <p>Heh, I don't remember that :-)<br><br>Anyway, LuaJIT has more options for microoptimziations simply because Lua is a simpler language. That doesn't actually make it impossible for PyPy, it simply make it harder and taking more time (but it's still possible). I still think we can get (but predicting future is hard) where LuaJIT is right now, but racing Mike would be a challenge that we might loose ;-)<br><br>That said, even in simple loops there are obvious optimizations to be performed, so we're far from being done. We're going there, but it's taking time ;-)</p>
        </div>
      </div>
      <div class="comment comment-6833632710066042850">
        <div class="comment-header">
          <a name="comment-6833632710066042850"></a>
            <span class="author">Victor</span> wrote on <span class="date">2010-11-27 19:33</span>:
        </div>
        <div class="comment-content">
          <p>Congrats to all PyPy developers for making huge contributions to Python performance, JIT and implementation research and delivering an end product that will help many developers to get more done.<br><br>IIUC, we still have ARM, jit-unroll-loops, more memory improvements, Python 2.7 (Fast Forward branch) and a bunch of other cool improvements in the works, besides some known interesting targets that will eventually be tackled (e.g. JITted stackless).<br><br>I wish more big Python apps and developers would play with PyPy and report the results.<br><br>Cheers!<br><br>P.S.: Fijal: see <a href="https://lambda-the-ultimate.org/node/3851#comment-57715" rel="nofollow">https://lambda-the-ultimate.org/node/3851#comment-57715</a></p>
        </div>
      </div>
      <div class="comment comment-700906583292544301">
        <div class="comment-header">
          <a name="comment-700906583292544301"></a>
            <span class="author">Michal M.</span> wrote on <span class="date">2010-11-29 18:55</span>:
        </div>
        <div class="comment-content">
          <p>Congratulations.<br>However, you suggest people used it in production environment - please, give us version compatible at least with CPython 2.6.<br>I hope that you plan it but at first you wanted to have stable and fast base. :)</p>
        </div>
      </div>
      <div class="comment comment-8230685673269995077">
        <div class="comment-header">
          <a name="comment-8230685673269995077"></a>
            <span class="author">Amaury Forgeot d'Arc</span> wrote on <span class="date">2010-12-01 22:21</span>:
        </div>
        <div class="comment-content">
          <p>@Michal:<br>There is already an ongoing effort to port PyPy to Python 2.7.<br><br>But we need some help! It's a good way to become a PyPy developer.<br>And no, you don't have to be a JIT expert to implement itertools.combinations or asian codecs.</p>
        </div>
      </div>
      <div class="comment comment-8019723345377233612">
        <div class="comment-header">
          <a name="comment-8019723345377233612"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-09 00:18</span>:
        </div>
        <div class="comment-content">
          <p>kudos to whip-smart guys for this wonderful piece of software.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/11/improving-memory-behaviour-to-make-self-856966667913962461.html" class="u-url">Improving Memory Behaviour to Make Self-Hosted PyPy Translations Practical</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/antonio-cuni.html">Antonio Cuni</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/11/improving-memory-behaviour-to-make-self-856966667913962461.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-11-26T12:51:00Z" itemprop="datePublished" title="2010-11-26 12:51">2010-11-26 12:51</time></a>
            </p>
                <p class="commentline">10 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>In our <a class="reference external" href="../posts/2010/11/snake-which-bites-its-tail-pypy-jitting-5161284681004717142.html">previous blog post</a>, we talked about how fast PyPy can translate
itself compared to CPython.  However, the price to pay for the 2x speedup was
an huge amount of memory: actually, it was so huge that a standard <tt class="docutils literal"><span class="pre">-Ojit</span></tt>
compilation could not be completed on 32-bit because it required more than the
4 GB of RAM that are addressable on that platform.  On 64-bit, it consumed
8.3 GB of RAM instead of the 2.3 GB needed by CPython.</p>
<p>This behavior was mainly caused by the JIT, because at the time we wrote the
blog post the generated assembler was kept alive forever, together with some
big data structure needed to execute it.</p>
<p>In the past two weeks Anto and Armin attacked the issue in the <tt class="docutils literal"><span class="pre">jit-free</span></tt>
branch, which has been recently <a class="reference external" href="https://codespeak.net/pipermail/pypy-svn/2010-November/045019.html">merged</a> to trunk.  The branch solves several
issues. The main idea of the branch is that if a
loop has not been executed for a certain amount of time (controlled by the new
<tt class="docutils literal">loop_longevity</tt> JIT parameter) we consider it "old" and no longer needed,
thus we deallocate it.</p>
<p>(In the process of doing this, we also discovered and fixed an
oversight in the implementation of generators, which led to generators being
freed only very slowly.)</p>
<p>To understand the freeing of loops some more, let's look at how many loops are
actually created during a translation.
The purple line in the following graph shows how many loops (and bridges) are
alive at any point in time with an infinite longevity, which is equivalent to
the situation we had before the <tt class="docutils literal"><span class="pre">jit-free</span></tt> branch.  By contrast, the blue
line shows the number of loops that you get in the current trunk: the
difference is evident, as now we never have more than 10000 loops alive, while
previously we got up to about 37000 ones.  The time on the X axis is expressed
in "Giga Ticks", where a tick is the value read out of the <a class="reference external" href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a>
of the CPU.</p>

<a href="https://3.bp.blogspot.com/_4gR6Ggu8oHQ/TO-wIZWQVmI/AAAAAAAAAKs/J4PKLIFxxOc/s1600/loop-longevity-64-gcdelta.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5543843324606043746" src="https://3.bp.blogspot.com/_4gR6Ggu8oHQ/TO-wIZWQVmI/AAAAAAAAAKs/J4PKLIFxxOc/s600/loop-longevity-64-gcdelta.png" style="cursor: pointer; cursor: hand; width: 600px; height: 306px;"></a>

<p>The grey vertical bars represent the beginning of each phase of the
translation:</p>
<ul class="simple">
<li>
<tt class="docutils literal">annotate</tt> performs control flow graph construction and type inference.</li>
<li>
<tt class="docutils literal">rtype</tt> lowers the abstraction level of the control flow graphs with types to that of C.</li>
<li>
<tt class="docutils literal">pyjitpl</tt> constructs the JIT.</li>
<li>
<tt class="docutils literal">backendopt</tt> optimizes the control flow graphs.</li>
<li>
<tt class="docutils literal">stackcheckinsertion</tt> finds the places in the call graph that can overflow the C stack and inserts checks that raise an exception instead.</li>
<li>
<tt class="docutils literal">database_c</tt> produces a database of all the objects the C code will have to know about.</li>
<li>
<tt class="docutils literal">source_c</tt> produces the C source code.</li>
<li>
<tt class="docutils literal">compile_c</tt> calls the compiler to produce the executable.</li>
</ul>
<p>You can nicely see, how the number of alive graphs drops shortly after the
beginning of a new phase.</p>
<p>Those two fixes, freeing loops and generators, improve the memory usage greatly:
now, translating PyPy
on PyPy on 32-bit consumes 2 GB of RAM, while on CPython it consumes 1.1 GB.
This result can even be improved somewhat, because we are not actually freeing
the assembler code itself, but
only the large data structures around it; we can consider it as a residual
memory leak of around 150 MB in this case.  This will be fixed in the
<a class="reference external" href="https://codespeak.net/svn/pypy/branch/jit-free-asm/">jit-free-asm</a> branch.</p>
<p>The following graph shows the memory usage in more detail:</p>
<blockquote>
<ul class="simple">
<li>the blue line (<strong>cpython-scaled</strong>) shows the total amount of RAM that the
OS allocates for CPython.  Note that the X axis (the time) has been
scaled down so that it spans as much as the PyPy one, to ease the
comparison. Actually, CPython took more than twice as much time as PyPy to
complete the translation</li>
<li>the red line (<strong>VmRss</strong>) shows the total amount of RAM that the
OS allocates for PyPy: it includes both the memory directly handled by
our GC and the "raw memory" that we need to allocate for other tasks, such
as the assembly code generated by the JIT</li>
<li>the brown line (<strong>gc-before</strong>) shows how much memory is used by the GC
before each major collection</li>
<li>the yellow line (<strong>gc-after</strong>) shows how much memory is used by the GC
after each major collection: this represent the amount of memory which is
actually needed to hold our Python objects.  The difference between
gc-before and gc-after (the <em>GC delta</em>) is the amout of memory that the GC
uses before triggering a new major collection</li>
</ul>
</blockquote>

<a href="https://1.bp.blogspot.com/_4gR6Ggu8oHQ/TO-wX3gomAI/AAAAAAAAAK0/sQhn6oMjWdY/s1600/memory-32.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5543843590400677890" src="https://1.bp.blogspot.com/_4gR6Ggu8oHQ/TO-wX3gomAI/AAAAAAAAAK0/sQhn6oMjWdY/s600/memory-32.png" style="cursor: pointer; cursor: hand; width: 600px; height: 306px;"></a>

<p>By comparing <strong>gc-after</strong> and <strong>cpython-scaled</strong>, we can see that PyPy
uses mostly the same amount of memory as CPython for storing the application
objects (due to reference counting the memory usage in CPython is always very
close to the actually necessary memory).  The extra memory
used by PyPy is due to the GC delta, to the machine code generated by the JIT
and probably to some other external effect (such as e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/Memory_fragmentation">Memory
Fragmentation</a>).</p>
<p>Note that the GC delta can be set arbitrarly low (another recent addition --
the default value depends on the actual RAM on your computer; it probably
works to translate if your computer has precisely 2 GB, because in this
case the GC delta and thus the total memory usage will be somewhat
lower than reported here), but the cost is to have more
frequent major collections and thus a higher run-time overhead.  The same is
true for the memory needed by the JIT, which can be reduced by telling the JIT
to compile less often or to discard old loops more frequently.  As often
happens in computer science, there is a trade-off between space and time, and
currently for this particular example PyPy runs twice as fast as CPython by
doubling the memory usage. We hope to improve even more on this trade-off.</p>
<p>On 64-bit, things are even better as shown by the the following graph:</p>

<a href="https://1.bp.blogspot.com/_4gR6Ggu8oHQ/TO-whfBmjLI/AAAAAAAAAK8/eUOmx59dA80/s1600/memory-64-gcdelta.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5543843755626761394" src="https://1.bp.blogspot.com/_4gR6Ggu8oHQ/TO-whfBmjLI/AAAAAAAAAK8/eUOmx59dA80/s600/memory-64-gcdelta.png" style="cursor: pointer; cursor: hand; width: 600px; height: 306px;"></a>

<p>The general shape of the lines is similar to the 32-bit graph. However, the
relative difference to CPython is much better: we need about 3 GB of RAM, just
24% more than the 2.4 GB needed by CPython.  And we are still more than 2x
faster!</p>
<p>The memory saving is due (partly?) to the vtable ptr optimization, which is
enabled by default on 64-bit because it has no speed penalty (see
<a class="reference external" href="../posts/2009/10/gc-improvements-6174120095428192954.html">Unifying the vtable ptr with the GC header</a>).</p>
<p>The net result of our work is that now translating PyPy on PyPy is practical
and takes less than 30 minutes.  It's impressive how quickly you get used to
translation taking half the time -- now we cannot use CPython any more for that
because it feels too slow :-).</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-4950732767191711545">
        <div class="comment-header">
          <a name="comment-4950732767191711545"></a>
            <span class="author">crncosta</span> wrote on <span class="date">2010-11-26 16:29</span>:
        </div>
        <div class="comment-content">
          <p>Big huge improvement since last post. Kudos!! :-)<br><br>Please don't get me wrong, but I need to ask: is there any plan to merge pypy into cPython (or even replace it)?<br><br>BTW, I'm following the blog (please, keep this regular posts) and planing to make a donation to support your next sprint due to the regular and very well done work.<br><br>congratulations again.</p>
        </div>
      </div>
      <div class="comment comment-3139180760487800094">
        <div class="comment-header">
          <a name="comment-3139180760487800094"></a>
            <span class="author">Martijn Faassen</span> wrote on <span class="date">2010-11-26 17:09</span>:
        </div>
        <div class="comment-content">
          <p>This is incredibly cool! Congrats!</p>
        </div>
      </div>
      <div class="comment comment-7025512732564064311">
        <div class="comment-header">
          <a name="comment-7025512732564064311"></a>
            <span class="author">Leonardo Santagada</span> wrote on <span class="date">2010-11-26 17:38</span>:
        </div>
        <div class="comment-content">
          <p>This is amazing. It was kind of a let down when you reported it used too much memory. But now I can on my laptop translate pypy in 32 and 64 bits using pypy itself :)<br><br>The world is good again :)</p>
        </div>
      </div>
      <div class="comment comment-8272560978038036502">
        <div class="comment-header">
          <a name="comment-8272560978038036502"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-26 17:48</span>:
        </div>
        <div class="comment-content">
          <p>@crncosta<br><br>There are no plans for merging PyPy to CPython. I don't think "replacing" is a good word, but you can use PyPy for a lot of things already, so it is a viable Python implementation together with CPython.</p>
        </div>
      </div>
      <div class="comment comment-1957260981826150935">
        <div class="comment-header">
          <a name="comment-1957260981826150935"></a>
            <span class="author">Luis</span> wrote on <span class="date">2010-11-26 18:20</span>:
        </div>
        <div class="comment-content">
          <p>I am curious... Has there ever been interest from Google to sponsor this project?<br>I know about unladen swallow, but has anyone there expressed interest in using pypy somewhere in their organization?<br><br>Sorry for the off topic question...</p>
        </div>
      </div>
      <div class="comment comment-5391894609060204294">
        <div class="comment-header">
          <a name="comment-5391894609060204294"></a>
            <span class="author">Peter</span> wrote on <span class="date">2010-11-26 18:28</span>:
        </div>
        <div class="comment-content">
          <p>Always fascinating to read about the work you're doing.  Please keep posting, and keep up the good work.  You really are heroes.</p>
        </div>
      </div>
      <div class="comment comment-6012478128672522590">
        <div class="comment-header">
          <a name="comment-6012478128672522590"></a>
            <span class="author">WI</span> wrote on <span class="date">2010-11-27 01:09</span>:
        </div>
        <div class="comment-content">
          <p>Wow! this is great news.. keep us posted on what other developments you have.</p>
        </div>
      </div>
      <div class="comment comment-6113702063840466327">
        <div class="comment-header">
          <a name="comment-6113702063840466327"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-27 05:02</span>:
        </div>
        <div class="comment-content">
          <p>like luis i am also curious about why google doesn't show a lot more interest in pypy. unladen swallow didn't really work out or did it?</p>
        </div>
      </div>
      <div class="comment comment-4495003157966448533">
        <div class="comment-header">
          <a name="comment-4495003157966448533"></a>
            <span class="author">Symbol</span> wrote on <span class="date">2010-11-27 11:37</span>:
        </div>
        <div class="comment-content">
          <p>Kudos!<br><br>KUTGW!!</p>
        </div>
      </div>
      <div class="comment comment-7289962563710841452">
        <div class="comment-header">
          <a name="comment-7289962563710841452"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-28 08:33</span>:
        </div>
        <div class="comment-content">
          <p>Congrats!</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/11/running-large-radio-telescope-software-7600337209616168504.html" class="u-url">Running large radio telescope software on top of PyPy and twisted</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/11/running-large-radio-telescope-software-7600337209616168504.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-11-15T18:43:00Z" itemprop="datePublished" title="2010-11-15 18:43">2010-11-15 18:43</time></a>
            </p>
                <p class="commentline">11 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Hello.</p>
<p>As some of you already know, I've recently started working on a
<a class="reference external" href="https://en.wikipedia.org/wiki/MeerKAT">very large radio telescope</a> at <a class="reference external" href="https://ska.ac.za">SKA South Africa</a>. This telescope's
operating software runs almost exclusively on Python (several high throughput
pieces are in C or CUDA or directly executed by FPGAs). Some cool telescope pictures:</p>

<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/_5R1EBmwBBTs/TOF9pTRAv2I/AAAAAAAAAuA/AGh-7hr68OU/s1600/telescope1.jpg" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/_5R1EBmwBBTs/TOF9pTRAv2I/AAAAAAAAAuA/AGh-7hr68OU/s1600/telescope1.jpg"></a>
</div>
<br><div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/_5R1EBmwBBTs/TOF9rFhQmwI/AAAAAAAAAuE/LFXySmzV0t0/s1600/telescope2.jpg" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://2.bp.blogspot.com/_5R1EBmwBBTs/TOF9rFhQmwI/AAAAAAAAAuE/LFXySmzV0t0/s1600/telescope2.jpg"></a>
</div>

<p>(photos courtesy of SKA South Africa)</p>
<p>Most of the operation software is using the <a class="reference external" href="https://bitbucket.org/hodgestar/katcp">KatCP</a> protocol to talk between devices.
The currently used implementation is Open Source software with a custom home built
server and client. As part of the experiments, I've implemented a <a class="reference external" href="https://twistedmatrix.com">Twisted</a> based
version and run in on top of CPython and PyPy for both the default
implementation and the one based on Twisted to see how those perform.</p>
<p>There are two testing scenarios: the first one is trying to saturate the connection
by setting up multiple sensors that report state every 10ms, the second one
is measuring a round-trip between sending a request and receiving the response.
Both numbers are measuring the number of requests per 0.2s, so the more the better. On X axis there is a number of simultanously connected clients.</p>
<p>All benchmark code is available in the KatCP repository.</p>
<p>The results are as follows:</p>

<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/_5R1EBmwBBTs/TOF-YS6DbqI/AAAAAAAAAuI/E8Ub4I4uFBQ/s1600/1.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="480" src="https://3.bp.blogspot.com/_5R1EBmwBBTs/TOF-YS6DbqI/AAAAAAAAAuI/E8Ub4I4uFBQ/s640/1.png" width="640"></a>
</div>
<br><div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/_5R1EBmwBBTs/TOF-ZCvEOAI/AAAAAAAAAuM/Mdfz9Mho1o4/s1600/2.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="480" src="https://2.bp.blogspot.com/_5R1EBmwBBTs/TOF-ZCvEOAI/AAAAAAAAAuM/Mdfz9Mho1o4/s640/2.png" width="640"></a>
</div>
<p>As you can see, in general Twisted has larger overhead for a single client
and scales better as the number of clients increases. That's I think expected,
since Twisted has extra layers of indirection. The round trip degradation of
Twisted has to be investigated, but for us scenario1 is by far more important.</p>
<p>All across the board PyPy performs much better than CPython for both
Twisted and a home-made solution, which I think is a pretty good result.</p>
<p>Note: we didn't roll this set up into production yet, but there are high
chances for both twisted and PyPy to be used in some near future.</p>
<p>Cheers,
fijal</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-3181408838865406721">
        <div class="comment-header">
          <a name="comment-3181408838865406721"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-16 01:56</span>:
        </div>
        <div class="comment-content">
          <p>Why not try PyZmq (https://www.zeromq.org/bindings:python):)? the IPython project(https://ipython.scipy.org/moin/) is also moving from Twisted <br>to PyZmq.</p>
        </div>
      </div>
      <div class="comment comment-8035374275227730326">
        <div class="comment-header">
          <a name="comment-8035374275227730326"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-16 06:23</span>:
        </div>
        <div class="comment-content">
          <p>Sorry this is not an apropriate forum to discuss this. One of the reasons would be that Twisted and PyZmq are doing two completely different things and PyZmq won't work on PyPy.</p>
        </div>
      </div>
      <div class="comment comment-3389611818471464106">
        <div class="comment-header">
          <a name="comment-3389611818471464106"></a>
            <span class="author">Michal M.</span> wrote on <span class="date">2010-11-16 07:59</span>:
        </div>
        <div class="comment-content">
          <p>Oh, I envy you. And congratulations.<br>Keep working.<br>I wait for 2.6 compatible ver. of PyPy to try it with my little project.<br><br>A widzÄ…c, Å¼e prawdopodobnie rodak, to tym bardziej siÄ™ cieszÄ™.</p>
        </div>
      </div>
      <div class="comment comment-7795603788437441319">
        <div class="comment-header">
          <a name="comment-7795603788437441319"></a>
            <span class="author">glyph</span> wrote on <span class="date">2010-11-16 09:13</span>:
        </div>
        <div class="comment-content">
          <p>Maciej, this is great news.  Congratulations.<br><br>I look forward to making PyPy+Twisted even faster from the Twisted side :).</p>
        </div>
      </div>
      <div class="comment comment-6865257513702858440">
        <div class="comment-header">
          <a name="comment-6865257513702858440"></a>
            <span class="author">Alessio Sclocco</span> wrote on <span class="date">2010-11-17 14:00</span>:
        </div>
        <div class="comment-content">
          <p>Hi Maciej,<br><br>You say that there you are mostly using Python and sometimes C, CUDA or FPGAs.<br>I am writing my master thesis in the Netherlands, it is about the efficient implementation of a beam forming algorithm (the one used by the LOFAR) on modern GPUs using CUDA and OpenCL. Do you have some papers or other material there about the telescope software ? I would be really interested on citing it on the related works part.</p>
        </div>
      </div>
      <div class="comment comment-4344316384999289811">
        <div class="comment-header">
          <a name="comment-4344316384999289811"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-17 16:26</span>:
        </div>
        <div class="comment-content">
          <p>Hey Alessio. I think this blog is not really a good medium for 2-way communication feel free to come to #pypy on irc.freenode.net or write to me directly at fijall at gmail.<br><br>In general, we don't want beam forming to be performed on GPU (because it's hard), but rather on custom-built hardware and FPGAs.</p>
        </div>
      </div>
      <div class="comment comment-5454709995154631628">
        <div class="comment-header">
          <a name="comment-5454709995154631628"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-21 10:40</span>:
        </div>
        <div class="comment-content">
          <p>I have a program using Python and Twisted where I load tested both server and client connections (the program can do both the server and client protocol). I tested both types out to 100 connections (at 50 milli-second polling intervals) while measuring CPU load. <br><br>What I found was that when acting as a server it scaled fairly linearly. When acting as the client side however, load rose to a peak about 60 clients, then fell by a third until 80 clients, and then rose again until at 100 clients it reached the same load level as at 60. If you have a similar situation you may need to watch out for this phenomenon. <br><br>I also found that using the epoll reactor on Linux made a *big* difference to capacity in my applications, much more so than any normal program optimization efforts that I made. I have multiple clients and multiple server ports all running simultaneously, so I'm not sure how this may translate to your application if you are only using Twisted as a server. <br><br>Here's a link to my project web site where I show the connections versus CPU load chart (first chart):<br><br>https://mblogic.sourceforge.net/mblogichelp/general/Capacity-en.html<br><br>I haven't tested this with PyPy as I don't have a combination of anything that is both 32-bit *and* new enough to run a recent version.</p>
        </div>
      </div>
      <div class="comment comment-1793771126834445104">
        <div class="comment-header">
          <a name="comment-1793771126834445104"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-21 12:16</span>:
        </div>
        <div class="comment-content">
          <p>PyPy has 64bit support these days.</p>
        </div>
      </div>
      <div class="comment comment-6847121771885284579">
        <div class="comment-header">
          <a name="comment-6847121771885284579"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-22 20:28</span>:
        </div>
        <div class="comment-content">
          <p>I also made the previous anonymous post on the 21st. I haven't been able to get the 64 bit JIT version to run or build. That may be my fault, but I haven't been able to test it (this isn't a problem that I want to waste your time on however). <br><br>I have tested the non-JIT Pypy using a simplified version of my server and client programs, using asyncore instead of Twisted. The server and client use a standard industrial automation protocol to talk to each other over a TCP socket. The programs also make heavy use of list slicing and struct. <br><br>The non-JIT version passes all the tests I have for the server, and runs my application performance test at roughly 1/3 the speed of CPython 2.6. This is very impressive, as I have never been able to get either IronPython (on Mono) nor Jython to even run the programs, let alone pass my functional tests. The fact that Pypy (non-JIT) can run these programs perfectly without changes is something that I find very promising. <br><br>Please continue the good work, and thank you for what you've done so far!</p>
        </div>
      </div>
      <div class="comment comment-3950439295016682746">
        <div class="comment-header">
          <a name="comment-3950439295016682746"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-23 08:13</span>:
        </div>
        <div class="comment-content">
          <p>Hey, great to hear!<br><br>Well, the non-JIT version would rather be slow, but that's fine :) We try very hard to produce a compliant python interpreter and twisted folk helped us greatly with getting all the posix stuff right.<br><br>Cheers,<br>fijal</p>
        </div>
      </div>
      <div class="comment comment-8680146944859733629">
        <div class="comment-header">
          <a name="comment-8680146944859733629"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2010-11-26 23:53</span>:
        </div>
        <div class="comment-content">
          <p>I would be very interested if someone could provide some info on how to get twisted working on pyp. I have managed to install twisted in the pypy setup but starting it produces: <br>AttributeError: 'module' object has no attribute 'load_dynamic'<br>coming from zope</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/11/efficiently-implementing-python-objects-3838329944323946932.html" class="u-url">Efficiently Implementing Python Objects With Maps</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/11/efficiently-implementing-python-objects-3838329944323946932.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-11-13T16:40:00Z" itemprop="datePublished" title="2010-11-13 16:40">2010-11-13 16:40</time></a>
            </p>
                <p class="commentline">15 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>As could be foreseen by my <a class="reference external" href="../posts/2010/08/call-for-benchmarks-2605012131351543912.html">Call for Memory Benchmarks</a> post a while ago, I am
currently working on improving the memory behaviour of PyPy's Python
interpreter. In this blog post I want to describe the various data a Python
instance can store. Then I want to describe how a branch that I did and that was
recently merged implements the various features of instances in a very
memory-efficient way.</p>
<div class="section" id="python-s-object-model">
<h2>Python's Object Model</h2>
<p>All "normal" new-style Python instances (i.e. instances of subclasses of <tt class="docutils literal">object</tt>
without added declarations) store two (or possibly three) kinds of information.</p>
<div class="section" id="storing-the-class">
<h3>Storing the Class</h3>
<p>Every instance knows which class it belongs to. This information is accessible
via the <tt class="docutils literal">.__class__</tt> attribute. It can also be changed to other (compatible
enough) classes by writing to that attribute.</p>
</div>
<div class="section" id="instance-variables">
<h3>Instance Variables</h3>
<p>Every instance also has an arbitrary number of attributes stored (also called
instance variables). The instance variables used can vary per instance, which is
not the case in most other class-based languages: traditionally (e.g. in
Smalltalk or Java) the class describes the shape of its instances,
which means that the
set of admissible instance variable names is the same for all instances of a
class.</p>
<p>In Python on the other hand, it is possible to add arbitrary attributes to an
instance at any point. The instance behaves like a dictionary mapping attribute
names (as strings) to the attribute values.</p>
<p>This is actually how CPython implements instances. Every instance has a
reference to a dictionary that stores all the attributes of the instance. This
dictionary can be reached via the <tt class="docutils literal">.__dict__</tt> attribute. To make things more
fun, the dictionary can also be <em>changed</em> by writing to that attribute.</p>
</div>
<div class="section" id="example">
<h3>Example</h3>
<p>As an example, consider the following code:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">A</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">pass</span>

instance1 <span style="color: #555555;">=</span> A()
instance1<span style="color: #555555;">.</span>x <span style="color: #555555;">=</span> <span style="color: #FF6600;">4</span>
instance1<span style="color: #555555;">.</span>y <span style="color: #555555;">=</span> <span style="color: #FF6600;">6</span>
instance1<span style="color: #555555;">.</span>z <span style="color: #555555;">=</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>

instance2 <span style="color: #555555;">=</span> A()
instance2<span style="color: #555555;">.</span>x <span style="color: #555555;">=</span> <span style="color: #FF6600;">1</span>
instance2<span style="color: #555555;">.</span>y <span style="color: #555555;">=</span> <span style="color: #FF6600;">2</span>
instance2<span style="color: #555555;">.</span>z <span style="color: #555555;">=</span> <span style="color: #FF6600;">3</span>
</pre></div>
<p>These two instances would look something like this in memory:</p>
<a href="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6__OBefcI/AAAAAAAAAMg/vmOMwGa5mKw/s1600/instance-grey.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075684529241538" src="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6__OBefcI/AAAAAAAAAMg/vmOMwGa5mKw/s400/instance-grey.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 57px;"></a>
<p>(The picture glosses over a number of details, but it still shows the essential
issues.)</p>
<p>This way of storing things is simple, but unfortunately rather inefficient. Most
instances of the same class have the same shape, i.e. the same set of instance
attribute names. That means that the key part of all the dictionaries is
identical (shown grey here). Therefore storing that part repeatedly in all
instances is a waste. In addition, dictionaries are themselves rather large.
Since they are typically implemented as hashmaps, which must not be too full to
be efficient, a dictionary will use something like 6 words on average per key.</p>
</div>
<div class="section" id="slots">
<h3>Slots</h3>
<p>Since normal instances are rather large, CPython 2.2 introduced slots, to make
instances consume less memory. Slots are a way to fix the set of attributes an
instance can have. This is achieved by adding a declaration to a class, like
this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">B</span>(<span style="color: #336666;">object</span>):
    __slots__ <span style="color: #555555;">=</span> [<span style="color: #CC3300;">"x"</span>, <span style="color: #CC3300;">"y"</span>, <span style="color: #CC3300;">"z"</span>]
</pre></div>
<p>Now the instances of <tt class="docutils literal">B</tt> can only have <tt class="docutils literal">x</tt>, <tt class="docutils literal">y</tt> and <tt class="docutils literal">z</tt> as attributes
and don't have a dictionary at all. Instead, the instances of <tt class="docutils literal">B</tt> get
allocated with enough size to hold exactly the number of instance variables that
the class permits. This clearly saves a lot of memory over the dictionary
approach, but has a number of disadvantages. It is obviously less flexible, as
you cannot add additional instance variables to an instance if you happen to
need to do that. It also introduces a set of <a class="reference external" href="https://docs.python.org/reference/datamodel.html#slots">rules and corner-cases</a> that can
be surprising sometimes (e.g. instances of a subclass of a class with slots that
doesn't have a slots declaration will have a dict).</p>
</div>
</div>
<div class="section" id="using-maps-for-memory-efficient-instances">
<h2>Using Maps for Memory-Efficient Instances</h2>
<p>As we have seen in the diagram above, the dictionaries of instances of the same
class tend to look very similar and share all the keys. The central idea to use
less memory is to "factor out" the common parts of the instance dictionaries
into a new object, called a "map" (because it is a guide to the landscape of the
object, or something). After that factoring out, the representation of the
instances above looks something like this:</p>
<a href="https://2.bp.blogspot.com/_zICyAWqZbLA/TN6__c74O3I/AAAAAAAAAMo/CxNPGbfD8bc/s1600/instancemap.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075688532294514" src="https://2.bp.blogspot.com/_zICyAWqZbLA/TN6__c74O3I/AAAAAAAAAMo/CxNPGbfD8bc/s400/instancemap.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 59px;"></a>
<p>Every instance now has a reference to its map, which describes what the instance
looks like. The actual instance variables are stored in an array (called
<tt class="docutils literal">storage</tt> in the diagram). In the example here, the map describes that the
instances have three attributes <tt class="docutils literal">x</tt>, <tt class="docutils literal">y</tt> and <tt class="docutils literal">z</tt>. The numbers after the
attributes are indexes into the storage array.</p>
<p>If somebody adds a new attribute to one of the instances, the map for that
instance will be changed to another map that also contains the new attribute,
and the storage will have to grow a field with the new attribute. The maps are
immutable, immortal and reused as much as possible. This means, that two
instances of the same class with the same set of attributes will have the same
map. This also means that the memory the map itself uses is not too important,
because it will potentially be amortized over many instances.</p>
<p>Note that using maps makes instances nearly as small as if the correct slots had
been declared in the class. The only overhead needed is the indirection to the
storage array, because you can get new instance variables, but not new slots.</p>
<p>The concept of a "map" that describes instances is kind of old and comes from
the virtual machine for the <a class="reference external" href="https://en.wikipedia.org/wiki/Self_%28programming_language%29">Self</a> programming language. The optimization was
first described in 1989 in a paper by Chambers, Ungar and Lee with the title <a class="reference external" href="https://labs.oracle.com/self/papers/implementation.html">An
Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language
Based on Prototypes</a>. A similar technique is used in Google's V8 JavaScript
engine, where the maps are called <a class="reference external" href="https://code.google.com/apis/v8/design.html#prop_access">hidden classes</a> and in the <a class="reference external" href="https://blogs.sun.com/jrose/entry/javaone_in_2010">Rhino
JavaScript engine</a>.</p>
<p>The rest of the post describes a number of further details that occur if
instances are implemented using maps.</p>
<div class="section" id="supporting-dictionaries-with-maps">
<h3>Supporting Dictionaries with Maps</h3>
<p>The default instance representation with maps as shown above works without
actually having a dictionary as part of each instance. If a dictionary is
actually requested, by accessing the <tt class="docutils literal">.__dict__</tt> attribute, it needs to be
created and cached. The dictionary is not a normal Python dictionary, but a thin
wrapper around the object that forwards all operations to it. From the user's
point of view it behaves like a normal dictionary though (it even has the
correct type).</p>
<p>The dictionary needs to be cached, because accessing <tt class="docutils literal">.__dict__</tt> several times
should always return the same dictionary. The caching happens by using a
different map that knows about the dictionary and putting the dictionary into
the storage array:</p>
<a href="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6__ibswtI/AAAAAAAAAMw/ZBY7pvZAel8/s1600/dictinstancemap.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075690007937746" src="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6__ibswtI/AAAAAAAAAMw/ZBY7pvZAel8/s400/dictinstancemap.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 102px;"></a>
<p>Things become really complex if the fake dict is used in strange ways. As long
as the keys are strings, everything is fine. If somebody adds other keys to the
dict, they cannot be represented by the map any more (which supports only
attributes, i.e. string keys in the <tt class="docutils literal">__dict__</tt>). If that happens, all the
information of the instance will move into the fake dictionary, like this:</p>
<a href="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6___mTkZI/AAAAAAAAAM4/2F-B8drBvKk/s1600/dictinstancemapdevolved.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075697837052306" src="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6___mTkZI/AAAAAAAAAM4/2F-B8drBvKk/s400/dictinstancemapdevolved.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 249px;"></a>
<p>In this picture, the key <tt class="docutils literal"><span class="pre">-1</span></tt> was added to the instance's dictionary. Since
using the dictionary in arbitrary ways should be rare, we are fine with the
additional time and memory that the approach takes.</p>
</div>
<div class="section" id="slots-and-maps">
<h3>Slots and Maps</h3>
<p>Maps work perfectly together with slots, because the slots can just be stored
into the storage array used by the maps as well (in practise there are some
refinements to that scheme).  This means that putting a <tt class="docutils literal">__slots__</tt> on a
class has mostly no effect, because the instance only stores the values of the
attributes (and not the names), which is equivalent to the way slots are stored
in CPython.</p>
</div>
</div>
<div class="section" id="implementation-details">
<h2>Implementation Details</h2>
<p>In the diagrams above, I represented the maps as flat objects. In practise this
is a bit more complex, because it needs to be efficient to go from one map to
the next when new attributes are added. Thus the maps are organized in a tree.</p>
<p>The instances with their maps from above look a bit more like this in practise:</p>
<a href="https://4.bp.blogspot.com/_zICyAWqZbLA/TN7AABHntqI/AAAAAAAAANA/YHVsUp51d60/s1600/realmap.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075698245220002" src="https://4.bp.blogspot.com/_zICyAWqZbLA/TN7AABHntqI/AAAAAAAAANA/YHVsUp51d60/s400/realmap.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 271px;"></a>
<p>Every map just describes one attribute of the object, with a name and a an
index. Every map also has a <tt class="docutils literal">back</tt> field, that points to another map
describing what the rest of the object looks like. This chain ends with a
terminator, which also stores the class of the object.</p>
<p>The maps also contain the information necessary for making a new object of
class <tt class="docutils literal">A</tt>. Immediately after the new object has been created, its map is the
terminator. If the <tt class="docutils literal">x</tt> attribute is added, its maps is changed to the
second-lowest map, and so on. The blue arrows show the sequence of maps that
the new object goes through when the attributes <tt class="docutils literal">x, y, z</tt> are added.</p>
<p>This representation of maps as chains of objects sounds very inefficient if an
object has many attributes. The whole chain has to be walked to find the index.
This is true to some extent. The problem goes away in the presence of the JIT,
which knows that the chain of maps is an immutable structure, and will thus
optimize away all the chain-walking. If the JIT is not used, there are a few
caches that try to speed up the walking of this chain (similar to the method
cache in CPython and PyPy).</p>
</div>
<div class="section" id="results">
<h2>Results</h2>
<p>It's hard to compare the improvements of this optimization in a fair way, as
the trade-offs are just very different. Just to give an impression, a million
objects of the same class with three fields on a 32bit system takes:</p>
<p>without slots:</p>
<ul class="simple">
<li>182 MiB memory in CPython</li>
<li>177 MiB memory in PyPy without maps</li>
<li>40 MiB memory in PyPy with maps</li>
</ul>
<p>with slots:</p>
<ul class="simple">
<li>45 MiB memory in CPython</li>
<li>50 MiB memory in PyPy without maps</li>
<li>40 MiB memory in PyPy with maps</li>
</ul>
<p>Note how maps make the objects a bit more efficient like CPython using slots.
Also, using slots has no additional effect in PyPy.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>Maps are a powerful approach to shrinking the memory used by many similar
instances. I think they can be pushed even further (e.g. by adding information
about the types of the attributes) and plan to do so in the following months.
Details will be forthcoming.</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-5783692099276223419">
        <div class="comment-header">
          <a name="comment-5783692099276223419"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2010-11-13 17:28</span>:
        </div>
        <div class="comment-content">
          <p>Not sure if you are glossing over this, but it seems trivial to avoid the map chain walking by duplicating all of the information in a maps back pointer chain into the map itself.  However, the lookup keys are still strings, so your options are some kind of frozen hashtable (which could be nice) or a sorted array.<br><br>Both of those still seem much more efficient than chasing pointers.</p>
        </div>
      </div>
      <div class="comment comment-3507693547785476828">
        <div class="comment-header">
          <a name="comment-3507693547785476828"></a>
            <span class="author">Erez</span> wrote on <span class="date">2010-11-13 19:08</span>:
        </div>
        <div class="comment-content">
          <p>What about the additional running time overhead?</p>
        </div>
      </div>
      <div class="comment comment-5462825228324060529">
        <div class="comment-header">
          <a name="comment-5462825228324060529"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-13 20:48</span>:
        </div>
        <div class="comment-content">
          <p>I was surprised not to see any real-world benchmarks (since you collected them earlier). That leaves the impression, that it might be disapointing (knowing that the object/class ratio generally isn't very large).</p>
        </div>
      </div>
      <div class="comment comment-1445643915832363259">
        <div class="comment-header">
          <a name="comment-1445643915832363259"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-11-13 21:48</span>:
        </div>
        <div class="comment-content">
          <p>@Reid:<br>I am glossing over the runtime overhead, because the JIT completely removes it, as it knows that the maps are immutable. So you only have a problem if you don't want a JIT, in which case maps indeed make some things a bit slower. Duplicating the information everywhere is possible, but I would like to avoid it (we had a prototype that did it, and it became messy quickly).<br><br>@Erez<br>There is no additional runtime overhead if you have the JIT â€“ in fact, things become faster, because the JIT can turn an attribute access into a array field read out of the storage array at a fixed offset.<br><br>@Anonymous<br>I have not presented any real-world benchmarks, because I actually did not get around to running them. Yes, I collected some and started writing a memory benchmark framework. But I didn't have time for a full analysis yet. I plan to do such an analysis hopefully soon.<br><br>Anyway, maps never make anything larger, so it is really just a matter of how many instances there are in practice. This will just depend on the benchmark.</p>
        </div>
      </div>
      <div class="comment comment-4973317805930862659">
        <div class="comment-header">
          <a name="comment-4973317805930862659"></a>
            <span class="author">Zeev</span> wrote on <span class="date">2010-11-14 00:13</span>:
        </div>
        <div class="comment-content">
          <p>Does this optimization enable building pypy using pypy without having 16GB of ram?</p>
        </div>
      </div>
      <div class="comment comment-8109962982969843413">
        <div class="comment-header">
          <a name="comment-8109962982969843413"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-14 01:29</span>:
        </div>
        <div class="comment-content">
          <p>Is there anything intrinsic toPyPy in this, or can this optimisation be used in CPython as well?</p>
        </div>
      </div>
      <div class="comment comment-4211257088140676616">
        <div class="comment-header">
          <a name="comment-4211257088140676616"></a>
            <span class="author">ot</span> wrote on <span class="date">2010-11-14 03:16</span>:
        </div>
        <div class="comment-content">
          <p>To remove the chain-walking overhead when the code is not JITted, would it be possible to use a persistent hashtable, like for example the hash trie used in Clojure (see https://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice/)? They are quite simple to implement and very fast (almost as fast as a normal hashtable lookup)</p>
        </div>
      </div>
      <div class="comment comment-5202625175156727929">
        <div class="comment-header">
          <a name="comment-5202625175156727929"></a>
            <span class="author">Allen Short</span> wrote on <span class="date">2010-11-14 08:34</span>:
        </div>
        <div class="comment-content">
          <p>ot: i'm part way to implementing that for Python.<br><br>https://bazaar.launchpad.net/~washort/%2Bjunk/perseus/annotate/head:/perseus/__init__.py</p>
        </div>
      </div>
      <div class="comment comment-5294634611556603176">
        <div class="comment-header">
          <a name="comment-5294634611556603176"></a>
            <span class="author">ot</span> wrote on <span class="date">2010-11-14 21:23</span>:
        </div>
        <div class="comment-content">
          <p>@Allen: interesting, I wonder how much code would need to be changed to make it RPython...</p>
        </div>
      </div>
      <div class="comment comment-5681147692410048223">
        <div class="comment-header">
          <a name="comment-5681147692410048223"></a>
            <span class="author">verte</span> wrote on <span class="date">2010-11-15 07:45</span>:
        </div>
        <div class="comment-content">
          <p>What are the pypy "with slots" and "without slots" numbers? They are different even though you point out that they have no effect. Is the pypy in question one with sharing dicts?</p>
        </div>
      </div>
      <div class="comment comment-7772094251400965646">
        <div class="comment-header">
          <a name="comment-7772094251400965646"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-15 07:56</span>:
        </div>
        <div class="comment-content">
          <p>@verte mapdicts help pypy objects with or without slots (although much more for the latter). There is no difference in pypy with mapdict between having slots or not having slots.</p>
        </div>
      </div>
      <div class="comment comment-3845360728805325221">
        <div class="comment-header">
          <a name="comment-3845360728805325221"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-11-15 12:58</span>:
        </div>
        <div class="comment-content">
          <p>@Zeev no, the translation results from last week already included this optimization. Maps don't help translation much, because we already added all the necessary slot declarations to save memory on CPython.<br><br>@ot Would be possible, yes. Not sure it is worth it, given that the total set of attributes of typical instances is not very large. The data structure looks interesting though.</p>
        </div>
      </div>
      <div class="comment comment-2328794658467699116">
        <div class="comment-header">
          <a name="comment-2328794658467699116"></a>
            <span class="author">ot</span> wrote on <span class="date">2010-11-15 13:21</span>:
        </div>
        <div class="comment-content">
          <p>@Carl: yes, it was just hypotetic, "if it is a bottleneck". I think anyway that even with very small instance dictionaries there could be a benefit: most keys would be resolved within the first layer of the trie, so with a single lookup or two at most. But it could be premature optimization.</p>
        </div>
      </div>
      <div class="comment comment-2140109847813676734">
        <div class="comment-header">
          <a name="comment-2140109847813676734"></a>
            <span class="author">verte</span> wrote on <span class="date">2010-11-16 00:30</span>:
        </div>
        <div class="comment-content">
          <p>I still don't understand. Was there a difference with __slots__ on pypy before mapdict? Why are the numbers different on pypy without mapdict? Are those the numbers with or without the old sharing dictimpl? If without, what is the memory usage with sharing dicts?</p>
        </div>
      </div>
      <div class="comment comment-2450714668067085687">
        <div class="comment-header">
          <a name="comment-2450714668067085687"></a>
            <span class="author">barnert</span> wrote on <span class="date">2014-08-03 23:31</span>:
        </div>
        <div class="comment-content">
          <p>This came up on <a href="https://stackoverflow.com/questions/13761423/does-pep-412-make-slots-redundant/13763204#comment39074868_13763204" rel="nofollow">StackOverflow</a>, but let me answer it here.<br><br>While the CPython split-dict implementation in 3.3+ (<a href="https://legacy.python.org/dev/peps/pep-0412/" rel="nofollow">PEP 412</a>) may be inspired by your design, it's not the same, and it doesn't provide nearly as much savings.<br><br>The first difference is that it still has a full dict struct in the instance. For classes without that many attributes (i.e., most of them), the dict struct is almost as big as the hash table, so this means you typically only get half the savings as in PyPy. However, this means the thing you can access by __dict__ isn't created dynamically, it acts exactly like a dict even at the C API level, and it can transparently (again, even at the C API level) convert itself to a combined dict if needed (if the table needs to expand and there's more than one reference to the shared key table). The fact that the difference between 3.2 and 3.3 is completely undetectable to any code that doesn't directly access the hash buckets is a big part of the reason Mark Shannon was able to get everyone to agree to accept it, and as far as I know there's no serious consideration for changing it.<br><br>The second difference is that the dict struct's array is kept in the same (sparse) order as the shared key table, rather than being a compact array indexed by the values of the shared key table. This means it's kept at least 1/3rd unloaded, meaning that again you get less space savings than with PyPy. There's less of a good rationale here; there's a small performance cost to the slightly more complicated code needed for indexing PyPy-style, and it would make small combined dicts one word larger (which could affect classes whose instances all have different attributes, or cases where you have a huge number of classes with few instances, or other edge cases). The PEP implies that using the sparse implementation is probably overly conservative, and leaves open the possibility of changing it after 3.3.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/11/speeding-up-pypy-by-donations-6035529829962326007.html" class="u-url">Speeding up PyPy by donations</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/holger-krekel.html">holger krekel</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/11/speeding-up-pypy-by-donations-6035529829962326007.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-11-10T15:40:00Z" itemprop="datePublished" title="2010-11-10 15:40">2010-11-10 15:40</time></a>
            </p>
                <p class="commentline">3 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <div class="document" id="pypy-joins-the-software-freedom-conservancy">
<h3 class="title">PyPy joins the Software Freedom Conservancy</h3>

<p>Good news. PyPy is now a member of the Software Freedom Conservancy (SFC),
see <a class="reference external" href="https://sfconservancy.org/news/2010/nov/10/pypy-joins/">the SFC blog post</a>.  This allows us to manage non-profit monetary aspects of
the project independently from a company or particular persons.   So we
can now officially receive donations both from people prefering right or
left sides, see the <tt class="docutils literal">Donate</tt> buttons on our <a class="reference external" href="https://pypy.org/">home page</a> and our <a class="reference external" href="https://morepypy.blogspot.com/">blog</a>.
And you can use PayPal or Google Checkout, Donations are tax-exempt in the
USA and hopefully soon in Europe as well.</p>
<p>What's it going to get used for?  For the immediate future we intend to use
the donations for funding travels of core contributors to PyPy sprints
who otherwise can't afford to come.  So if you have no time but some
money you can help to encourage coding contributors to care for PyPy.
If we end up with bigger sums we'll see and take suggestions.  Money
spending decisions will be done by core PyPy people according to
non-profit guidelines.  And we'll post information from time to time
about how much we got and where the money went.</p>
<p>If you have any questions regarding the SFC membership or donations
you may send email to sfc at pypy.org  which will be observed
by Carl Friedrich Bolz, Jacob Hallen and Holger Krekel - the initial
PyPy SFC representatives on behalf of the PyPy team.  Many thanks go
out to Bradley M. Kuhn for helping to implement the PyPy SFC membership.</p>
<p>cheers,</p>
<p>Holger &amp; Carl Friedrich</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-4199949154450484847">
        <div class="comment-header">
          <a name="comment-4199949154450484847"></a>
            <span class="author">glyph</span> wrote on <span class="date">2010-11-11 08:13</span>:
        </div>
        <div class="comment-content">
          <p>Congratulations, welcome to the SFC family!  It's been great for Twisted.  Just donated $25 myself - now go make Twisted faster on PyPy :).</p>
        </div>
      </div>
      <div class="comment comment-8038428262731309136">
        <div class="comment-header">
          <a name="comment-8038428262731309136"></a>
            <span class="author">holger krekel</span> wrote on <span class="date">2010-11-11 13:13</span>:
        </div>
        <div class="comment-content">
          <p>Thanks glyph.  I realized we should have mentioned Twisted already in the post since you are working through the SFC for some time now.  In fact, your being there was a good argument for us to also consider going there, so thanks for that :)</p>
        </div>
      </div>
      <div class="comment comment-7331711214057123433">
        <div class="comment-header">
          <a name="comment-7331711214057123433"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-11-11 13:14</span>:
        </div>
        <div class="comment-content">
          <p>@glyph cool, thanks! As for making Twisted faster, we already did some of that: https://bit.ly/aGCY6r<br>No clue how these benchmarks reflect an actual application of course :-)</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/11/snake-which-bites-its-tail-pypy-jitting-5161284681004717142.html" class="u-url">A snake which bites its tail: PyPy JITting itself</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/antonio-cuni.html">Antonio Cuni</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/11/snake-which-bites-its-tail-pypy-jitting-5161284681004717142.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-11-09T17:32:00Z" itemprop="datePublished" title="2010-11-09 17:32">2010-11-09 17:32</time></a>
            </p>
                <p class="commentline">21 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <a href="https://2.bp.blogspot.com/_4gR6Ggu8oHQ/TNmLArIQa0I/AAAAAAAAAKk/S86e8w4lF6g/s1600/pypy.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5537610060522351426" src="https://2.bp.blogspot.com/_4gR6Ggu8oHQ/TNmLArIQa0I/AAAAAAAAAKk/S86e8w4lF6g/s400/pypy.png" style="float: right; margin: 0 0 10px 10px; cursor: pointer; cursor: hand; width: 321px; height: 263px;"></a>


<p>We have to admit: even if we have been writing for years about the fantastic
speedups that the PyPy JIT gives, we, the PyPy developers, still don't use it
for our daily routine.  <strong>Until today</strong> :-).</p>
<p>Readers brave enough to run <tt class="docutils literal">translate.py</tt> to translate PyPy by themselves
surely know that the process takes quite a long time to complete, about a hour
on super-fast hardware and even more on average computers.  Unfortunately, it
happened that <tt class="docutils literal">translate.py</tt> was a bad match for our JIT and thus ran much
slower on PyPy than on CPython.</p>
<p>One of the main reasons is that the PyPy translation toolchain makes heavy use
of custom metaclasses, and until few weeks ago metaclasses disabled some of
the central optimizations which make PyPy so fast.  During the recent
<a class="reference external" href="../posts/2010/10/dusseldorf-sprint-report-2010-371223200425847723.html">DÃ¼sseldorf sprint</a>, Armin and Carl Friedrich <a class="reference external" href="https://codespeak.net/pipermail/pypy-svn/2010-October/044046.html">fixed</a> this problem and
re-enabled all the optimizations even in presence of metaclasses.</p>
<p>So, today we decided that it was time to benchmark again PyPy against itself.
First, we tried to translate PyPy using CPython as usual, with the following
command line (on a machine with an "Intel(R) Xeon(R) CPU W3580 @ 3.33GHz" and
12 GB of RAM, running a 32-bit Ubuntu):</p>
<pre class="literal-block">
$ python ./translate.py -Ojit targetpypystandalone --no-allworkingmodules

... lots of output, fractals included ...

[Timer] Timings:
[Timer] annotate                       ---  252.0 s
[Timer] rtype_lltype                   ---  199.3 s
[Timer] pyjitpl_lltype                 ---  565.2 s
[Timer] backendopt_lltype              ---  217.4 s
[Timer] stackcheckinsertion_lltype     ---   26.8 s
[Timer] database_c                     ---  234.4 s
[Timer] source_c                       ---  480.7 s
[Timer] compile_c                      ---  258.4 s
[Timer] ===========================================
[Timer] Total:                         --- 2234.2 s
</pre>
<p>Then, we tried the same command line with PyPy (SVN revision 78903, x86-32 JIT
backend, downloaded from the <a class="reference external" href="https://buildbot.pypy.org/nightly/trunk/">nightly build</a> page):</p>
<pre class="literal-block">
$ pypy-c-78903 ./translate.py -Ojit targetpypystandalone --no-allworkingmodules

... lots of output, fractals included ...

[Timer] Timings:
[Timer] annotate                       ---  165.3 s
[Timer] rtype_lltype                   ---  121.9 s
[Timer] pyjitpl_lltype                 ---  224.0 s
[Timer] backendopt_lltype              ---   72.1 s
[Timer] stackcheckinsertion_lltype     ---    7.0 s
[Timer] database_c                     ---  104.4 s
[Timer] source_c                       ---  167.9 s
[Timer] compile_c                      ---  320.3 s
[Timer] ===========================================
[Timer] Total:                         --- 1182.8 s
</pre>
<p>Yes, it's not a typo: PyPy is almost <strong>two times faster</strong> than CPython!
Moreover, we can see that PyPy is faster in each of the individual steps apart
<tt class="docutils literal">compile_c</tt>, which consists in just a call to <tt class="docutils literal">make</tt> to invoke <tt class="docutils literal">gcc</tt>.
The slowdown comes from the fact that the Makefile also contains a lot of
calls to the <a class="reference external" href="https://codespeak.net/svn/pypy/trunk/pypy/translator/c/gcc/trackgcroot.py">trackgcroot.py</a> script, which happens to perform badly on PyPy
but we did not investigate why yet.</p>
<p>However, there is also a drawback: on this specific benchmark, PyPy consumes
much more memory than CPython.  The reason why the command line above contains
<tt class="docutils literal"><span class="pre">--no-allworkingmodules</span></tt> is that if we include all the modules the
translation crashes when it's complete at 99% because it consumes all the 4GB
of memory which is addressable by a 32-bit process.</p>
<p>A partial explanation if that so far the assembler generated by the PyPy JIT
is immortal, and the memory allocated for it is never reclaimed.  This is
clearly bad for a program like <tt class="docutils literal">translate.py</tt> which is divided into several
independent steps, and for which most of the code generated in each step could
be safely be thrown away when it's completed.</p>
<p>If we switch to 64-bit we can address the whole 12 GB of RAM that we have, and
thus translating with all working modules is no longer an issue.  This is the
time taken with CPython (note that it does not make sense to compare with the
32-bit CPython translation above, because that one does not include all the
modules):</p>
<pre class="literal-block">
$ python ./translate.py -Ojit

[Timer] Timings:
[Timer] annotate                       ---  782.7 s
[Timer] rtype_lltype                   ---  445.2 s
[Timer] pyjitpl_lltype                 ---  955.8 s
[Timer] backendopt_lltype              ---  457.0 s
[Timer] stackcheckinsertion_lltype     ---   63.0 s
[Timer] database_c                     ---  505.0 s
[Timer] source_c                       ---  939.4 s
[Timer] compile_c                      ---  465.1 s
[Timer] ===========================================
[Timer] Total:                         --- 4613.2 s
</pre>
<p>And this is for PyPy:</p>
<pre class="literal-block">
$ pypy-c-78924-64 ./translate.py -Ojit

[Timer] Timings:
[Timer] annotate                       ---  505.8 s
[Timer] rtype_lltype                   ---  279.4 s
[Timer] pyjitpl_lltype                 ---  338.2 s
[Timer] backendopt_lltype              ---  125.1 s
[Timer] stackcheckinsertion_lltype     ---   21.7 s
[Timer] database_c                     ---  187.9 s
[Timer] source_c                       ---  298.8 s
[Timer] compile_c                      ---  650.7 s
[Timer] ===========================================
[Timer] Total:                         --- 2407.6 s
</pre>
<p>The results are comparable with the 32-bit case: PyPy is still almost 2 times
faster than CPython.  And it also shows that our 64-bit JIT backend is as good
as the 32-bit one.  Again, the drawback is in the consumed memory: CPython
used 2.3 GB while PyPy took 8.3 GB.</p>
<p>Overall, the results are impressive: we knew that PyPy can be good at
optimizing small benchmarks and even middle-sized programs, but as far as we
know this is the first example in which it heavily optimizes a huge, real world
application.  And, believe us, the PyPy translation toolchain is complex
enough to contains all kinds of dirty tricks and black magic that make Python
lovable and hard to optimize :-).</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-457770828661469514">
        <div class="comment-header">
          <a name="comment-457770828661469514"></a>
            <span class="author">Victor</span> wrote on <span class="date">2010-11-09 17:50</span>:
        </div>
        <div class="comment-content">
          <p>This is amazing, huge kudos to all PyPy developers!<br><br>Do these results include "HÃ¥kan's jit-unroll-loops branch" you mentioned in sprint report? When are we going to get a release containing these improvements? And do the nightly builds include them?</p>
        </div>
      </div>
      <div class="comment comment-754875425435548503">
        <div class="comment-header">
          <a name="comment-754875425435548503"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-11-09 18:05</span>:
        </div>
        <div class="comment-content">
          <p>@Victor: No, HÃ¥kan's branch has not been merged. It still has some problems that we don't quite know how to solve.<br><br>The nightly builds include all other improvements though. We plan to do a release at some point soon.</p>
        </div>
      </div>
      <div class="comment comment-5294922705279297360">
        <div class="comment-header">
          <a name="comment-5294922705279297360"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-09 18:28</span>:
        </div>
        <div class="comment-content">
          <p>This is great!<br><br>One question: A while back, after the GSoC project for 64-bit, there was an issue with asmgcc-64 such that the 64-bit GC was slower than it should be.<br><br>It appears from the performance described in this post, that that must be resolved now. Is that right?<br><br>Thanks,<br>Gary</p>
        </div>
      </div>
      <div class="comment comment-2549981730179807318">
        <div class="comment-header">
          <a name="comment-2549981730179807318"></a>
            <span class="author">Leonardo Santagada</span> wrote on <span class="date">2010-11-09 18:36</span>:
        </div>
        <div class="comment-content">
          <p>There should be a way to not only throw away jit memory but somehow tell pypy to try to not use more than say 3gb of ram so it will not hit swap on 4gb machines.</p>
        </div>
      </div>
      <div class="comment comment-1854764887627800176">
        <div class="comment-header">
          <a name="comment-1854764887627800176"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-09 18:39</span>:
        </div>
        <div class="comment-content">
          <p>@Gary yes, that is correct</p>
        </div>
      </div>
      <div class="comment comment-7010819725315048516">
        <div class="comment-header">
          <a name="comment-7010819725315048516"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-09 23:00</span>:
        </div>
        <div class="comment-content">
          <p>Wow, cool work!</p>
        </div>
      </div>
      <div class="comment comment-4018845240154714849">
        <div class="comment-header">
          <a name="comment-4018845240154714849"></a>
            <span class="author">Eric van Riet Paap</span> wrote on <span class="date">2010-11-09 23:26</span>:
        </div>
        <div class="comment-content">
          <p>Excellent.. congratulations!</p>
        </div>
      </div>
      <div class="comment comment-3564411200439829057">
        <div class="comment-header">
          <a name="comment-3564411200439829057"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2010-11-09 23:30</span>:
        </div>
        <div class="comment-content">
          <p>Wow, looks great! <br><br>Many thanks for posting the benchmark â€“ and for your relentless work on pypy!<br><br>One thing: Could you add tests comparing with programs converted to python3?</p>
        </div>
      </div>
      <div class="comment comment-3751388925560533742">
        <div class="comment-header">
          <a name="comment-3751388925560533742"></a>
            <span class="author">Antonio Cuni</span> wrote on <span class="date">2010-11-10 07:21</span>:
        </div>
        <div class="comment-content">
          <p>@ArneBab: I'm not sure what you mean, but consider that at the moment PyPy does not support Python 3, so it does not make sense to compare against it.</p>
        </div>
      </div>
      <div class="comment comment-433573818662290636">
        <div class="comment-header">
          <a name="comment-433573818662290636"></a>
            <span class="author">Michael Foord</span> wrote on <span class="date">2010-11-10 16:04</span>:
        </div>
        <div class="comment-content">
          <p>PyPy continues to get more and more impressive.</p>
        </div>
      </div>
      <div class="comment comment-6600655960308450665">
        <div class="comment-header">
          <a name="comment-6600655960308450665"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2010-11-10 17:02</span>:
        </div>
        <div class="comment-content">
          <p>For reference, at some point (long ago) I tried to use Psyco to speed up translate.py on CPython; but i didn't make any difference -- I'm guessing it's because we have nested scope variables at a few critical points, which Psyco cannot optimize.  Now I no longer have a need for that :-)</p>
        </div>
      </div>
      <div class="comment comment-2015589656924032306">
        <div class="comment-header">
          <a name="comment-2015589656924032306"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-10 23:19</span>:
        </div>
        <div class="comment-content">
          <p>Very cool achievement.  I'm curious however to know why compile_c section is slower.  I thought it was mostly waiting on external programs to run and so should of been similar time cpython?  Congratulations!</p>
        </div>
      </div>
      <div class="comment comment-7039009230695346103">
        <div class="comment-header">
          <a name="comment-7039009230695346103"></a>
            <span class="author">Antonio Cuni</span> wrote on <span class="date">2010-11-11 10:28</span>:
        </div>
        <div class="comment-content">
          <p>@Anonymous: you are right when you say that compile_c mostly invokes gcc, but also a python script called trackgcroot.py.<br><br>The python script is run with the same interpreter using for translate.py (so pypy in this case), and it happens that it's slower than with cpython.</p>
        </div>
      </div>
      <div class="comment comment-3055202868498579159">
        <div class="comment-header">
          <a name="comment-3055202868498579159"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-11 13:03</span>:
        </div>
        <div class="comment-content">
          <p>How come the 64 bit timings are so much worse than the 32 bit timings (both CPython and PyPy)?</p>
        </div>
      </div>
      <div class="comment comment-6637380789173283501">
        <div class="comment-header">
          <a name="comment-6637380789173283501"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-11-11 13:11</span>:
        </div>
        <div class="comment-content">
          <p>@Anonymous: Because the 64bit version is translating all modules, which simply gives the translator a lot more to do. We cannot do that yet on 32bit due to memory problems.</p>
        </div>
      </div>
      <div class="comment comment-2933333625046513876">
        <div class="comment-header">
          <a name="comment-2933333625046513876"></a>
            <span class="author">Victor</span> wrote on <span class="date">2010-11-11 17:26</span>:
        </div>
        <div class="comment-content">
          <p>@cfbolz Well, but you sure can run the 64bit version with the same module list as you did for 32bit... So if running the benchmark again in the same conditions isn't a lot of work, it'd provide yet another interesting data point ;)</p>
        </div>
      </div>
      <div class="comment comment-3376534848460569297">
        <div class="comment-header">
          <a name="comment-3376534848460569297"></a>
            <span class="author">adimasci</span> wrote on <span class="date">2010-11-12 07:13</span>:
        </div>
        <div class="comment-content">
          <p>Nice work !</p>
        </div>
      </div>
      <div class="comment comment-8396560491293375089">
        <div class="comment-header">
          <a name="comment-8396560491293375089"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-12 07:29</span>:
        </div>
        <div class="comment-content">
          <p>In other words: The pypy jit compiler leaks a massive amount of memory. Will you address this issue?</p>
        </div>
      </div>
      <div class="comment comment-879554982667399974">
        <div class="comment-header">
          <a name="comment-879554982667399974"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-12 07:58</span>:
        </div>
        <div class="comment-content">
          <p>Technically it's not "leaking". And yes, we're trying to address this issue.</p>
        </div>
      </div>
      <div class="comment comment-7858753886330788277">
        <div class="comment-header">
          <a name="comment-7858753886330788277"></a>
            <span class="author">Tim Parkin</span> wrote on <span class="date">2010-11-23 10:10</span>:
        </div>
        <div class="comment-content">
          <p>Yes I think the word you wanted was "uses" instead of "leaks". The latter implies unforseen problems and errors, the former implies that memory usage hasn't been addressed yet... Just to reiterate - PyPy currently *uses* more memory than CPython.</p>
        </div>
      </div>
      <div class="comment comment-1761767041507751492">
        <div class="comment-header">
          <a name="comment-1761767041507751492"></a>
            <span class="author">Tim Parkin</span> wrote on <span class="date">2010-11-23 10:10</span>:
        </div>
        <div class="comment-content">
          <p>Oh and a huge congratulations for this achievement!!!</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/10/dusseldorf-sprint-report-2010-371223200425847723.html" class="u-url">DÃ¼sseldorf Sprint Report 2010</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/10/dusseldorf-sprint-report-2010-371223200425847723.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-10-31T14:17:00Z" itemprop="datePublished" title="2010-10-31 14:17">2010-10-31 14:17</time></a>
            </p>
                <p class="commentline">6 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <a href="https://3.bp.blogspot.com/_zICyAWqZbLA/TM168_X40bI/AAAAAAAAAMY/Q65Oyd9ufRE/s1600/repo.png">
</a>
<p>This years installment of the yearly PyPy DÃ¼sseldorf Sprint is drawing to a
close. As usual, we worked in the seminar room of the <a class="reference external" href="https://www.stups.uni-duesseldorf.de/">programming language
group</a> at the University of DÃ¼sseldorf. The sprint was different from previous
ones in that we had fewer people than usual and many actually live in
DÃ¼sseldorf all the time.</p>
<p>David spent the sprint working on the <a class="reference external" href="https://codespeak.net/svn/pypy/branch/arm-backend/">arm-backend</a> branch, which is adding an
ARM backend to the JIT. With the help of Armin he added support for bridges in
the JIT and generally implemented missing operations, mostly for handling integers so far.</p>
<p>Ronny and Anto worked the whole week trying to come up with a scheme for
importing PyPy's SVN history into a mercurial repository without loosing too
much information. This is a non-trivial task, because PyPy's history is gnarly.
We are nearly at revision 79000 and when we started using it, Subversion was at
version 0.1. All possible and impossible ways to mangle and mistreat a
Subversion repository have been applied to PyPy's repo, so most of the
importing tools just give up. Ronny and Anto came up with a new plan and new
helper scripts every day, only to then discover another corner case that they
hadn't thought of. Now they might actually have a final plan (but they said
that every day, so who knows?).</p>
<a href="https://3.bp.blogspot.com/_zICyAWqZbLA/TM168_X40bI/AAAAAAAAAMY/Q65Oyd9ufRE/s1600/repo.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5534214705330573746" src="https://3.bp.blogspot.com/_zICyAWqZbLA/TM168_X40bI/AAAAAAAAAMY/Q65Oyd9ufRE/s400/repo.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 400px; height: 240px;">The branch history of PyPy's repository (every box is a branch)</a><p>Carl Friedrich and Lukas started working in earnest on memory benchmarks to
understand the memory behaviour of Python code better. They have now
implemented a generic memory benchmark runner and a simple analysis that walks
all objects and collects size information about them. They also added some
benchmarks that were proposed in the comments of the recent <a class="reference external" href="../posts/2010/08/call-for-benchmarks-2605012131351543912.html">call for
benchmarks</a>. As soon as some results from that work are there, we will post
about them.</p>
<p>There were also some minor tasks performed during the sprint. Armin implemented
the <tt class="docutils literal">_bisect</tt> module and the <tt class="docutils literal">dict.popitem</tt> method in RPython. Armin and
Carl Friedrich made the new memory-saving mapdict implementation more suitable
to use without the JIT (blog post should come about that too, at some point).
They also made classes with custom metaclasses a lot faster when the JIT is
used.</p>
<p>The last three days of the sprint were spent working on HÃ¥kan's
<a class="reference external" href="https://codespeak.net/svn/pypy/branch/jit-unroll-loops/">jit-unroll-loops</a> branch.  The branch is meant to move loop invariants out of
the loop, using techniques very similar to what is described in the recent post
on <a class="reference external" href="../posts/2010/09/using-escape-analysis-across-loop-2887031293132023676.html">escape analysis across loop boundaries</a> (see? it will soon stop being
science-fiction). Some of the ideas of this approach also come from <a class="reference external" href="https://luajit.org/">LuaJIT</a>
which also uses very aggressive loop invariant code motion in its optimizers.
Moving loop invariants outside of the loop is very useful, because many of the
lookups that Python programs do in loops are loop invariants. An example is if
you call a function in a loop: The global lookup can often be done only once.</p>
<p>This branch fundamentally changes some of the core assumptions of the JIT, so
it is a huge amount of work to make it fit with all the other parts and to
adapt all tests. That work is now nearly done, some failing tests remain. The
next steps are to fix them and then do additional tests with the translated
executable and look at the benchmarks.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-4351408054874491495">
        <div class="comment-header">
          <a name="comment-4351408054874491495"></a>
            <span class="author">Luis</span> wrote on <span class="date">2010-11-04 13:58</span>:
        </div>
        <div class="comment-content">
          <p>It's great to see improvements in pypy. At this moment, the only three benchmarks that perform better in cpython than in pypy are spitfire, slow spitfire and twisted_tcp.<br><br>What's the reason for the lower performance on these benchmarks? Is it the same reason for the three or there are multiple causes?<br><br>Luis</p>
        </div>
      </div>
      <div class="comment comment-603706658660129092">
        <div class="comment-header">
          <a name="comment-603706658660129092"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-04 14:03</span>:
        </div>
        <div class="comment-content">
          <p>Hey.<br><br>spitfire and slowspitfire are a 'won't fix' benchmarks (at least in the near future). The spitfire_cstringio is using the same thing, but cStringIO instead of a list of strings.<br><br>Twisted_tcp is slightly more complex and has something to do with pushing a lot of data through sockets. In pypy you usually have to copy data before write, because it can potentially be moved in the GC.<br><br>Cheers,<br>fijal</p>
        </div>
      </div>
      <div class="comment comment-6219139122131514560">
        <div class="comment-header">
          <a name="comment-6219139122131514560"></a>
            <span class="author">Luis</span> wrote on <span class="date">2010-11-04 19:46</span>:
        </div>
        <div class="comment-content">
          <p>Thanks! I suppose "won't fix" has a meaning in a pypy context. What does it mean?</p>
        </div>
      </div>
      <div class="comment comment-7743238805948786685">
        <div class="comment-header">
          <a name="comment-7743238805948786685"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-04 21:16</span>:
        </div>
        <div class="comment-content">
          <p>won't fix means we won't fix it ;-) To be precise it means we know this program is slow, but also there is a way to write this program to be fast, please use the other way.</p>
        </div>
      </div>
      <div class="comment comment-4405360531072260779">
        <div class="comment-header">
          <a name="comment-4405360531072260779"></a>
            <span class="author">Luis</span> wrote on <span class="date">2010-11-04 23:41</span>:
        </div>
        <div class="comment-content">
          <p>So it doesn't make much sense including these benchmarks in speed.pypy.org, don't you think?<br>Perhaps it should be described somewhere what are the strengths and weaknesses of this implementation, suggesting the right approach for each task. Something like "best practices" or something like that...</p>
        </div>
      </div>
      <div class="comment comment-6767848252444140373">
        <div class="comment-header">
          <a name="comment-6767848252444140373"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-05 07:36</span>:
        </div>
        <div class="comment-content">
          <p>I think deleting it from the nightly run doesn't make sense. It still measures something and helps us catch regressions.<br><br>The document you're proposing is actually a really neat idea. I've already did a couple of presentation on it, so it's only about gathering knowledge ("only").</p>
        </div>
      </div>
         </div>

</div>
</div>
<div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/12/toy-load-store.html" class="listtitle">Load and store forwarding in the Toy Optimizer</a>
      </li>
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (9)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (6)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div></div>
</main>
</div>
<div style="clear: both; width: 75%; margin: 1em auto;">
        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-17.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-15.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
         
                 <footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    Â© 2026 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
    Â 
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
    Â 
    Last built 2026-01-17T00:22
  </div>
  <div style="margin-left: auto">
  <a href="../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../assets/js/styles.js"></script></footer>
</body>
</html>