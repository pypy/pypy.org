<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="A Faster Python">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>PyPy (old posts, page 18) | PyPy</title>
<link href="../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../rss.xml">
<link rel="canonical" href="https://www.pypy.org/blog/index-18.html">
<link rel="icon" href="../favicon2.ico" sizes="16x16">
<link rel="icon" href="../favicon32x32.ico" sizes="32x32">
<link rel="prev" href="index-19.html" type="text/html">
<link rel="next" href="index-17.html" type="text/html">
<!--[if lt IE 9]><script src="../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../assets/css/tipuesearch.css">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../index.html">
                    <image id="toplogo" src="../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../compat.html">Compatibility</a> </li>  
                    <li> <a href="../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href=".">Index</a> </li>  
                    <li> <a href="../categories/">Tags</a> </li>  
                    <li> <a href="../archive.html">Archive by year</a> </li>  
                    <li> <a href="../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Searchâ€¦" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><div class="post">
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/04/using-tkinter-and-idle-with-pypy-6156563216925585965.html" class="u-url">Using Tkinter and IDLE with PyPy</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/antonio-cuni.html">Antonio Cuni</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/04/using-tkinter-and-idle-with-pypy-6156563216925585965.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-04-20T11:22:00Z" itemprop="datePublished" title="2011-04-20 11:22">2011-04-20 11:22</time></a>
            </p>
                <p class="commentline">13 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>We are pleased to announce that Tkinter, the GUI library based on TCL/TK, now
works with PyPy.<br>
Tkinter is composed of two parts:<br></p>
<blockquote>
<ul class="simple">
<li>
<tt class="docutils literal">_tkinter</tt>, a module written in C which interfaces with the TCL world</li>
<li>
<tt class="docutils literal">Tkinter</tt>, a pure Python package which wraps <tt class="docutils literal">_tkinter</tt> to expose the
pythonic API we are used to</li>
</ul>
</blockquote>
<div class="separator" style="clear: both; text-align: center;">
</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-MnwNRQAgGvU/Ta6zPmuA7MI/AAAAAAAAAMs/k1_boT54q-I/s1600/idle.png" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="264" src="https://4.bp.blogspot.com/-MnwNRQAgGvU/Ta6zPmuA7MI/AAAAAAAAAMs/k1_boT54q-I/s320/idle.png" width="320"></a>
</div>
The <a class="reference external" href="https://bitbucket.org/pypy/tkinter">PyPy version of _tkinter</a> reuses the C code of as found in CPython and
compile it through the PyPy C-API compatibility layer, <tt class="docutils literal">cpyext</tt>.  To make it
work with PyPy, we had to modify it slightly, in order to remove the
dependency on some API functions which are not supported by PyPy.  In particular, we
removed the dependency on the <tt class="docutils literal">PyOS_InputHook</tt> variable, which allows a nice
integration of Tkinter and the Python interactive prompt: the result is that,
unlike CPython, in PyPy Tk windows created at the interactive prompt are not
shown until we manually call the <tt class="docutils literal">mainloop</tt> method.  Apart from this
inconvenience, all the rest works fine.<br>
At the moment, <tt class="docutils literal">_tkinter</tt> is not distributed with PyPy because our build
system does not support automatic compilation of C extension.  Instead, it is
necessary to install it manually, either directly from <a class="reference external" href="https://bitbucket.org/pypy/tkinter">source</a> or by
easy_installing/pip installing <a class="reference external" href="https://pypi.python.org/pypi/tkinter-pypy/">tkinter-pypy</a> from PyPI.<br>
For everything to work correctly, you need a recent build of PyPy: the
following is a step-by-step guide to install <tt class="docutils literal">_tkinter</tt> in a PyPy nightly
build for Linux 64 bit; for other architectures, look at the <a class="reference external" href="https://buildbot.pypy.org/nightly/trunk/">nightly build
page</a>:<br><pre class="literal-block">$ wget https://buildbot.pypy.org/nightly/trunk/pypy-c-jit-43485-1615dfd7d8f1-linux64.tar.bz2

$ tar xfv pypy-c-jit-43485-1615dfd7d8f1-linux64.tar.bz2

$ cd pypy-c-jit-43485-1615dfd7d8f1-linux64/

$ wget https://peak.telecommunity.com/dist/ez_setup.py

$ ./bin/pypy ez_setup.py    # install setuptools

$ ./bin/easy_install tkinter-pypy
</pre>
Once you complete the steps above, you can start using <tt class="docutils literal">Tkinter</tt> from your
python programs.  In particular, you can use IDLE, the IDE which is part of
the Python standard library.  To start IDLE, type:<br><pre class="literal-block">$ ./bin/pypy -m idlelib.idle
</pre>
Have fun :-)
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-3304885392337132366">
        <div class="comment-header">
          <a name="comment-3304885392337132366"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-04-20 15:09</span>:
        </div>
        <div class="comment-content">
          <p>It is sooo ancient. I'd think twice before bundling anything potentially exploitable (read - compiled C modules) with PyPy.</p>
        </div>
      </div>
      <div class="comment comment-264499153784526218">
        <div class="comment-header">
          <a name="comment-264499153784526218"></a>
            <span class="author">RonnyPfannschmidt</span> wrote on <span class="date">2011-04-20 22:59</span>:
        </div>
        <div class="comment-content">
          <p>i fail to see how this is more exploitable than say ctypes (which is already shipped)</p>
        </div>
      </div>
      <div class="comment comment-5310458325429707473">
        <div class="comment-header">
          <a name="comment-5310458325429707473"></a>
            <span class="author">Brandon Corfman</span> wrote on <span class="date">2011-04-22 17:01</span>:
        </div>
        <div class="comment-content">
          <p>I'm really REALLY happy about this ... Tkinter, multiprocessing, and 2.7 support were my remaining roadblocks to using PyPy. I'm d/l now to give it a try with Raven Checkers. I hope that I won't need to look back.</p>
        </div>
      </div>
      <div class="comment comment-9041475672553038739">
        <div class="comment-header">
          <a name="comment-9041475672553038739"></a>
            <span class="author">Joaquin Abian</span> wrote on <span class="date">2011-05-13 20:41</span>:
        </div>
        <div class="comment-content">
          <p>I tried to install tkinter on win 7. When I do pypy ez_setup.py I get a traceback that finish with:<br><br>  File "ez_setup.py", line 212, in main<br>    from setuptools.command.easy_install import main<br>ZipImportError: 'setuptools.command.install'<br><br>Some hint on how to solve it?</p>
        </div>
      </div>
      <div class="comment comment-6578213749601320280">
        <div class="comment-header">
          <a name="comment-6578213749601320280"></a>
            <span class="author">Antonio Cuni</span> wrote on <span class="date">2011-05-18 15:13</span>:
        </div>
        <div class="comment-content">
          <p>@Joaquin:<br>indeed, ez_setup seems not to work on windows. It might be related to this, although I did not investigate further:<br>https://bugs.pypy.org/issue725<br><br>Instead of ez_setup, you can try to follow these instructions and install distribute/pip, which we recommend anyway nowadays:<br>https://doc.pypy.org/en/latest/getting-started.html#installing-pypy<br><br>Note however that tkinter-pypy is not precompiled for windows, so you need to have the necessary developer tools installed.  If you manage to build a precompiled binary of tkinter-pypy, I'd be happy to put it in pypi :-)</p>
        </div>
      </div>
      <div class="comment comment-5845624591340641323">
        <div class="comment-header">
          <a name="comment-5845624591340641323"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-11-24 16:52</span>:
        </div>
        <div class="comment-content">
          <p>Seems that tcl8.4-dev and tk8.4-dev needs to be installed!<br>This should be insert into the "install instruction" ;)</p>
        </div>
      </div>
      <div class="comment comment-7119717896785860198">
        <div class="comment-header">
          <a name="comment-7119717896785860198"></a>
            <span class="author">Daniel Petti</span> wrote on <span class="date">2012-05-29 19:01</span>:
        </div>
        <div class="comment-content">
          <p>What does "command 'cc' failed with error 1" mean? I keep getting that upon installing tkinter-pypy</p>
        </div>
      </div>
      <div class="comment comment-7200347303753871176">
        <div class="comment-header">
          <a name="comment-7200347303753871176"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2012-10-22 17:27</span>:
        </div>
        <div class="comment-content">
          <p>I'm unable to compile it on Windows (MinGW and also tried with VS 2010). Getting the following error:<br><br>fatal error: tcl.h: No such file or directory<br><br>My TCL installed under a different directory. How can I point the compiler to use tcl.h file from that directory?<br></p>
        </div>
      </div>
      <div class="comment comment-2697137645828666594">
        <div class="comment-header">
          <a name="comment-2697137645828666594"></a>
            <span class="author">Rich Wandell</span> wrote on <span class="date">2013-05-03 14:47</span>:
        </div>
        <div class="comment-content">
          <p>I am having an incredible amount of problems attempting to build tkinter for pypy on windows. Is there anywhere I can download a pre built version?</p>
        </div>
      </div>
      <div class="comment comment-4983756749478960401">
        <div class="comment-header">
          <a name="comment-4983756749478960401"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2013-10-28 18:14</span>:
        </div>
        <div class="comment-content">
          <p>This is outdated. But how to use Tkinter currently under windows?</p>
        </div>
      </div>
      <div class="comment comment-5089440210287212340">
        <div class="comment-header">
          <a name="comment-5089440210287212340"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2014-02-02 11:18</span>:
        </div>
        <div class="comment-content">
          <p>I think I've managed to compile Tkinter for Windows. Could anyone interested please try it out? Just download this archive and extract it into your Pypy folder:<br>https://dl-web.dropbox.com/get/Public/Tkinter%20for%20Windows.zip?_subject_uid=29914669&amp;w=AACPaRHDWsfcxafgdXsHV405wJNIsKrYzRXZMHwIKPuiNA&amp;dl=1</p>
        </div>
      </div>
      <div class="comment comment-6206951068433637031">
        <div class="comment-header">
          <a name="comment-6206951068433637031"></a>
            <span class="author">Luis</span> wrote on <span class="date">2014-05-11 22:35</span>:
        </div>
        <div class="comment-content">
          <p>XJDHDR: The link is not working. Do you still have the file available to download?</p>
        </div>
      </div>
      <div class="comment comment-5679064089883478272">
        <div class="comment-header">
          <a name="comment-5679064089883478272"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2014-05-12 17:27</span>:
        </div>
        <div class="comment-content">
          <p>@Luis<br>The file is still available. Try this link:<br><a href="https://dl.dropboxusercontent.com/u/29914669/Tkinter%20for%20Windows.zip" rel="nofollow">https://dl.dropboxusercontent.com/u/29914669/Tkinter%20for%20Windows.zip</a><br><br>Dropbox must have changed something on their end.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/04/tutorial-part-2-adding-jit-8121732841568309472.html" class="u-url">Tutorial Part 2: Adding a JIT</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/04/tutorial-part-2-adding-jit-8121732841568309472.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-04-06T13:51:00Z" itemprop="datePublished" title="2011-04-06 13:51">2011-04-06 13:51</time></a>
            </p>
                <p class="commentline">10 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>This is the second part of a tutorial written by <a class="reference external" href="https://codespeak.net/pipermail/pypy-dev/2011q2/007128.html">Andrew Brown</a>. The first
part described how to <a class="reference external" href="../posts/2011/04/tutorial-writing-interpreter-with-pypy-3785910476193156295.html">write an interpreter with PyPy</a>.</p>
<div class="section" id="adding-jit">
<h2>Adding JIT</h2>
<p>Translating RPython to C is pretty cool, but one of the best features of PyPy
is its ability to <em>generate just-in-time compilers for your interpreter</em>.
That's right, from just a couple hints on how your interpreter is structured,
PyPy will generate and include a JIT compiler that will, at runtime, translate
the interpreted code of our BF language to machine code!</p>
<p>So what do we need to tell PyPy to make this happen? First it needs to know
where the start of your bytecode evaluation loop is. This lets it keep track of
instructions being executed in the target language (BF).</p>
<p>We also need to let it know what defines a particular execution frame. Since
our language doesn't really have stack frames, this boils down to what's
constant for the execution of a particular instruction, and what's not. These
are called "green" and "red" variables, respectively.</p>
<p>Refer back to <a class="reference external" href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example2.py">example2.py</a> for the following.</p>
<p>In our main loop, there are four variables used: pc, program, bracket_map, and
tape. Of those, pc, program, and bracket_map are all green variables. They
<em>define</em> the execution of a particular instruction. If the JIT routines see the
same combination of green variables as before, it knows it's skipped back and
must be executing a loop.  The variable "tape" is our red variable, it's what's
being manipulated by the execution.</p>
<p>So let's tell PyPy this info. Start by importing the JitDriver class and making
an instance:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">from</span> <span style="color: #00CCFF; font-weight: bold;">pypy.rlib.jit</span> <span style="color: #006699; font-weight: bold;">import</span> JitDriver
jitdriver <span style="color: #555555;">=</span> JitDriver(greens<span style="color: #555555;">=</span>[<span style="color: #CC3300;">'pc'</span>, <span style="color: #CC3300;">'program'</span>, <span style="color: #CC3300;">'bracket_map'</span>],
        reds<span style="color: #555555;">=</span>[<span style="color: #CC3300;">'tape'</span>])
</pre></div>
<p>And we add this line to the very top of the while loop in the mainloop
function:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;">jitdriver<span style="color: #555555;">.</span>jit_merge_point(pc<span style="color: #555555;">=</span>pc, tape<span style="color: #555555;">=</span>tape, program<span style="color: #555555;">=</span>program,
        bracket_map<span style="color: #555555;">=</span>bracket_map)
</pre></div>
<p>We also need to define a JitPolicy. We're not doing anything fancy, so this is
all we need somewhere in the file:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">jitpolicy</span>(driver):
    <span style="color: #006699; font-weight: bold;">from</span> <span style="color: #00CCFF; font-weight: bold;">pypy.jit.codewriter.policy</span> <span style="color: #006699; font-weight: bold;">import</span> JitPolicy
    <span style="color: #006699; font-weight: bold;">return</span> JitPolicy()
</pre></div>
<p>See this example at <a class="reference external" href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example3.py">example3.py</a></p>
<p>Now try translating again, but with the flag <tt class="docutils literal"><span class="pre">--opt=jit</span></tt>:</p>
<pre class="literal-block">
$ python ./pypy/pypy/translator/goal/translate.py --opt=jit example3.py
</pre>
<p>It will take significantly longer to translate with JIT enabled, almost 8
minutes on my machine, and the resulting binary will be much larger. When it's
done, try having it run the mandelbrot program again. A world of difference,
from 12 seconds compared to 45 seconds before!</p>
<p>Interestingly enough, you can see when the JIT compiler switches from
interpreted to machine code with the mandelbrot example. The first few lines of
output come out pretty fast, and then the program gets a boost of speed and
gets even faster.</p>
</div>
<div class="section" id="a-bit-about-tracing-jit-compilers">
<h2>A bit about Tracing JIT Compilers</h2>
<p>It's worth it at this point to read up on how tracing JIT compilers work.
Here's a brief explanation: The interpreter is usually running your interpreter
code as written. When it detects a loop of code in the target language (BF) is
executed often, that loop is considered "hot" and marked to be traced. The next
time that loop is entered, the interpreter gets put in tracing mode where every
executed instruction is logged.</p>
<p>When the loop is finished, tracing stops. The trace of the loop is sent to an
optimizer, and then to an assembler which outputs machine code. That machine
code is then used for subsequent loop iterations.</p>
<p>This machine code is often optimized for the most common case, and depends on
several assumptions about the code. Therefore, the machine code will contain
guards, to validate those assumptions. If a guard check fails, the runtime
falls back to regular interpreted mode.</p>
<p>A good place to start for more information is
<a class="reference external" href="https://en.wikipedia.org/wiki/Just-in-time_compilation">https://en.wikipedia.org/wiki/Just-in-time_compilation</a></p>
</div>
<div class="section" id="debugging-and-trace-logs">
<h2>Debugging and Trace Logs</h2>
<p>Can we do any better? How can we see what the JIT is doing? Let's do two
things.</p>
<p>First, let's add a get_printable_location function, which is used during debug
trace logging:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">get_location</span>(pc, program, bracket_map):
    <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #CC3300;">"</span><span style="color: #AA0000;">%s</span><span style="color: #CC3300;">_</span><span style="color: #AA0000;">%s</span><span style="color: #CC3300;">_</span><span style="color: #AA0000;">%s</span><span style="color: #CC3300;">"</span> <span style="color: #555555;">%</span> (
            program[:pc], program[pc], program[pc<span style="color: #555555;">+</span><span style="color: #FF6600;">1</span>:]
            )
jitdriver <span style="color: #555555;">=</span> JitDriver(greens<span style="color: #555555;">=</span>[<span style="color: #CC3300;">'pc'</span>, <span style="color: #CC3300;">'program'</span>, <span style="color: #CC3300;">'bracket_map'</span>], reds<span style="color: #555555;">=</span>[<span style="color: #CC3300;">'tape'</span>],
        get_printable_location<span style="color: #555555;">=</span>get_location)
</pre></div>
<p>This function is passed in the green variables, and should return a string.
Here, we're printing out the BF code, surrounding the currently executing
instruction with underscores so we can see where it is.</p>
<p>Download this as <a class="reference external" href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example4.py">example4.py</a> and translate it the same as example3.py.</p>
<p>Now let's run a test program (test.b, which just prints the letter "A" 15 or so
times in a loop) with trace logging:</p>
<pre class="literal-block">
$ PYPYLOG=jit-log-opt:logfile ./example4-c test.b
</pre>
<p>Now take a look at the file "logfile". This file is quite hard to read, so
here's my best shot at explaining it.</p>
<p>The file contains a log of every trace that was performed, and is essentially a
glimpse at what instructions it's compiling to machine code for you. It's
useful to see if there are unnecessary instructions or room for optimization.</p>
<p>Each trace starts with a line that looks like this:</p>
<pre class="literal-block">
[3c091099e7a4a7] {jit-log-opt-loop
</pre>
<p>and ends with a line like this:</p>
<pre class="literal-block">
[3c091099eae17d jit-log-opt-loop}
</pre>
<p>The next line tells you which loop number it is, and how many ops are in it.
In my case, the first trace looks like this:</p>
<table class="highlighttable"><tr>
<td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td>
<td class="code">
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;">  [<span style="color: #FF6600;">3</span>c167c92b9118f] {jit<span style="color: #555555;">-</span>log<span style="color: #555555;">-</span>opt<span style="color: #555555;">-</span>loop
  <span style="color: #0099FF; font-style: italic;"># Loop 0 : loop with 26 ops</span>
  [p0, p1, i2, i3]
  debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[_&gt;_+&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
  debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[&gt;_+_&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
  i4 <span style="color: #555555;">=</span> getarrayitem_gc(p1, i2, descr<span style="color: #555555;">=&lt;</span>SignedArrayDescr<span style="color: #555555;">&gt;</span>)
  i6 <span style="color: #555555;">=</span> int_add(i4, <span style="color: #FF6600;">1</span>)
  setarrayitem_gc(p1, i2, i6, descr<span style="color: #555555;">=&lt;</span>SignedArrayDescr<span style="color: #555555;">&gt;</span>)
  debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[&gt;+_&lt;_-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
  debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[&gt;+&lt;_-_]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
  i7 <span style="color: #555555;">=</span> getarrayitem_gc(p1, i3, descr<span style="color: #555555;">=&lt;</span>SignedArrayDescr<span style="color: #555555;">&gt;</span>)
  i9 <span style="color: #555555;">=</span> int_sub(i7, <span style="color: #FF6600;">1</span>)
  setarrayitem_gc(p1, i3, i9, descr<span style="color: #555555;">=&lt;</span>SignedArrayDescr<span style="color: #555555;">&gt;</span>)
  debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[&gt;+&lt;-_]_&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
  i10 <span style="color: #555555;">=</span> int_is_true(i9)
  guard_true(i10, descr<span style="color: #555555;">=&lt;</span>Guard2<span style="color: #555555;">&gt;</span>) [p0]
  i14 <span style="color: #555555;">=</span> call(ConstClass(ll_dict_lookup__dicttablePtr_Signed_Signed), ConstPtr(ptr12), <span style="color: #FF6600;">90</span>, <span style="color: #FF6600;">90</span>, descr<span style="color: #555555;">=&lt;</span>SignedCallDescr<span style="color: #555555;">&gt;</span>)
  guard_no_exception(, descr<span style="color: #555555;">=&lt;</span>Guard3<span style="color: #555555;">&gt;</span>) [i14, p0]
  i16 <span style="color: #555555;">=</span> int_and(i14, <span style="color: #555555;">-</span><span style="color: #FF6600;">9223372036854775808</span>)
  i17 <span style="color: #555555;">=</span> int_is_true(i16)
  guard_false(i17, descr<span style="color: #555555;">=&lt;</span>Guard4<span style="color: #555555;">&gt;</span>) [i14, p0]
  i19 <span style="color: #555555;">=</span> call(ConstClass(ll_get_value__dicttablePtr_Signed), ConstPtr(ptr12), i14, descr<span style="color: #555555;">=&lt;</span>SignedCallDescr<span style="color: #555555;">&gt;</span>)
  guard_no_exception(, descr<span style="color: #555555;">=&lt;</span>Guard5<span style="color: #555555;">&gt;</span>) [i19, p0]
  i21 <span style="color: #555555;">=</span> int_add(i19, <span style="color: #FF6600;">1</span>)
  i23 <span style="color: #555555;">=</span> int_lt(i21, <span style="color: #FF6600;">114</span>)
  guard_true(i23, descr<span style="color: #555555;">=&lt;</span>Guard6<span style="color: #555555;">&gt;</span>) [i21, p0]
  guard_value(i21, <span style="color: #FF6600;">86</span>, descr<span style="color: #555555;">=&lt;</span>Guard7<span style="color: #555555;">&gt;</span>) [i21, p0]
  debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[_&gt;_+&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
  jump(p0, p1, i2, i3, descr<span style="color: #555555;">=&lt;</span>Loop0<span style="color: #555555;">&gt;</span>)
  [<span style="color: #FF6600;">3</span>c167c92bc6a15] jit<span style="color: #555555;">-</span>log<span style="color: #555555;">-</span>opt<span style="color: #555555;">-</span>loop}
</pre></div>
</td>
</tr></table>
<p>I've trimmed the debug_merge_point lines a bit, they were really long.</p>
<p>So let's see what this does. This trace takes 4 parameters: 2 object pointers
(p0 and p1) and 2 integers (i2 and i3). Looking at the debug lines, it seems to
be tracing one iteration of this loop: "[&gt;+&lt;-]"</p>
<p>It starts executing the first operation on line 4, a "&gt;", but immediately
starts executing the next operation. The "&gt;" had no instructions, and looks
like it was optimized out completely.  This loop must always act on the same
part of the tape, the tape pointer is constant for this trace. An explicit
advance operation is unnecessary.</p>
<p>Lines 5 to 8 are the instructions for the "+" operation. First it gets the
array item from the array in pointer p1 at index i2 (line 6), adds 1 to it and
stores it in i6 (line 7), and stores it back in the array (line 8).</p>
<p>Line 9 starts the "&lt;" instruction, but it is another no-op. It seems that i2
and i3 passed into this routine are the two tape pointers used in this loop
already calculated. Also deduced is that p1 is the tape array. It's not clear
what p0 is.</p>
<p>Lines 10 through 13 perform the "-" operation: get the array value (line 11),
subtract (line 12) and set the array value (line 13).</p>
<p>Next, on line 14, we come to the "]" operation. Lines 15 and 16 check whether
i9 is true (non-zero). Looking up, i9 is the array value that we just
decremented and stored, now being checked as the loop condition, as expected
(remember the definition of "]").  Line 16 is a guard, if the condition is not
met, execution jumps somewhere else, in this case to the routine called
&lt;Guard2&gt; and is passed one parameter: p0.</p>
<p>Assuming we pass the guard, lines 17 through 23 are doing the dictionary lookup
to bracket_map to find where the program counter should jump to.  I'm not too
familiar with what the instructions are actually doing, but it looks like there
are two external calls and 3 guards. This seems quite expensive, especially
since we know bracket_map will never change (PyPy doesn't know that).  We'll
see below how to optimize this.</p>
<p>Line 24 increments the newly acquired instruction pointer. Lines 25 and 26 make
sure it's less than the program's length.</p>
<p>Additionally, line 27 guards that i21, the incremented instruction pointer, is
exactly 86. This is because it's about to jump to the beginning (line 29) and
the instruction pointer being 86 is a precondition to this block.</p>
<p>Finally, the loop closes up at line 28 so the JIT can jump to loop body &lt;Loop0&gt;
to handle that case (line 29), which is the beginning of the loop again. It
passes in parameters (p0, p1, i2, i3).</p>
</div>
<div class="section" id="optimizing">
<h2>Optimizing</h2>
<p>As mentioned, every loop iteration does a dictionary lookup to find the
corresponding matching bracket for the final jump. This is terribly
inefficient, the jump target is not going to change from one loop to the next.
This information is constant and should be compiled in as such.</p>
<p>The problem is that the lookups are coming from a dictionary, and PyPy is
treating it as opaque. It doesn't know the dictionary isn't being modified or
isn't going to return something different on each query.</p>
<p>What we need to do is provide another hint to the translation to say that the
dictionary query is a pure function, that is, its output depends <em>only</em> on its
inputs and the same inputs should always return the same output.</p>
<p>To do this, we use a provided function decorator pypy.rlib.jit.purefunction,
and wrap the dictionary call in a decorated function:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #9999FF;">@purefunction</span>
<span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">get_matching_bracket</span>(bracket_map, pc):
    <span style="color: #006699; font-weight: bold;">return</span> bracket_map[pc]
</pre></div>
<p>This version can be found at <a class="reference external" href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example5.py">example5.py</a></p>
<p>Translate again with the JIT option and observe the speedup. Mandelbrot now
only takes 6 seconds!  (from 12 seconds before this optimization)</p>
<p>Let's take a look at the trace from the same function:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;">[<span style="color: #FF6600;">3</span>c29fad7b792b0] {jit<span style="color: #555555;">-</span>log<span style="color: #555555;">-</span>opt<span style="color: #555555;">-</span>loop
<span style="color: #0099FF; font-style: italic;"># Loop 0 : loop with 15 ops</span>
[p0, p1, i2, i3]
debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[_&gt;_+&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[&gt;_+_&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
i4 <span style="color: #555555;">=</span> getarrayitem_gc(p1, i2, descr<span style="color: #555555;">=&lt;</span>SignedArrayDescr<span style="color: #555555;">&gt;</span>)
i6 <span style="color: #555555;">=</span> int_add(i4, <span style="color: #FF6600;">1</span>)
setarrayitem_gc(p1, i2, i6, descr<span style="color: #555555;">=&lt;</span>SignedArrayDescr<span style="color: #555555;">&gt;</span>)
debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[&gt;+_&lt;_-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[&gt;+&lt;_-_]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
i7 <span style="color: #555555;">=</span> getarrayitem_gc(p1, i3, descr<span style="color: #555555;">=&lt;</span>SignedArrayDescr<span style="color: #555555;">&gt;</span>)
i9 <span style="color: #555555;">=</span> int_sub(i7, <span style="color: #FF6600;">1</span>)
setarrayitem_gc(p1, i3, i9, descr<span style="color: #555555;">=&lt;</span>SignedArrayDescr<span style="color: #555555;">&gt;</span>)
debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[&gt;+&lt;-_]_&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
i10 <span style="color: #555555;">=</span> int_is_true(i9)
guard_true(i10, descr<span style="color: #555555;">=&lt;</span>Guard2<span style="color: #555555;">&gt;</span>) [p0]
debug_merge_point(<span style="color: #CC3300;">'+&lt;[&gt;[_&gt;_+&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.'</span>, <span style="color: #FF6600;">0</span>)
jump(p0, p1, i2, i3, descr<span style="color: #555555;">=&lt;</span>Loop0<span style="color: #555555;">&gt;</span>)
[<span style="color: #FF6600;">3</span>c29fad7ba32ec] jit<span style="color: #555555;">-</span>log<span style="color: #555555;">-</span>opt<span style="color: #555555;">-</span>loop}
</pre></div>
<p>Much better! Each loop iteration is an add, a subtract, two array loads, two
array stores, and a guard on the exit condition. That's it! This code doesn't
require <em>any</em> program counter manipulation.</p>
<p>I'm no expert on optimizations, this tip was suggested by Armin Rigo on the
pypy-dev list. Carl Friedrich has a series of posts on how to optimize your
interpreter that are also very useful: <a class="reference external" href="https://bit.ly/bundles/cfbolz/1">https://bit.ly/bundles/cfbolz/1</a></p>
</div>
<div class="section" id="final-words">
<h2>Final Words</h2>
<p>I hope this has shown some of you what PyPy is all about other than a faster
implementation of Python.</p>
<p>For those that would like to know more about how the process works, there are
several academic papers explaining the process in detail that I recommend. In
particular: Tracing the Meta-Level: PyPy's Tracing JIT Compiler.</p>
<p>See <a class="reference external" href="https://readthedocs.org/docs/pypy/en/latest/extradoc.html">https://readthedocs.org/docs/pypy/en/latest/extradoc.html</a></p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-6085380460859434897">
        <div class="comment-header">
          <a name="comment-6085380460859434897"></a>
            <span class="author">Winston Ewert</span> wrote on <span class="date">2011-04-06 21:59</span>:
        </div>
        <div class="comment-content">
          <p>Some interpreters are written to evaluate directly from the AST. i.e. they never generate bytecode, instead each node in the ast simply has the code to execute it as a "virtual" function. Could PyPy JIT such an interpreter? Or does it essentially assume a bytecode based interpreter?</p>
        </div>
      </div>
      <div class="comment comment-1902484944946012766">
        <div class="comment-header">
          <a name="comment-1902484944946012766"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-04-07 05:56</span>:
        </div>
        <div class="comment-content">
          <p>In theory it should be able to, if it's written in RPython. Perhaps it would be harder to place the hints for the jit engine?<br><br>As far as I understand it, it still traces some kind of bytecode (generated from the RPython code), but uses the can_enter_jit hints to determine what to trace and the length of a trace.<br><br>If it'll be fast is another question though. Why not give it a try? (E.g. one could implement the LLVM kaleidoscope language in RPython.)</p>
        </div>
      </div>
      <div class="comment comment-8500050776770522416">
        <div class="comment-header">
          <a name="comment-8500050776770522416"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-04-07 06:05</span>:
        </div>
        <div class="comment-content">
          <p>@Winston in theory nothing prevents JIT from working on AST-based interpreters. In practice however, it would require a bit of engineering to convince the JIT that the green (constant) argument is a complex object structure. That's however just engineering</p>
        </div>
      </div>
      <div class="comment comment-5452355239319367469">
        <div class="comment-header">
          <a name="comment-5452355239319367469"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-04-07 09:24</span>:
        </div>
        <div class="comment-content">
          <p>It's actually not a problem at all to have an AST-based interpreter. In fact, the Prolog uses "ASTs" (Prolog is homoiconic, so the ASTs are just Prologs normal data structures).<br><br>Maciej: that's not a problem if your ASTs are actually immutable. If they aren't you have a problem which indeed requires some engineering.</p>
        </div>
      </div>
      <div class="comment comment-6194582595663977823">
        <div class="comment-header">
          <a name="comment-6194582595663977823"></a>
            <span class="author">Quiz</span> wrote on <span class="date">2011-04-07 10:45</span>:
        </div>
        <div class="comment-content">
          <p>The effect of the loop "[&gt;+&lt;-]" is <br><br>tape[position+1] += tape[position]<br>tape[position] = 0<br><br>We saw that PyPy can optimize the program counter away in this loop--but this loop could be executed in constant time. Will PyPy ever be able to optimize it to that degree?</p>
        </div>
      </div>
      <div class="comment comment-4017602435873791161">
        <div class="comment-header">
          <a name="comment-4017602435873791161"></a>
            <span class="author">Winston Ewert</span> wrote on <span class="date">2011-04-10 01:53</span>:
        </div>
        <div class="comment-content">
          <p>Well, you finally motivated me to give it a try. I optimized the BF example and managed to get some pretty nice speed boosts all without dipping into the low level (aside from reading the log)</p>
        </div>
      </div>
      <div class="comment comment-4240220600091975575">
        <div class="comment-header">
          <a name="comment-4240220600091975575"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-04-13 09:50</span>:
        </div>
        <div class="comment-content">
          <p>Great article, man! Many thanks and keep on rocking!</p>
        </div>
      </div>
      <div class="comment comment-2274397798855994473">
        <div class="comment-header">
          <a name="comment-2274397798855994473"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-08-07 08:47</span>:
        </div>
        <div class="comment-content">
          <p>Great tutorial, but where can I find the 'test.b' file (mentioned for the tracing JIT) for a try?</p>
        </div>
      </div>
      <div class="comment comment-5488699696338796997">
        <div class="comment-header">
          <a name="comment-5488699696338796997"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2012-11-22 10:50</span>:
        </div>
        <div class="comment-content">
          <p>hi guys.  can jit merge points not be put inside methods?  Going off example3.py, if I take the body of the while loop and move it into a method of the Tape class (along with the jitdriver), all the speed gains go away.  can anyone explain why this happens?  Thanks!</p>
        </div>
      </div>
      <div class="comment comment-4631403739625499910">
        <div class="comment-header">
          <a name="comment-4631403739625499910"></a>
            <span class="author">Sarah Mount</span> wrote on <span class="date">2016-07-30 23:12</span>:
        </div>
        <div class="comment-content">
          <p>BTW the link to https://bit.ly/bundles/cfbolz/1 has bit-rotted.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/04/tutorial-writing-interpreter-with-pypy-3785910476193156295.html" class="u-url">Tutorial: Writing an Interpreter with PyPy, Part 1</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/04/tutorial-writing-interpreter-with-pypy-3785910476193156295.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-04-05T13:44:00Z" itemprop="datePublished" title="2011-04-05 13:44">2011-04-05 13:44</time></a>
            </p>
                <p class="commentline">15 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>This is a guest blog post <a href="https://codespeak.net/pipermail/pypy-dev/2011q2/007128.html">written by Andrew Brown</a>, with help from the PyPy developers
on the pypy-dev mailing list.</p>
<p>This tutorial's master copy and supporting files live at
<a class="reference external" href="https://bitbucket.org/brownan/pypy-tutorial/">https://bitbucket.org/brownan/pypy-tutorial/</a></p>
<hr>
<p>When I first learned about the PyPy project, it took me a while to figure out
exactly what it was about. For those that don't already know, it's two things:</p>
<ul class="simple">
<li>A set of tools for implementing interpreters for interpreted languages</li>
<li>An implementation of Python using this toolchain</li>
</ul>
<p>The second part is probably what most people think PyPy is, but this tutorial
is <em>not</em> about their Python interpreter.  It is about writing your own
interpreter for your own language.</p>
<p>This is the project I undertook to help myself better understand how PyPy works
and what it's all about.</p>
<p>This tutorial assumes you know very little about PyPy, how it works, and even
what it's all about. I'm starting from the very beginning here.</p>
<div class="section" id="what-pypy-does">
<h2>What PyPy Does</h2>
<p>Here's a brief overview of what PyPy can do. Let's say you want to write an
interpreted language. This involves writing some kind of source code parser, a
bytecode interpretation loop, and lots of standard library code.</p>
<p>That's quite a bit of work for moderately complicated languages, and there's a
lot of low level work involved. Writing the parser and compiler code usually
isn't fun, that's why there are tools out there to generate parsers and
compilers for you.</p>
<p>Even then, you still must worry about memory management in your interpreter,
and you're going to be re-implementing a lot if you want data types like
arbitrary precision integers, nice general hash tables, and such. It's enough
to put someone off from implementing their idea for a language.</p>
<p>Wouldn't it be nice if you could write your language in an existing high level
language like, for example, Python? That sure would be ideal, you'd get all the
advantages of a high level language like automatic memory management and rich
data types at your disposal.  Oh, but an interpreted language interpreting
another language would be slow, right? That's twice as much interpreting going
on.</p>
<p>As you may have guessed, PyPy solves this problem. PyPy is a sophisticated
toolchain for analyzing and translating your interpreter code to C code (or JVM
or CLI). This process is called "translation", and it knows how to translate
quite a lot of Python's syntax and standard libraries, but not everything. All
you have to do is write your interpreter in <strong>RPython</strong>, a subset of the Python
language carefully defined to allow this kind of analysis and translation, and
PyPy will produce for you a very efficient interpreter.</p>
<p>Because efficient interpreters should not be hard to write.</p>
</div>
<div class="section" id="the-language">
<h2>The Language</h2>
<p>The language I've chosen to implement is dead simple. The language runtime
consists of a tape of integers, all initialized to zero, and a single pointer
to one of the tape's cells. The language has 8 commands, described here:</p>
<dl class="docutils">
<dt>&gt;</dt>
<dd>Moves the tape pointer one cell to the right</dd>
</dl>
<dl class="docutils">
<dt>&lt;</dt>
<dd>Moves the tape pointer one cell to the left</dd>
<dt>+</dt>
<dd>Increments the value of the cell underneath the pointer</dd>
<dt>-</dt>
<dd>Decrements the value of the cell underneath the pointer</dd>
</dl>
<dl class="docutils">
<dt>[</dt>
<dd>If the cell under the current pointer is 0, skip to the instruction after
the matching ]</dd>
</dl>
<dl class="docutils">
<dt>]</dt>
<dd>Skip back to the matching [ (evaluating its condition)</dd>
</dl>
<dl class="docutils">
<dt>.</dt>
<dd>Print out a single byte to stdout from the cell under the pointer</dd>
</dl>
<dl class="docutils">
<dt>,</dt>
<dd>Read in a single byte from stdin to the cell under the pointer</dd>
</dl>
<p>Any unrecognized bytes are ignored.</p>
<p>Some of you may recognize this language. I will be referring to it as BF.</p>
<p>One thing to notice is that the language is its own bytecode; there is no
translation from source code to bytecode. This means that the language can be
interpreted directly: the main eval loop of our interpreter will operate right
on the source code. This simplifies the implementation quite a bit.</p>
</div>
<div class="section" id="first-steps">
<h2>First Steps</h2>
<p>Let's start out by writing a BF interpreter in plain old Python. The first step
is sketching out an eval loop:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">mainloop</span>(program):
    tape <span style="color: #555555;">=</span> Tape()
    pc <span style="color: #555555;">=</span> <span style="color: #FF6600;">0</span>
    <span style="color: #006699; font-weight: bold;">while</span> pc <span style="color: #555555;">&lt;</span> <span style="color: #336666;">len</span>(program):
        code <span style="color: #555555;">=</span> program[pc]

        <span style="color: #006699; font-weight: bold;">if</span> code <span style="color: #555555;">==</span> <span style="color: #CC3300;">"&gt;"</span>:
            tape<span style="color: #555555;">.</span>advance()
        <span style="color: #006699; font-weight: bold;">elif</span> code <span style="color: #555555;">==</span> <span style="color: #CC3300;">"&lt;"</span>:
            tape<span style="color: #555555;">.</span>devance()
        <span style="color: #006699; font-weight: bold;">elif</span> code <span style="color: #555555;">==</span> <span style="color: #CC3300;">"+"</span>:
            tape<span style="color: #555555;">.</span>inc()
        <span style="color: #006699; font-weight: bold;">elif</span> code <span style="color: #555555;">==</span> <span style="color: #CC3300;">"-"</span>:
            tape<span style="color: #555555;">.</span>dec()
        <span style="color: #006699; font-weight: bold;">elif</span> code <span style="color: #555555;">==</span> <span style="color: #CC3300;">"."</span>:
            sys<span style="color: #555555;">.</span>stdout<span style="color: #555555;">.</span>write(<span style="color: #336666;">chr</span>(tape<span style="color: #555555;">.</span>get()))
        <span style="color: #006699; font-weight: bold;">elif</span> code <span style="color: #555555;">==</span> <span style="color: #CC3300;">","</span>:
            tape<span style="color: #555555;">.</span>set(<span style="color: #336666;">ord</span>(sys<span style="color: #555555;">.</span>stdin<span style="color: #555555;">.</span>read(<span style="color: #FF6600;">1</span>)))
        <span style="color: #006699; font-weight: bold;">elif</span> code <span style="color: #555555;">==</span> <span style="color: #CC3300;">"["</span> <span style="color: #000000; font-weight: bold;">and</span> value() <span style="color: #555555;">==</span> <span style="color: #FF6600;">0</span>:
            <span style="color: #0099FF; font-style: italic;"># Skip forward to the matching ]</span>
        <span style="color: #006699; font-weight: bold;">elif</span> code <span style="color: #555555;">==</span> <span style="color: #CC3300;">"]"</span> <span style="color: #000000; font-weight: bold;">and</span> value() <span style="color: #555555;">!=</span> <span style="color: #FF6600;">0</span>:
            <span style="color: #0099FF; font-style: italic;"># Skip back to the matching [</span>

        pc <span style="color: #555555;">+=</span> <span style="color: #FF6600;">1</span>
</pre></div>
<p>As you can see, a program counter (pc) holds the current instruction index. The
first statement in the loop gets the instruction to execute, and then a
compound if statement decides how to execute that instruction.</p>
<p>The implementation of [ and ] are left out here, but they should change the
program counter to the value of the matching bracket. (The pc then gets
incremented, so the condition is evaluated once when entering a loop, and once
at the end of each iteration)</p>
<p>Here's the implementation of the Tape class, which holds the tape's values as
well as the tape pointer:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Tape</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>thetape <span style="color: #555555;">=</span> [<span style="color: #FF6600;">0</span>]
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>position <span style="color: #555555;">=</span> <span style="color: #FF6600;">0</span>

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">get</span>(<span style="color: #336666;">self</span>):
        <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>thetape[<span style="color: #336666;">self</span><span style="color: #555555;">.</span>position]
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">set</span>(<span style="color: #336666;">self</span>, val):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>thetape[<span style="color: #336666;">self</span><span style="color: #555555;">.</span>position] <span style="color: #555555;">=</span> val
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">inc</span>(<span style="color: #336666;">self</span>):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>thetape[<span style="color: #336666;">self</span><span style="color: #555555;">.</span>position] <span style="color: #555555;">+=</span> <span style="color: #FF6600;">1</span>
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">dec</span>(<span style="color: #336666;">self</span>):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>thetape[<span style="color: #336666;">self</span><span style="color: #555555;">.</span>position] <span style="color: #555555;">-=</span> <span style="color: #FF6600;">1</span>
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">advance</span>(<span style="color: #336666;">self</span>):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>position <span style="color: #555555;">+=</span> <span style="color: #FF6600;">1</span>
        <span style="color: #006699; font-weight: bold;">if</span> <span style="color: #336666;">len</span>(<span style="color: #336666;">self</span><span style="color: #555555;">.</span>thetape) <span style="color: #555555;">&lt;=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>position:
            <span style="color: #336666;">self</span><span style="color: #555555;">.</span>thetape<span style="color: #555555;">.</span>append(<span style="color: #FF6600;">0</span>)
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">devance</span>(<span style="color: #336666;">self</span>):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>position <span style="color: #555555;">-=</span> <span style="color: #FF6600;">1</span>
</pre></div>
<p>As you can see, the tape expands as needed to the right, indefinitely. We
should really add some error checking to make sure the pointer doesn't go
negative, but I'm not worrying about that now.</p>
<p>Except for the omission of the "[" and "]" implementation, this code will work
fine.  However, if the program has a lot of comments, it will have to skip over
them one byte at a time at runtime. So let's parse those out once and for all.</p>
<p>At the same time, we'll build a dictionary mapping between brackets, so that
finding a matching bracket is just a single dictionary lookup. Here's how:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">parse</span>(program):
    parsed <span style="color: #555555;">=</span> []
    bracket_map <span style="color: #555555;">=</span> {}
    leftstack <span style="color: #555555;">=</span> []

    pc <span style="color: #555555;">=</span> <span style="color: #FF6600;">0</span>
    <span style="color: #006699; font-weight: bold;">for</span> char <span style="color: #000000; font-weight: bold;">in</span> program:
        <span style="color: #006699; font-weight: bold;">if</span> char <span style="color: #000000; font-weight: bold;">in</span> (<span style="color: #CC3300;">'['</span>, <span style="color: #CC3300;">']'</span>, <span style="color: #CC3300;">'&lt;'</span>, <span style="color: #CC3300;">'&gt;'</span>, <span style="color: #CC3300;">'+'</span>, <span style="color: #CC3300;">'-'</span>, <span style="color: #CC3300;">','</span>, <span style="color: #CC3300;">'.'</span>):
            parsed<span style="color: #555555;">.</span>append(char)

            <span style="color: #006699; font-weight: bold;">if</span> char <span style="color: #555555;">==</span> <span style="color: #CC3300;">'['</span>:
                leftstack<span style="color: #555555;">.</span>append(pc)
            <span style="color: #006699; font-weight: bold;">elif</span> char <span style="color: #555555;">==</span> <span style="color: #CC3300;">']'</span>:
                left <span style="color: #555555;">=</span> leftstack<span style="color: #555555;">.</span>pop()
                right <span style="color: #555555;">=</span> pc
                bracket_map[left] <span style="color: #555555;">=</span> right
                bracket_map[right] <span style="color: #555555;">=</span> left
            pc <span style="color: #555555;">+=</span> <span style="color: #FF6600;">1</span>

    <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #CC3300;">""</span><span style="color: #555555;">.</span>join(parsed), bracket_map
</pre></div>
<p>This returns a string with all invalid instructions removed, and a dictionary
mapping bracket indexes to their matching bracket index.</p>
<p>All we need is some glue code and we have a working BF interpreter:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">run</span>(<span style="color: #336666;">input</span>):
    program, <span style="color: #336666;">map</span> <span style="color: #555555;">=</span> parse(<span style="color: #336666;">input</span><span style="color: #555555;">.</span>read())
    mainloop(program, <span style="color: #336666;">map</span>)

<span style="color: #006699; font-weight: bold;">if</span> __name__ <span style="color: #555555;">==</span> <span style="color: #CC3300;">"__main__"</span>:
    <span style="color: #006699; font-weight: bold;">import</span> <span style="color: #00CCFF; font-weight: bold;">sys</span>
    run(<span style="color: #336666;">open</span>(sys<span style="color: #555555;">.</span>argv[<span style="color: #FF6600;">1</span>], <span style="color: #CC3300;">'r'</span>))
</pre></div>
<p>If you're following along at home, you'll also need to change the signature of
mainloop() and implement the bracket branches of the if statement. Here's the
complete example: <a class="reference external" href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example1.py">example1.py</a></p>
<p>At this point you can try it out to see that it works by running the
interpreter under python, but be warned, it will be <em>very</em> slow on the more
complex examples:</p>
<pre class="literal-block">
$ python example1.py 99bottles.b
</pre>
<p>You can find mandel.b and several other example programs (not written by me) in
my repository.</p>
</div>
<div class="section" id="pypy-translation">
<h2>PyPy Translation</h2>
<p>But this is not about writing a BF interpreter, this is about PyPy. So what
does it take to get PyPy to translate this into a super-fast executable?</p>
<p>As a side note, there are some simple examples in the pypy/translator/goal
directory of the PyPy source tree that are helpful here. My starting point for
learning this was the example "targetnopstandalone.py", a simple hello world
for PyPy.</p>
<p>For our example, the module must define a name called "target" which returns the
entry point. The translation process imports your module and looks for that
name, calls it, and the function object returned is where it starts the
translation.</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">run</span>(fp):
    program_contents <span style="color: #555555;">=</span> <span style="color: #CC3300;">""</span>
    <span style="color: #006699; font-weight: bold;">while</span> <span style="color: #336666;">True</span>:
        read <span style="color: #555555;">=</span> os<span style="color: #555555;">.</span>read(fp, <span style="color: #FF6600;">4096</span>)
        <span style="color: #006699; font-weight: bold;">if</span> <span style="color: #336666;">len</span>(read) <span style="color: #555555;">==</span> <span style="color: #FF6600;">0</span>:
            <span style="color: #006699; font-weight: bold;">break</span>
        program_contents <span style="color: #555555;">+=</span> read
    os<span style="color: #555555;">.</span>close(fp)
    program, bm <span style="color: #555555;">=</span> parse(program_contents)
    mainloop(program, bm)

<span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">entry_point</span>(argv):
    <span style="color: #006699; font-weight: bold;">try</span>:
        filename <span style="color: #555555;">=</span> argv[<span style="color: #FF6600;">1</span>]
    <span style="color: #006699; font-weight: bold;">except</span> <span style="color: #CC0000; font-weight: bold;">IndexError</span>:
        <span style="color: #006699; font-weight: bold;">print</span> <span style="color: #CC3300;">"You must supply a filename"</span>
        <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #FF6600;">1</span>

    run(os<span style="color: #555555;">.</span>open(filename, os<span style="color: #555555;">.</span>O_RDONLY, <span style="color: #FF6600;">0777</span>))
    <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #FF6600;">0</span>

<span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">target</span>(<span style="color: #555555;">*</span>args):
    <span style="color: #006699; font-weight: bold;">return</span> entry_point, <span style="color: #336666;">None</span>

<span style="color: #006699; font-weight: bold;">if</span> __name__ <span style="color: #555555;">==</span> <span style="color: #CC3300;">"__main__"</span>:
    entry_point(sys<span style="color: #555555;">.</span>argv)
</pre></div>
<p>The entry_point function is passed the command line arguments when you run the
resulting executable.</p>
<p>A few other things have changed here too. See the next section...</p>
</div>
<div class="section" id="about-rpython">
<h2>About RPython</h2>
<p>Let's talk a bit about RPython at this point. PyPy can't translate arbitrary
Python code because Python is a bit too dynamic. There are restrictions on what
standard library functions and what syntax constructs one can use. I won't be
going over all the restrictions, but for more information see
<a class="reference external" href="https://readthedocs.org/docs/pypy/en/latest/coding-guide.html#restricted-python">https://readthedocs.org/docs/pypy/en/latest/coding-guide.html#restricted-python</a></p>
<p>In the example above, you'll see a few things have changed.  I'm now using low
level file descriptors with os.open and os.read instead of file objects.
The implementation of "." and "," are similarly tweaked (not shown above).
Those are the only changes to make to this code, the rest is simple enough for
PyPy to digest.</p>
<p>That wasn't so hard, was it? I still get to use dictionaries, expandable lists,
and even classes and objects! And if low level file descriptors are too low for
you, there are some helpful abstractions in the rlib.streamio module included
with PyPy's "RPython standard library."</p>
<p>For the example thus far, see <a class="reference external" href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example2.py">example2.py</a></p>
</div>
<div class="section" id="translating">
<h2>Translating</h2>
<p>If you haven't already, check yourself out the latest version of PyPy from
their bitbucket.org repository:</p>
<pre class="literal-block">
$ hg clone https://bitbucket.org/pypy/pypy
</pre>
<p>(A recent revision is necessary because of a bugfix that makes my example
possible)</p>
<p>The script to run is in "pypy/translator/goal/translate.py". Run this script,
passing in our example module as an argument.</p>
<p><b><i>[A note added much later: this script has been moved to "rpython/bin/rpython".]</i></b></p>
<pre class="literal-block">
$ python ./pypy/pypy/translator/goal/translate.py example2.py
</pre>
<p>(You can use PyPy's python interpreter for extra speed, but it's not necessary)</p>
<p>PyPy will churn for a bit, drawing some nice looking fractals to your console
while it works. It takes around 20 seconds on my machine.</p>
<p>The result from this is an executable binary that interprets BF programs.
Included in my repository are some example BF programs, including a mandelbrot
fractal generator, which takes about 45 seconds to run on my computer. Try it
out:</p>
<pre class="literal-block">
$ ./example2-c mandel.b
</pre>
<p>Compare this to running the interpreter un-translated on top of python:</p>
<pre class="literal-block">
$ python example2.py mandel.b
</pre>
<p>Takes forever, doesn't it?</p>
<p>So there you have it. We've successfully written our own interpreter in RPython
and translated it with the PyPy toolchain.</p>
<hr>
<p>(more in the next blog post...)</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-1655999581131029809">
        <div class="comment-header">
          <a name="comment-1655999581131029809"></a>
            <span class="author">Dunk</span> wrote on <span class="date">2011-04-05 14:10</span>:
        </div>
        <div class="comment-content">
          <p>nice post!</p>
        </div>
      </div>
      <div class="comment comment-7110443337570363967">
        <div class="comment-header">
          <a name="comment-7110443337570363967"></a>
            <span class="author">DaNmarner</span> wrote on <span class="date">2011-04-05 16:35</span>:
        </div>
        <div class="comment-content">
          <p>Hmmmmmm, yum.<br><br>I'm going to translate this into Chinese, if you don't mind?</p>
        </div>
      </div>
      <div class="comment comment-386734010605518570">
        <div class="comment-header">
          <a name="comment-386734010605518570"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-04-05 16:56</span>:
        </div>
        <div class="comment-content">
          <p>"devance"? I think you meant "retract".</p>
        </div>
      </div>
      <div class="comment comment-6846797576851428869">
        <div class="comment-header">
          <a name="comment-6846797576851428869"></a>
            <span class="author">Paul Smith</span> wrote on <span class="date">2011-04-06 04:09</span>:
        </div>
        <div class="comment-content">
          <p>On my Ubuntu 10.10 laptop, the PyPy BF interpreter ran hanoi in ~20 sec and mandel in ~40 sec. By comparison, the beef BF interpreter (written in C) ran these in ~10 and ~20 sec., respectively. Not too shabby, PyPy.</p>
        </div>
      </div>
      <div class="comment comment-1013638857021386597">
        <div class="comment-header">
          <a name="comment-1013638857021386597"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-04-06 10:22</span>:
        </div>
        <div class="comment-content">
          <p>Nice article though I'm really missing a simple benchmark between the python interpreter and the pypy interpreter. "Takes forever" vs "45 seconds" isn't as awesome of a conclusion as I'd hoped for.</p>
        </div>
      </div>
      <div class="comment comment-4239135028386300775">
        <div class="comment-header">
          <a name="comment-4239135028386300775"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-04-06 14:52</span>:
        </div>
        <div class="comment-content">
          <p>@temptemptemp13: I think you are missing something much more substantial. This article is not about Python at all. It is about how to use the PyPy toolchain to implement a different language - in this case the brainfuck programming language.<br><br>While BF isn't a very useful language, it has the nice properties of being very small. Almost all of the language fits in a blog post.</p>
        </div>
      </div>
      <div class="comment comment-1971667908316437874">
        <div class="comment-header">
          <a name="comment-1971667908316437874"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-04-08 10:32</span>:
        </div>
        <div class="comment-content">
          <p>Thanks. I've finally understood what PyPy is.</p>
        </div>
      </div>
      <div class="comment comment-3863676909683312150">
        <div class="comment-header">
          <a name="comment-3863676909683312150"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-04-12 18:24</span>:
        </div>
        <div class="comment-content">
          <p>I like how this article became family-friendly by actually avoiding calling BF by its name :-)</p>
        </div>
      </div>
      <div class="comment comment-4472733791964019847">
        <div class="comment-header">
          <a name="comment-4472733791964019847"></a>
            <span class="author">Davide</span> wrote on <span class="date">2011-04-15 03:52</span>:
        </div>
        <div class="comment-content">
          <p>Amazing! Thanks for posting. I was wondering, what's about a pure C or C++ implementations, as close as reasonable to the python one? So I wrote them. You can read more details <a href="https://blog.javacorner.net/2011/04/pypy-wonders.html" rel="nofollow">here</a>, but the bottom line is that PyPy is (marginally) faster than C++, and (marginally) slower than C :-O</p>
        </div>
      </div>
      <div class="comment comment-2259705524617110733">
        <div class="comment-header">
          <a name="comment-2259705524617110733"></a>
            <span class="author">Antonio Cuni</span> wrote on <span class="date">2011-04-15 07:53</span>:
        </div>
        <div class="comment-content">
          <p>@Davide: you should compare your C version against the PyPy version WITH the JIT, as explained here:<br><br>https://morepypy.blogspot.com/2011/04/tutorial-part-2-adding-jit.html<br><br>I bet that PyPy will easily win :-)</p>
        </div>
      </div>
      <div class="comment comment-4622755320167081094">
        <div class="comment-header">
          <a name="comment-4622755320167081094"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-12-12 01:15</span>:
        </div>
        <div class="comment-content">
          <p>Nice post. I just want to report that I tried running<br><br> /usr/share/pypy-1.6/pypy/translator/goal/translate.py example2.py<br><br>and got the following error.<br>This is with an Ubuntu 1.7 pypy package rebuilt on Debian squeeze (the 1.6 is a typo, it should be 1.7).<br><br>[translation:ERROR] Error:<br>[translation:ERROR]  Traceback (most recent call last):<br>[translation:ERROR]    File "/usr/share/pypy-1.6/pypy/translator/goal/translate.py", line 308, in main<br>[translation:ERROR]     drv.proceed(goals)<br>[translation:ERROR]    File "/usr/share/pypy-1.6/pypy/translator/driver.py", line 809, in proceed<br>[translation:ERROR]     return self._execute(goals, task_skip = self._maybe_skip())<br>[translation:ERROR]    File "/usr/share/pypy-1.6/pypy/translator/tool/taskengine.py", line 116, in _execute<br>[translation:ERROR]     res = self._do(goal, taskcallable, *args, **kwds)<br>[translation:ERROR]    File "/usr/share/pypy-1.6/pypy/translator/driver.py", line 286, in _do<br>[translation:ERROR]     res = func()<br>[translation:ERROR]    File "/usr/share/pypy-1.6/pypy/translator/driver.py", line 441, in task_backendopt_lltype<br>[translation:ERROR]     from pypy.translator.backendopt.all import backend_optimizations<br>[translation:ERROR]    File "/usr/share/pypy-1.6/pypy/translator/backendopt/all.py", line 2, in <br>[translation:ERROR]     from pypy.translator.backendopt import removenoops<br>[translation:ERROR]    File "/usr/share/pypy-1.6/pypy/translator/backendopt/removenoops.py", line 5, in <br>[translation:ERROR]     from pypy import conftest<br>[translation:ERROR]    File "/usr/share/pypy-1.6/pypy/conftest.py", line 1, in <br>[translation:ERROR]     import py, pytest, sys, os, textwrap, types<br>[translation:ERROR]  ImportError: No module named pytest<br>[translation] start debugger...<br>&gt; /usr/share/pypy-1.6/pypy/conftest.py(1)()<br>-&gt; import py, pytest, sys, os, textwrap, types<br>(Pdb+)<br><br>So, it looks like pytest needs to be installed. This does not appear to be available as a Debian package.<br><br>Regards, Faheem Mitha <br>(faheem at faheem dot info)</p>
        </div>
      </div>
      <div class="comment comment-3206828184167150028">
        <div class="comment-header">
          <a name="comment-3206828184167150028"></a>
            <span class="author">James Mills</span> wrote on <span class="date">2013-02-14 05:44</span>:
        </div>
        <div class="comment-content">
          <p>This is a great post for anyone interested in programming languages :) Great post!</p>
        </div>
      </div>
      <div class="comment comment-6509040578763151306">
        <div class="comment-header">
          <a name="comment-6509040578763151306"></a>
            <span class="author">â„­acilhÎ±Ï‚, â„’a â„¬atalema</span> wrote on <span class="date">2013-02-23 02:12</span>:
        </div>
        <div class="comment-content">
          <p>Now, with os.read() and os.write():<br><br>[translation:ERROR] Error:<br>[translation:ERROR]  Traceback (most recent call last):<br>[translation:ERROR]    File "/opt/local/lib/pypy/src/pypy-pypy-07e08e9c885c/pypy/translator/goal/translate.py", line 303, in main<br>[translation:ERROR]     drv.proceed(goals)<br>[translation:ERROR]    File "/opt/local/lib/pypy-2.0-b1/src/pypy-pypy-07e08e9c885c/pypy/translator/driver.py", line 771, in proceed<br>[translation:ERROR]     return self._execute(goals, task_skip = self._maybe_skip())<br>[translation:ERROR]    File "/opt/local/lib/pypy-2.0-b1/src/pypy-pypy-07e08e9c885c/pypy/translator/tool/taskengine.py", line 116, in _execute<br>[translation:ERROR]     res = self._do(goal, taskcallable, *args, **kwds)<br>[translation:ERROR]    File "/opt/local/lib/pypy-2.0-b1/src/pypy-pypy-07e08e9c885c/pypy/translator/driver.py", line 283, in _do<br>[translation:ERROR]     res = func()<br>[translation:ERROR]    File "/opt/local/lib/pypy-2.0-b1/src/pypy-pypy-07e08e9c885c/pypy/translator/driver.py", line 319, in task_annotate<br>[translation:ERROR]     s = annotator.build_types(self.entry_point, self.inputtypes)<br>[translation:ERROR]    File "/opt/local/lib/pypy-2.0-b1/src/pypy-pypy-07e08e9c885c/pypy/annotation/annrpython.py", line 89, in build_types<br>[translation:ERROR]     return self.build_graph_types(flowgraph, inputcells, complete_now=complete_now)<br>[translation:ERROR]    File "/opt/local/lib/pypy-2.0-b1/src/pypy-pypy-07e08e9c885c/pypy/annotation/annrpython.py", line 142, in build_graph_types<br>[translation:ERROR]     self.complete()<br>[translation:ERROR]    File "/opt/local/lib/pypy-2.0-b1/src/pypy-pypy-07e08e9c885c/pypy/annotation/annrpython.py", line 217, in complete<br>[translation:ERROR]     raise AnnotatorError(text)<br>[translation:ERROR]  AnnotatorError: -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>[translation:ERROR] Blocked block -- operation cannot succeed<br>[translation:ERROR]<br>[translation:ERROR]  v1 = ord(v0)<br>[translation:ERROR] In :<br>[translation:ERROR] Happened at file /Users/cacilhas/Workspace/Personal/brainfuck/src/brainfuck/parser.py line 29<br>[translation:ERROR]<br>[translation:ERROR] ==&gt;             tape.set(ord(os.read(0, 1)))<br>[translation:ERROR]<br>[translation:ERROR] Known variable annotations:<br>[translation:ERROR]  v0 = SomeString(can_be_None=True)</p>
        </div>
      </div>
      <div class="comment comment-6568973580845189857">
        <div class="comment-header">
          <a name="comment-6568973580845189857"></a>
            <span class="author">Dvd Fo</span> wrote on <span class="date">2013-08-26 12:25</span>:
        </div>
        <div class="comment-content">
          <p>I think that your "," implementation is incorrect, os.read returns an empty string on EOF, thus [0] triggers an exception.<br>According to Wikipedia, setting the cell to 0, -1 or leaving the cell unchanged each may be used to tell EOF apart from other characters.</p>
        </div>
      </div>
      <div class="comment comment-3836156420776004882">
        <div class="comment-header">
          <a name="comment-3836156420776004882"></a>
            <span class="author">James</span> wrote on <span class="date">2015-12-02 05:50</span>:
        </div>
        <div class="comment-content">
          <p>I followed this tutorial again several years later :) (just for fun) using the newly published rpython toolchain now available up on PyPi. You can now just: pip install rpython -- I also wanted to point out that recent versions of the RPython toolchain have made advances in what it can translate it seems; specifically I did not need to change the open(...).read() parts to lower level os.read() calls.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/04/pypy-goteborg-post-easter-sprint-april-16274563331982977.html" class="u-url">PyPy GÃ¶teborg Post-Easter Sprint April 25 - May 1 2011</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/04/pypy-goteborg-post-easter-sprint-april-16274563331982977.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-04-04T13:16:00Z" itemprop="datePublished" title="2011-04-04 13:16">2011-04-04 13:16</time></a>
            </p>
                <p class="commentline">3 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>The next PyPy sprint will be in Gothenburg, Sweden. It is a public sprint,
very suitable for newcomers.  We'll focus on making the 1.5 release (if
it hasn't already happened) and whatever interests the Sprint attendees.</p>
<div class="section" id="topics-and-goals">
<h2>Topics and goals</h2>
<p>The main goal is to polish and release PyPy 1.5, supporting Python 2.7
as well as the last few months' improvements in the JIT (provided that
it hasn't already happened).  Other topics:</p>
<ul class="simple">
<li>Going over our documentation, and classifying our docs in terms of
mouldiness.  Deciding what needs writing, and maybe writing it.</li>
<li>Helping people get their code running with PyPy</li>
<li>maybe work on EuroPython Training, and talks</li>
<li>Summer of Code preparation</li>
<li>speed.pypy.org</li>
<li>any other programming task is welcome too -- e.g. tweaking the
Python or JavaScript interpreter, Stackless support, and so on.</li>
</ul>
</div>
<div class="section" id="location">
<h2>Location</h2>
<p>The sprint will be held in the apartment of Laura Creighton and Jacob HallÃ©n
which is at GÃ¶tabergsgatan 22 in Gothenburg, Sweden.  Here is a <a class="reference external" href="https://bit.ly/grRuQe">map</a>.  This is
in central Gothenburg.  It is between the <a class="reference external" href="https://www.vasttrafik.se/en/">tram</a> stops of Vasaplatsen and
Valand, (a distance of 4 blocks) where many lines call -- the 2, 3, 4, 5,
7, 10 and 13.</p>
<p>Probably cheapest and not too far away is to book accomodation at <a class="reference external" href="https://www.sgsveckobostader.se/en">SGS
Veckobostader</a>. The  <a class="reference external" href="https://www.elite.se/hotell/goteborg/park/">Elite Park Avenyn Hotel</a> is a luxury hotel just a
few blocks away. There are scores of hotels a short walk away from the
sprint location, suitable for every budget, desire for luxury, and desire
for the unusual.  You could, for instance, stay on a <a class="reference external" href="https://www.liseberg.se/en/home/Accommodation/Hotel/Hotel-Barken-Viking/">boat</a>.  Options are
too numerous to go into here. Just ask in the mailing list or on the blog.</p>
<p>Hours will be
from 10:00 until people have had enough.  It's a good idea to arrive a
day before the sprint starts and leave a day later.  In the middle of
the sprint there usually is a break day and it's usually ok to take
half-days off if you feel like it.</p>
</div>
<div class="section" id="good-to-know">
<h2>Good to Know</h2>
<p>Sweden is not part of the Euro zone. One SEK (krona in singular, kronor
in plural) is roughly 1/10th of a Euro (9.36 SEK to 1 Euro).</p>
<p>The venue is central in Gothenburg.  There is a large selection of
places to get food nearby, from edible-and-cheap to outstanding.  We
often cook meals together, so let us know if you have any food allergies,
dislikes, or special requirements.</p>
<p>Sweden uses the same kind of plugs as Germany. 230V AC.</p>
<p>The Sprint will be held the week following Easter.  This means, as always,
that <a class="reference external" href="https://www.gothcon.se/">Gothcon</a> will be taking place the weekend before (Easter weekend).
Gothcon, now in its 35 year, is the largest European game players conference.
Some of you may be interested in arriving early for the board games.
The conference site is only in Swedish, alas.  You don't need to register
in advance unless you are planning to host a tournament, (and it's too
late for that anyway).</p>
</div>
<div class="section" id="getting-here">
<h2>Getting Here</h2>
<p>If are coming train, you will arrive at the <a class="reference external" href="https://bit.ly/fON43p">Central Station</a>.  It is
about 12 blocks to the site from there, or you can take a <a class="reference external" href="https://www.vasttrafik.se/en/">tram</a>.</p>
<p>There are two airports which are local to GÃ¶teborg, <a class="reference external" href="https://swedavia.se/en/Goteborg/Traveller-information/Traffic-information/">Landvetter</a> (the main
one) and <a class="reference external" href="https://www.goteborgairport.se/eng.asp">Gothenburg City Airport</a> (where some budget airlines fly).
If you arrive at <a class="reference external" href="https://swedavia.se/en/Goteborg/Traveller-information/Traffic-information/">Landvetter</a>  the airport bus stops right downtown at
<a class="reference external" href="https://www.elite.se/hotell/goteborg/park/">Elite Park Avenyn Hotel</a> which is the second stop, 4 blocks from the
Sprint site, as well as the end of the line, which is the <a class="reference external" href="https://bit.ly/fON43p">Central Station</a>.
If you arrive at <a class="reference external" href="https://www.goteborgairport.se/eng.asp">Gothenburg City Airport</a> take the bus to the end of the
line.  You will be at the  <a class="reference external" href="https://bit.ly/fON43p">Central Station</a>.</p>
<p>You can also arrive by <a class="reference external" href="https://www.stenaline.nl/en/ferry/">ferry</a>, from either Kiel in Germany or Frederikshavn
in Denmark.</p>
</div>
<div class="section" id="who-s-coming">
<h2>Who's Coming?</h2>
<p>If you'd like to come, please let us know when you will be arriving and
leaving, as well as letting us know your interests  We'll keep a list
of <a class="reference external" href="https://foss.heptapod.net/pypy/extradoc/-/blob/branch/default/tip/sprintinfo/gothenburg-2011/people.txt">people</a> which we'll update (which you can do so yourself if you
have bitbucket pypy commit rights).</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-3352762323347059145">
        <div class="comment-header">
          <a name="comment-3352762323347059145"></a>
            <span class="author">intgr</span> wrote on <span class="date">2011-04-04 22:37</span>:
        </div>
        <div class="comment-content">
          <p>"e.g. tweaking the Python or JavaScript interpreter"<br><br>Are you implying that PyPy has a JavaScript interpreter now?</p>
        </div>
      </div>
      <div class="comment comment-2475327180628788036">
        <div class="comment-header">
          <a name="comment-2475327180628788036"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-04-05 13:58</span>:
        </div>
        <div class="comment-content">
          <p>It had one since a few years. It's not complete though: https://bitbucket.org/pypy/lang-js/overview</p>
        </div>
      </div>
      <div class="comment comment-550103863811834182">
        <div class="comment-header">
          <a name="comment-550103863811834182"></a>
            <span class="author">vak</span> wrote on <span class="date">2011-04-28 08:59</span>:
        </div>
        <div class="comment-content">
          <p>any updates from the event?</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/03/controlling-tracing-of-interpreter-with_26-3072929156700508140.html" class="u-url">Controlling the Tracing of an Interpreter With Hints, Part 4: Benchmarks</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/03/controlling-tracing-of-interpreter-with_26-3072929156700508140.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-03-26T17:44:00Z" itemprop="datePublished" title="2011-03-26 17:44">2011-03-26 17:44</time></a>
            </p>
                <p class="commentline">9 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>This is part 4 and the <strong>final</strong> part of the series on how to speed up an interpreter
written with PyPy by adding JIT hints to the interpreter. Part 1 described how
to <a class="reference external" href="../posts/2011/03/controlling-tracing-of-interpreter-with-871085470935630424.html">control the extent of tracing</a>. Part 2 described how to <a class="reference external" href="../posts/2011/03/controlling-tracing-of-interpreter-with_15-3281215865169782921.html">influence the
optimizer with promotion and pure functions</a>. Part 3 described a <a class="reference external" href="../posts/2011/03/controlling-tracing-of-interpreter-with_21-6524148550848694588.html">simple object
model and how it can be optimized</a> by doing small rewrites. In this (short) post
I present some benchmarks.</p>
<div class="section" id="benchmarks">
<h2>Benchmarks</h2>
<p>For the benchmarks I ran a subset of the benchmarks on <a class="reference external" href="https://speed.pypy.org">https://speed.pypy.org</a>
with CPython and four different executables of PyPy's Python interpreter (all
with a JIT). The executables contain all combinations of enabling maps (which
make instance attributes fast) and type versions (which makes method lookup
fast).</p>
<ul class="simple">
<li>
<strong>pypy-slow</strong>: contains neither maps nor type versions.</li>
<li>
<strong>pypy-map</strong>: contains maps but not type versions.</li>
<li>
<strong>pypy-version</strong>: contains type versions but not maps.</li>
<li>
<strong>pypy-full</strong>: contains both maps <em>and</em> type versions</li>
</ul>
<p>The results are as follows:</p>
<a href="https://2.bp.blogspot.com/-tzvNLyIUk2g/TY4mMvBzHYI/AAAAAAAAAP8/1Kc6uR3Mb14/s1600/bench-objmodel.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5588446187837660546" src="https://2.bp.blogspot.com/-tzvNLyIUk2g/TY4mMvBzHYI/AAAAAAAAAP8/1Kc6uR3Mb14/s600/bench-objmodel.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 600px;"></a>
<p>The graph shows the speedup over CPython's numbers. The results are quite
interesting. Maps by themselves do not speed up much over the bare JIT, whereas
typed versions alone improve on the JIT baseline in many cases. However, maps
are not useless. In combination with type versions they add a nice improvement
over just type versions in a number of benchmarks (most notably
<tt class="docutils literal"><span class="pre">raytrace-simple</span></tt> and <tt class="docutils literal">richards</tt> but also in <tt class="docutils literal"><span class="pre">crypto-pyaes</span></tt>, <tt class="docutils literal">django</tt>
and <tt class="docutils literal">go</tt>).</p>
<p>It's clear that type versions can be arbitrarily effective. A method lookup on a
class can be arbitrarily slow, if the inheritance hierarchy becomes deeper and
deeper. The full lookup is replaced by one promotion if type versions are
enabled.</p>
<p>Maps on the other hand always replace one dict lookup with one promotion. Since
dict lookups are already very fast, this by itself does not lead to a gigantic
improvement. Only in combination with type versions do they show their full
potential.</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-8521252991658760917">
        <div class="comment-header">
          <a name="comment-8521252991658760917"></a>
            <span class="author">Winston Ewert</span> wrote on <span class="date">2011-03-26 20:17</span>:
        </div>
        <div class="comment-content">
          <p>It's not clear to me why version + maps combine so well. Maps should effectively eliminate lookups on the instance dict and versions eliminate lookups on the class dict. Both versions would seem to eliminate different classes of lookups, so I'm not seeing why we have dramatic improvement when using them together.</p>
        </div>
      </div>
      <div class="comment comment-6850712540526590285">
        <div class="comment-header">
          <a name="comment-6850712540526590285"></a>
            <span class="author">Alex</span> wrote on <span class="date">2011-03-26 20:19</span>:
        </div>
        <div class="comment-content">
          <p>I'm not an expert at CPU architecture, but ISTM eliminating both can eliminate a large number of memory reads which would help with pipelining and other very low level optimizations.</p>
        </div>
      </div>
      <div class="comment comment-8246456973299056880">
        <div class="comment-header">
          <a name="comment-8246456973299056880"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-26 21:33</span>:
        </div>
        <div class="comment-content">
          <p>@Winston: I actually have no clue :-). The numbers are hard to deny though. I plan to stare at the traces a bit next week, can comment here if I find something interesting.</p>
        </div>
      </div>
      <div class="comment comment-5202002475509570499">
        <div class="comment-header">
          <a name="comment-5202002475509570499"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-27 14:52</span>:
        </div>
        <div class="comment-content">
          <p>@Winston: ok, I probably found out. Your reasoning is too simple because usually you do several lookups on the same object in a row. Every lookup looks first in the class, then in the instance. So it looks a bit like this:<br><br>lookup name1 in obj.__class__<br>lookup name1 in obj.__dict__<br>lookup name2 in obj.__class__<br>lookup name2 in obj.__dict__<br>lookup name2 in obj.__class__<br>lookup name2 in obj.__dict__<br><br>when using maps, every lookup in the dict is simply reading the map, promoting it and then a read. after the promotion of the map, the instance's layout is fully known. however, if type versions are disabled, the lookups in the class are complex operations that are opaque to the JIT. Therefore the JIT assumes they can change the layout and thus the map of the object.<br><br>If you also enable type versions, then the class lookups are understandable to the JIT. therefore the JIT can see that the class lookup didn't change the layout of the class. This means that after the first instance lookup, the following instance lookups cost nothing at all.</p>
        </div>
      </div>
      <div class="comment comment-7570150962796741243">
        <div class="comment-header">
          <a name="comment-7570150962796741243"></a>
            <span class="author">klaussfreire</span> wrote on <span class="date">2011-03-28 15:04</span>:
        </div>
        <div class="comment-content">
          <p>I think an important improvement brought about by maps is the memory footprint reduction.<br><br>It won't matter all the time, but it makes all classes as space-efficient as if they used __slots__, all automagically, which is no small thing.<br><br>For programs that handle lots of small objects, this can really make a difference, in memory consumption and speed (less memory to shuffle around will invariably be faster)<br><br>Perhaps the benchmark suite doesn't have enough of those cases.</p>
        </div>
      </div>
      <div class="comment comment-8177981225971493179">
        <div class="comment-header">
          <a name="comment-8177981225971493179"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-03-28 22:16</span>:
        </div>
        <div class="comment-content">
          <p>@cfbolz I think one reason why maps+version tags are fast is because we lack jit.unroll_safe on several lookup functions when version tags are disabled. Marking them as unrollable would speed things up.<br><br>The reasoning behind this is that old style classes which have maps, but no version tags are much faster than new style classes with version tags disabled.</p>
        </div>
      </div>
      <div class="comment comment-8842178111548556511">
        <div class="comment-header">
          <a name="comment-8842178111548556511"></a>
            <span class="author">Winston Ewert</span> wrote on <span class="date">2011-03-30 00:41</span>:
        </div>
        <div class="comment-content">
          <p>Thanks for taking the time to answer my query. <br><br>The use of class versions eliminates the opaque function being called because the JIT knows the return will be constant. This allows optimizations to work correctly. But this makes me wonder how much of the improvement is due to class versions and how much is due to lack of opaqueness. <br><br>At any rate, I always find the posts on this blog very interesting. It definitely some neat stuff you are doing here.</p>
        </div>
      </div>
      <div class="comment comment-7610808792454764481">
        <div class="comment-header">
          <a name="comment-7610808792454764481"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-30 11:30</span>:
        </div>
        <div class="comment-content">
          <p>@fijal I thought old-style classes had celldicts? That's yet another thing, but your point is still correct.</p>
        </div>
      </div>
      <div class="comment comment-8051443532853181425">
        <div class="comment-header">
          <a name="comment-8051443532853181425"></a>
            <span class="author">Benjamin</span> wrote on <span class="date">2011-04-27 22:48</span>:
        </div>
        <div class="comment-content">
          <p>I'd love to see a blog post about conventions to favor or avoid while writing python code to best take advantage of these excellent features.  For example, your previous post implied something like this would be faster than changing the class directly:<br><br>class Counter(object):<br>....def __init__(self):<br>........self.count = 0<br>....def increment(self):<br>........self.count += 1<br><br>class Many(object):<br>....counter = Counter()<br>....def __init__(self):<br>........self.counter.increment()<br><br>Granted, it would be preferable, from a coding standpoint, to just use a simple class attribute, but the adaptations that would likely work best for the pypy JIT seem like far smaller divergences from the 'ideal' python than many other lengths people go to when coding for speed, particularly compared to something like cython.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/03/thank-you-to-psf-5934275567667314914.html" class="u-url">A thank you to the PSF</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/03/thank-you-to-psf-5934275567667314914.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-03-21T23:50:00Z" itemprop="datePublished" title="2011-03-21 23:50">2011-03-21 23:50</time></a>
            </p>
                <p class="commentline">4 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>This year's PyCon was an incredible time; several members of the PyPy team were
there, and we'll be blogging more about our experiences in the coming days.
However, we quickly wanted to extend a thank you to the <a class="reference external" href="https://www.python.org/psf/">Python Software
Foundation (PSF)</a>.</p>
<p>As you may have heard, on Friday morning at PyCon Jesse Noller handed the PyPy
team a check for $10,000, on behalf of the PSF.  This was in recognition of our
success over the past few years in bringing PyPy from a research project
to a fast, compliant, production-ready Python implementation, and to allow us
to continue our work on making it faster and more up-to-date with upstream
version changes.</p>
<p>Beyond the large check, we're grateful for the endorsement this represents,
not only of our work on PyPy, but also of all alternatve Python VMs.
The PSF has shifted its focus from representing just CPython to representing
the Python Language, reguardless of its implementation, something we are very
appreciative of.</p>
<a href="https://3.bp.blogspot.com/-yLUKuyRgjdg/TYfklB5Jg4I/AAAAAAAABKM/_5Rv2thqzA0/s1600/pycon_cheque.jpg"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5586685187590816642" src="https://3.bp.blogspot.com/-yLUKuyRgjdg/TYfklB5Jg4I/AAAAAAAABKM/_5Rv2thqzA0/s320/pycon_cheque.jpg" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 320px; height: 269px;"></a>
<p>From left to right, PyPy people present at PyCon 2011: Maciej FijaÅ‚kowski, Armin Rigo, Alex Gaynor, Laura Creighton and Jacob HallÃ©n</p>

<p>Thank you, PSF.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-6583068564673411306">
        <div class="comment-header">
          <a name="comment-6583068564673411306"></a>
            <span class="author">Hodgestar</span> wrote on <span class="date">2011-03-22 00:17</span>:
        </div>
        <div class="comment-content">
          <p>Congratulations! It's great to see the PSF embracing the broader Python ecosystem.</p>
        </div>
      </div>
      <div class="comment comment-4030208982847066842">
        <div class="comment-header">
          <a name="comment-4030208982847066842"></a>
            <span class="author">Steve</span> wrote on <span class="date">2011-03-22 03:24</span>:
        </div>
        <div class="comment-content">
          <p>It's nice to be able to offer this support as an indication that we aren't just the CPython Software Foundation. It is a well-deserved award, and we know it will be put to good use.</p>
        </div>
      </div>
      <div class="comment comment-5041449382898940103">
        <div class="comment-header">
          <a name="comment-5041449382898940103"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-03-23 14:47</span>:
        </div>
        <div class="comment-content">
          <p>Yyes. Keep it Going! =)</p>
        </div>
      </div>
      <div class="comment comment-8377800197501710604">
        <div class="comment-header">
          <a name="comment-8377800197501710604"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-05-03 08:34</span>:
        </div>
        <div class="comment-content">
          <p>Wow, congratulations! PyPy has gone a long way.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/03/controlling-tracing-of-interpreter-with_21-6524148550848694588.html" class="u-url">Controlling the Tracing of an Interpreter With Hints, Part 3: Putting it All Together</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/03/controlling-tracing-of-interpreter-with_21-6524148550848694588.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-03-21T15:47:00Z" itemprop="datePublished" title="2011-03-21 15:47">2011-03-21 15:47</time></a>
            </p>
                <p class="commentline">7 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>This is part 3 of the series on how to speed up an interpreter written with
PyPy by adding JIT hints to the interpreter. Part 1 described how to <a class="reference external" href="../posts/2011/03/controlling-tracing-of-interpreter-with-871085470935630424.html">control
the extent of tracing</a>. Part 2 described how to <a class="reference external" href="../posts/2011/03/controlling-tracing-of-interpreter-with_15-3281215865169782921.html">influence the optimizer with
promotion and pure functions</a>. In this post I describe a worked-out example of
a small object model for a dynamic language and how to make it efficient using
the hints described in the previous posts.</p>
<div class="section" id="a-simple-object-model">
<h2>A Simple Object Model</h2>
<p>To implement a dynamic language efficiently, the operations on its objects need
to be fast. Most dynamic languages have object models that are made by using
dictionaries everywhere. Let's look at an example of how the JIT can be made to
optimize such operations.</p>
<p>For the purpose of this blog post we will use a very simple and bare-bones
object model that just supports very simple classes and instances, without any
inheritance or any fancy features. The model has classes, which contain methods.
Instances have a class. Instances have their own attributes. When looking up an
attribute on an instance, the instances attributes are searched. If the
attribute is not found there, the class' attributes are searched.</p>
<p>To implement this object model, we could use the following RPython code as part
of the interpreter source code:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Class</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, name):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>name <span style="color: #555555;">=</span> name
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>methods <span style="color: #555555;">=</span> {}

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">instantiate</span>(<span style="color: #336666;">self</span>):
        <span style="color: #006699; font-weight: bold;">return</span> Instance(<span style="color: #336666;">self</span>)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">find_method</span>(<span style="color: #336666;">self</span>, name):
        result <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>methods<span style="color: #555555;">.</span>get(name)
        <span style="color: #006699; font-weight: bold;">if</span> result <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>:
            <span style="color: #006699; font-weight: bold;">return</span> result
        <span style="color: #006699; font-weight: bold;">raise</span> <span style="color: #CC0000; font-weight: bold;">AttributeError</span>(name)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">change_method</span>(<span style="color: #336666;">self</span>, name, value):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>methods[name] <span style="color: #555555;">=</span> value


<span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Instance</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, cls):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>cls <span style="color: #555555;">=</span> cls
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>attributes <span style="color: #555555;">=</span> {}

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">getfield</span>(<span style="color: #336666;">self</span>, name):
        result <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>attributes<span style="color: #555555;">.</span>get(name)
        <span style="color: #006699; font-weight: bold;">if</span> result <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>:
            <span style="color: #006699; font-weight: bold;">return</span> result
        <span style="color: #006699; font-weight: bold;">raise</span> <span style="color: #CC0000; font-weight: bold;">AttributeError</span>(name)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">write_attribute</span>(<span style="color: #336666;">self</span>, name, value):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>attributes[name] <span style="color: #555555;">=</span> value

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">getattr</span>(<span style="color: #336666;">self</span>, name):
        <span style="color: #006699; font-weight: bold;">try</span>:
            <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>getfield(name)
        <span style="color: #006699; font-weight: bold;">except</span> <span style="color: #CC0000; font-weight: bold;">AttributeError</span>:
            <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>cls<span style="color: #555555;">.</span>find_method(name)
</pre></div>
<p>In this straightforward implementation the methods and attributes are just
stored in dictionaries on the classes/instances. While this object model is very
simple it already contains all the hard parts of Python's object model. Both
instances and classes can have arbitrary fields, and they are changeable at
any time.  Moreover, instances can change their class after they have been
created.</p>
<p>When using this object model in
an interpreter, a huge amount of time will be spent doing lookups in these
dictionaries. To make the language efficient using a tracing JIT, we need to
find a way to get rid of these dictionary lookups somehow.</p>
<p>Let's assume we trace through code that sums three attributes, such as:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;">inst<span style="color: #555555;">.</span>getattr(<span style="color: #CC3300;">"a"</span>) <span style="color: #555555;">+</span> inst<span style="color: #555555;">.</span>getattr(<span style="color: #CC3300;">"b"</span>) <span style="color: #555555;">+</span> inst<span style="color: #555555;">.</span>getattr(<span style="color: #CC3300;">"c"</span>)
</pre></div>
<p>The trace could look like this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #0099FF; font-style: italic;"># inst.getattr("a")</span>
attributes1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>attributes
result1 <span style="color: #555555;">=</span> <span style="color: #336666;">dict</span><span style="color: #555555;">.</span>get(attributes1, <span style="color: #CC3300;">"a"</span>)
guard(result1 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>)

<span style="color: #0099FF; font-style: italic;"># inst.getattr("b")</span>
attributes2 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>attributes
v1 <span style="color: #555555;">=</span> <span style="color: #336666;">dict</span><span style="color: #555555;">.</span>get(attributes2, <span style="color: #CC3300;">"b"</span>)
guard(v1 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #336666;">None</span>)
cls1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>cls
methods1 <span style="color: #555555;">=</span> cls<span style="color: #555555;">.</span>methods
result2 <span style="color: #555555;">=</span> <span style="color: #336666;">dict</span><span style="color: #555555;">.</span>get(methods1, <span style="color: #CC3300;">"b"</span>)
guard(result2 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>)
v2 <span style="color: #555555;">=</span> result1 <span style="color: #555555;">+</span> result2

<span style="color: #0099FF; font-style: italic;"># inst.getattr("c")</span>
attributes3 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>attributes
v3 <span style="color: #555555;">=</span> <span style="color: #336666;">dict</span><span style="color: #555555;">.</span>get(attributes3, <span style="color: #CC3300;">"c"</span>)
guard(v3 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #336666;">None</span>)
cls1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>cls
methods2 <span style="color: #555555;">=</span> cls<span style="color: #555555;">.</span>methods
result3 <span style="color: #555555;">=</span> <span style="color: #336666;">dict</span><span style="color: #555555;">.</span>get(methods2, <span style="color: #CC3300;">"c"</span>)
guard(result3 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>)

v4 <span style="color: #555555;">=</span> v2 <span style="color: #555555;">+</span> result3
<span style="color: #006699; font-weight: bold;">return</span>(v4)
</pre></div>
<p>In this example, the attribute <tt class="docutils literal">a</tt> is found on the instance, but the
attributes <tt class="docutils literal">b</tt> and <tt class="docutils literal">c</tt> are found on the class. The trace indeed contains
five calls to <tt class="docutils literal">dict.get</tt>, which is slow.</p>
</div>
<div class="section" id="making-instance-attributes-faster-using-maps">
<h2>Making Instance Attributes Faster Using Maps</h2>
<p>The first step in making <tt class="docutils literal">getattr</tt> faster in our object model is to optimize
away the dictionary lookups on the instances. The hints we have looked at in the
two earlier blog posts don't seem to help with the current object model. There is
no pure function to be seen, and the instance is not a candidate for promotion,
because there tend to be many instances.</p>
<p>This is a common problem when trying to apply hints. Often, the interpreter
needs a small rewrite to expose the pure functions and nearly-constant objects
that are implicitly there. In the case of instance fields this rewrite is not
entirely obvious. The basic idea is as follows. In theory instances can have
arbitrary fields. In practice however many instances share their layout (i.e.
their set of keys) with many other instances.</p>
<p>Therefore it makes sense to factor the layout information out of the instance
implementation into a shared object. This shared layout object is called a
<em>map</em>. Maps are an old idea that comes originally from the SELF language. They are
also used by many JavaScript implementations such as V8. I've <a class="reference external" href="../posts/2010/11/efficiently-implementing-python-objects-3838329944323946932.html">written about maps
before</a>, so I won't explain them fully again.</p>
<p>The rewritten <tt class="docutils literal">Instance</tt> class using maps looks like this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Map</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>attribute_indexes <span style="color: #555555;">=</span> {}
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>other_maps <span style="color: #555555;">=</span> {}

    <span style="color: #9999FF;">@purefunction</span>
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">getindex</span>(<span style="color: #336666;">self</span>, name):
        <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>attribute_indexes<span style="color: #555555;">.</span>get(name, <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>)

    <span style="color: #9999FF;">@purefunction</span>
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">new_map_with_additional_attribute</span>(<span style="color: #336666;">self</span>, name):
        <span style="color: #006699; font-weight: bold;">if</span> name <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #000000; font-weight: bold;">in</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>other_maps:
            newmap <span style="color: #555555;">=</span> Map()
            newmap<span style="color: #555555;">.</span>attribute_indexes<span style="color: #555555;">.</span>update(<span style="color: #336666;">self</span><span style="color: #555555;">.</span>attribute_indexes)
            newmap<span style="color: #555555;">.</span>attribute_indexes[name] <span style="color: #555555;">=</span> <span style="color: #336666;">len</span>(<span style="color: #336666;">self</span><span style="color: #555555;">.</span>attribute_indexes)
            <span style="color: #336666;">self</span><span style="color: #555555;">.</span>other_maps[name] <span style="color: #555555;">=</span> newmap
        <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>other_maps[name]


EMPTY_MAP <span style="color: #555555;">=</span> Map()

<span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Instance</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, cls):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>cls <span style="color: #555555;">=</span> cls
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>map <span style="color: #555555;">=</span> EMPTY_MAP
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>storage <span style="color: #555555;">=</span> []

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">getfield</span>(<span style="color: #336666;">self</span>, name):
        <span style="color: #336666;">map</span> <span style="color: #555555;">=</span> hint(<span style="color: #336666;">self</span><span style="color: #555555;">.</span>map, promote<span style="color: #555555;">=</span><span style="color: #336666;">True</span>)
        index <span style="color: #555555;">=</span> <span style="color: #336666;">map</span><span style="color: #555555;">.</span>getindex(name)
        <span style="color: #006699; font-weight: bold;">if</span> index <span style="color: #555555;">!=</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>:
            <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>storage[index]
        <span style="color: #006699; font-weight: bold;">raise</span> <span style="color: #CC0000; font-weight: bold;">AttributeError</span>(name)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">write_attribute</span>(<span style="color: #336666;">self</span>, name, value):
        <span style="color: #336666;">map</span> <span style="color: #555555;">=</span> hint(<span style="color: #336666;">self</span><span style="color: #555555;">.</span>map, promote<span style="color: #555555;">=</span><span style="color: #336666;">True</span>)
        index <span style="color: #555555;">=</span> <span style="color: #336666;">map</span><span style="color: #555555;">.</span>getindex(name)
        <span style="color: #006699; font-weight: bold;">if</span> index <span style="color: #555555;">!=</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>:
            <span style="color: #336666;">self</span><span style="color: #555555;">.</span>storage[index] <span style="color: #555555;">=</span> value
            <span style="color: #006699; font-weight: bold;">return</span>
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>map <span style="color: #555555;">=</span> <span style="color: #336666;">map</span><span style="color: #555555;">.</span>new_map_with_additional_attribute(name)
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>storage<span style="color: #555555;">.</span>append(value)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">getattr</span>(<span style="color: #336666;">self</span>, name):
        <span style="color: #006699; font-weight: bold;">try</span>:
            <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>getfield(name)
        <span style="color: #006699; font-weight: bold;">except</span> <span style="color: #CC0000; font-weight: bold;">AttributeError</span>:
            <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>cls<span style="color: #555555;">.</span>find_method(name)
</pre></div>
<p>Instances no longer use dictionaries to store their fields. Instead, they have a
reference to a map, which maps field names to indexes into a storage list. The
storage list contains the actual field values. The maps are shared between
objects with the same layout. Therefore they have to be immutable, which means
that their <tt class="docutils literal">getindex</tt> method is a pure function. When a new attribute is added
to an instance, a new map needs to be chosen, which is done with the
<tt class="docutils literal">new_map_with_additional_attribute</tt> method on the previous map. Now that we have
introduced maps, it is safe to promote the map everywhere, because we assume
that the number of different instance layouts is small.</p>
<p>With this changed instance implementation, the trace we had above changes to the
following, where <tt class="docutils literal">0xb74af4a8</tt> is the memory address of the Map instance that
has been promoted:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #0099FF; font-style: italic;"># inst.getattr("a")</span>
map1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>map
guard(map1 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb74af4a8</span>)
index1 <span style="color: #555555;">=</span> Map<span style="color: #555555;">.</span>getindex(map1, <span style="color: #CC3300;">"a"</span>)
guard(index1 <span style="color: #555555;">!=</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>)
storage1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>storage
result1 <span style="color: #555555;">=</span> storage1[index1]

<span style="color: #0099FF; font-style: italic;"># inst.getattr("b")</span>
map2 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>map
guard(map2 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb74af4a8</span>)
index2 <span style="color: #555555;">=</span> Map<span style="color: #555555;">.</span>getindex(map2, <span style="color: #CC3300;">"b"</span>)
guard(index2 <span style="color: #555555;">==</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>)
cls1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>cls
methods1 <span style="color: #555555;">=</span> cls<span style="color: #555555;">.</span>methods
result2 <span style="color: #555555;">=</span> <span style="color: #336666;">dict</span><span style="color: #555555;">.</span>get(methods1, <span style="color: #CC3300;">"b"</span>)
guard(result2 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>)
v2 <span style="color: #555555;">=</span> result1 <span style="color: #555555;">+</span> result2

<span style="color: #0099FF; font-style: italic;"># inst.getattr("c")</span>
map3 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>map
guard(map3 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb74af4a8</span>)
index3 <span style="color: #555555;">=</span> Map<span style="color: #555555;">.</span>getindex(map3, <span style="color: #CC3300;">"c"</span>)
guard(index3 <span style="color: #555555;">==</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>)
cls1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>cls
methods2 <span style="color: #555555;">=</span> cls<span style="color: #555555;">.</span>methods
result3 <span style="color: #555555;">=</span> <span style="color: #336666;">dict</span><span style="color: #555555;">.</span>get(methods2, <span style="color: #CC3300;">"c"</span>)
guard(result3 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>)

v4 <span style="color: #555555;">=</span> v2 <span style="color: #555555;">+</span> result3
<span style="color: #006699; font-weight: bold;">return</span>(v4)
</pre></div>
<p>The calls to <tt class="docutils literal">Map.getindex</tt> can be optimized away, because they are calls to
a pure function and they have constant arguments. That means that <tt class="docutils literal">index1/2/3</tt>
are constant and the guards on them can be removed. All but the first guard on
the map will be optimized away too, because the map cannot have changed in
between. The optimized trace looks like this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #0099FF; font-style: italic;"># inst.getattr("a")</span>
map1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>map
guard(map1 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb74af4a8</span>)
storage1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>storage
result1 <span style="color: #555555;">=</span> storage1[<span style="color: #FF6600;">0</span>]

<span style="color: #0099FF; font-style: italic;"># inst.getattr("b")</span>
cls1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>cls
methods1 <span style="color: #555555;">=</span> cls1<span style="color: #555555;">.</span>methods
result2 <span style="color: #555555;">=</span> <span style="color: #336666;">dict</span><span style="color: #555555;">.</span>get(methods1, <span style="color: #CC3300;">"b"</span>)
guard(result2 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>)
v2 <span style="color: #555555;">=</span> result1 <span style="color: #555555;">+</span> result2

<span style="color: #0099FF; font-style: italic;"># inst.getattr("c")</span>
cls2 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>cls
methods2 <span style="color: #555555;">=</span> cls2<span style="color: #555555;">.</span>methods
result3 <span style="color: #555555;">=</span> <span style="color: #336666;">dict</span><span style="color: #555555;">.</span>get(methods2, <span style="color: #CC3300;">"c"</span>)
guard(result3 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>)

v4 <span style="color: #555555;">=</span> v2 <span style="color: #555555;">+</span> result3
<span style="color: #006699; font-weight: bold;">return</span>(v4)
</pre></div>
<p>The index <tt class="docutils literal">0</tt> that is used to read out of the <tt class="docutils literal">storage</tt> array is the result
of the constant-folded <tt class="docutils literal">getindex</tt> call. This trace is already much better than
the original one. Now we are down from five dictionary lookups to just two.</p>
</div>
<div class="section" id="versioning-of-classes">
<h2>Versioning of Classes</h2>
<p>Instances were optimized making the assumption that the total number of
Instance layouts is small compared to the number of instances. For classes we
will make an even stronger assumption. We simply assume that it is rare for
classes to change at all. This is not totally reasonable (sometimes classes contain
counters or similar things) but for this simple example it is good enough.</p>
<p>What we would really like is if the <tt class="docutils literal">Class.find_method</tt> method were pure.
But it cannot be, because it is always possible to change the class itself.
Every time the class changes, <tt class="docutils literal">find_method</tt> can potentially return a
new value.</p>
<p>Therefore, we give every class a version number, which is increased every time a
class gets changed (i.e., the content of the <tt class="docutils literal">methods</tt> dictionary changes).
This means that the result of <tt class="docutils literal">methods.get()</tt> for a given <tt class="docutils literal">(name,
version)</tt> pair will always be the same, i.e. it is a pure operation.  To help
the JIT to detect this case, we factor it out in a helper method which is
explicitly marked as <tt class="docutils literal">@purefunction</tt>. The refactored <tt class="docutils literal">Class</tt> looks like
this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">VersionTag</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">pass</span>

<span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Class</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, name):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>name <span style="color: #555555;">=</span> name
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>methods <span style="color: #555555;">=</span> {}
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>version <span style="color: #555555;">=</span> VersionTag()

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">find_method</span>(<span style="color: #336666;">self</span>, name):
        <span style="color: #336666;">self</span> <span style="color: #555555;">=</span> hint(<span style="color: #336666;">self</span>, promote<span style="color: #555555;">=</span><span style="color: #336666;">True</span>)
        version <span style="color: #555555;">=</span> hint(<span style="color: #336666;">self</span><span style="color: #555555;">.</span>version, promote<span style="color: #555555;">=</span><span style="color: #336666;">True</span>)
        result <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>_find_method(name, version)
        <span style="color: #006699; font-weight: bold;">if</span> result <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>:
            <span style="color: #006699; font-weight: bold;">return</span> result
        <span style="color: #006699; font-weight: bold;">raise</span> <span style="color: #CC0000; font-weight: bold;">AttributeError</span>(name)

    <span style="color: #9999FF;">@purefunction</span>
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">_find_method</span>(<span style="color: #336666;">self</span>, name, version):
        <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>methods<span style="color: #555555;">.</span>get(name)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">change_method</span>(<span style="color: #336666;">self</span>, name, value):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>methods[name] <span style="color: #555555;">=</span> value
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>version <span style="color: #555555;">=</span> VersionTag()
</pre></div>
<p>What is interesting here is that <tt class="docutils literal">_find_method</tt> takes the <tt class="docutils literal">version</tt>
argument but it does not use it at all. Its only purpose is to make the call
pure (because when the version number changes, the result of the call might be
different than the previous one).</p>
<p>The trace with this new class implementation looks like this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #0099FF; font-style: italic;"># inst.getattr("a")</span>
map1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>map
guard(map1 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb74af4a8</span>)
index1 <span style="color: #555555;">=</span> Map<span style="color: #555555;">.</span>getindex(map1, <span style="color: #CC3300;">"a"</span>)
guard(index1 <span style="color: #555555;">!=</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>)
storage1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>storage
result1 <span style="color: #555555;">=</span> storage1[index1]

<span style="color: #0099FF; font-style: italic;"># inst.getattr("b")</span>
map2 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>map
guard(map2 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb74af4a8</span>)
index2 <span style="color: #555555;">=</span> Map<span style="color: #555555;">.</span>getindex(map2, <span style="color: #CC3300;">"b"</span>)
guard(index2 <span style="color: #555555;">==</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>)
cls1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>cls
guard(cls1 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb7aaaaf8</span>)
version1 <span style="color: #555555;">=</span> cls1<span style="color: #555555;">.</span>version
guard(version1 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb7bbbb18</span>)
result2 <span style="color: #555555;">=</span> Class<span style="color: #555555;">.</span>_find_method(cls, <span style="color: #CC3300;">"b"</span>, version1)
guard(result2 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>)
v2 <span style="color: #555555;">=</span> result1 <span style="color: #555555;">+</span> result2

<span style="color: #0099FF; font-style: italic;"># inst.getattr("c")</span>
map3 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>map
guard(map3 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb74af4a8</span>)
index3 <span style="color: #555555;">=</span> Map<span style="color: #555555;">.</span>getindex(map3, <span style="color: #CC3300;">"c"</span>)
guard(index3 <span style="color: #555555;">==</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>)
cls2 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>cls
guard(cls2 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb7aaaaf8</span>)
version2 <span style="color: #555555;">=</span> cls2<span style="color: #555555;">.</span>version
guard(version2 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb7bbbb18</span>)
result3 <span style="color: #555555;">=</span> Class<span style="color: #555555;">.</span>_find_method(cls, <span style="color: #CC3300;">"c"</span>, version2)
guard(result3 <span style="color: #000000; font-weight: bold;">is</span> <span style="color: #000000; font-weight: bold;">not</span> <span style="color: #336666;">None</span>)

v4 <span style="color: #555555;">=</span> v2 <span style="color: #555555;">+</span> result3
<span style="color: #006699; font-weight: bold;">return</span>(v4)
</pre></div>
<p>The calls to <tt class="docutils literal">Class._find_method</tt> can now be optimized away, also the
promotion of the class and the version, except for the first one. The final
optimized trace looks like this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #0099FF; font-style: italic;"># inst.getattr("a")</span>
map1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>map
guard(map1 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb74af4a8</span>)
storage1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>storage
result1 <span style="color: #555555;">=</span> storage1[<span style="color: #FF6600;">0</span>]

<span style="color: #0099FF; font-style: italic;"># inst.getattr("b")</span>
cls1 <span style="color: #555555;">=</span> inst<span style="color: #555555;">.</span>cls
guard(cls1 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb7aaaaf8</span>)
version1 <span style="color: #555555;">=</span> cls1<span style="color: #555555;">.</span>version
guard(version1 <span style="color: #555555;">==</span> <span style="color: #FF6600;">0xb7bbbb18</span>)
v2 <span style="color: #555555;">=</span> result1 <span style="color: #555555;">+</span> <span style="color: #FF6600;">41</span>

<span style="color: #0099FF; font-style: italic;"># inst.getattr("c")</span>
v4 <span style="color: #555555;">=</span> v2 <span style="color: #555555;">+</span> <span style="color: #FF6600;">17</span>
<span style="color: #006699; font-weight: bold;">return</span>(v4)
</pre></div>
<p>The constants <tt class="docutils literal">41</tt> and <tt class="docutils literal">17</tt> are the results of the folding of the
<cite>_find_method`</cite> calls. This final trace is now very good. It no longer performs any
dictionary lookups. Instead it contains several guards. The first guard
checks that the map is still the same. This guard will fail if the same
code is executed with an instance that has another layout. The second guard
checks that the class of <tt class="docutils literal">inst</tt> is still the same. It will fail if trace is
executed with an instance of another class. The third guard checks that the
class did not change since the trace was produced. It will fail if somebody
calls the <tt class="docutils literal">change_method</tt> method on the class.</p>
</div>
<div class="section" id="real-world-considerations">
<h2>Real-World Considerations</h2>
<p>The techniques used above for the simple object model are used for the object
model of PyPy's Python interpreter too. Since Python's object model is
considerably more complex, some additional work needs to be done.</p>
<p>The first problem that needs to be solved is that Python supports (multiple)
inheritance. Therefore looking up a method in a class needs to consider the
whole method resolution order. This makes the versioning of classes more
complex. If a class is changed its version changes. At the same time, the
versions of all the classes inheriting from it need to be changed as well,
recursively. This makes class changes expensive, but they should be rare.  On the
other hand, a method lookup in a complex class hierarchy is as optimized in the
trace as in our object model here.</p>
<p>A downside of the versioning of classes that we haven't yet fixed in PyPy, is
that some classes <em>do</em> change a lot. An example would be a class that keeps a
counter of how many instances have been created so far. This is very slow right
now, but we have ideas about how to fix it in the future.</p>
<p>Another optimization is that in practice the shape of an instance is correlated
with its class. In our code above, we allow both to vary independently.
In PyPy's Python interpreter we act somewhat more cleverly. The class of
an instance is not stored on the instance itself, but on the map. This means
that we get one fewer promotion (and thus one fewer guard) in the trace, because the class doesn't need to
be promoted after the map has been.</p>
</div>
<div class="section" id="more-general-patterns">
<h2>More General Patterns</h2>
<p>The techniques we used above to make instance and class lookups faster are
applicable in more general cases than the one we developed them for. A more
abstract view of maps is that of splitting a data-structure into a part that
changes slowly, and a part that changes quickly. In the concrete example of maps
we split the original dictionary into the map (the slow-changing part) and the
storage array (the quick-changing part). All the computation on the
slow-changing part can be constant-folded during tracing so that only the
manipulation of the quick-changing part remains.</p>
<p>Similarly, versions can be used to constant-fold arbitrary functions of large data
structures. The version needs to be updated carefully every time the result of
this function can change. Therefore this is useful only if the data structure is
expected to change slowly.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>In this post I showed how to use <tt class="docutils literal">purefunction</tt> and <tt class="docutils literal">promote</tt> to make a
small but still relevant dynamic object model no longer use any dictionary lookups
after tracing. Instead a number of guards are inserted into the
trace to check whether the assumptions about the objects are still true. This
makes operations on objects seriously faster. I plan to write <a href="../posts/2011/03/controlling-tracing-of-interpreter-with_26-3072929156700508140.html">another small post</a>
that shows the speed benefits for PyPy's Python interpreter for exactly these
operations.</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-1018061820458744331">
        <div class="comment-header">
          <a name="comment-1018061820458744331"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-03-21 19:33</span>:
        </div>
        <div class="comment-content">
          <p>Very clever indeed.<br>I think and additional speedup can be achieved<br>by using a technique from smalltalk intrepters:  Method lookup cache.<br>The cache is organized so that function<br>cache(class, method) returns a pointer to the method.<br>The early Smalltalk implementors reported pretty spectacular speedups when this cache was implemented.</p>
        </div>
      </div>
      <div class="comment comment-4106728624102302437">
        <div class="comment-header">
          <a name="comment-4106728624102302437"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-03-21 20:03</span>:
        </div>
        <div class="comment-content">
          <p>SO MUCH AWESOME.</p>
        </div>
      </div>
      <div class="comment comment-3747063490479041740">
        <div class="comment-header">
          <a name="comment-3747063490479041740"></a>
            <span class="author">RonnyPfannschmidt</span> wrote on <span class="date">2011-03-21 22:07</span>:
        </div>
        <div class="comment-content">
          <p>@vadiml: the jit+version tags already acts as method lookup cache for jited code<br>it basically inlines lookup(class, method)</p>
        </div>
      </div>
      <div class="comment comment-3902434886671367226">
        <div class="comment-header">
          <a name="comment-3902434886671367226"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-03-22 07:46</span>:
        </div>
        <div class="comment-content">
          <p>@RonnyPfannschmidt:  thinking more about it<br>yes, you're right of course</p>
        </div>
      </div>
      <div class="comment comment-816066422430586309">
        <div class="comment-header">
          <a name="comment-816066422430586309"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-03-23 18:37</span>:
        </div>
        <div class="comment-content">
          <p>I'm wondering about VersionTag().  The guard you've shown looks at its memory address.  Doesn't PyPy use compacting garbage collectors?  I seem to recall that from earlier posts about the cost of id().</p>
        </div>
      </div>
      <div class="comment comment-5816280209438834778">
        <div class="comment-header">
          <a name="comment-5816280209438834778"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-03-23 20:23</span>:
        </div>
        <div class="comment-content">
          <p>Hmm. And now I think I know why twisted isn't any faster in pypy. I remember looking at the source a few years ago and being horrified to see that they were changing class methods during runtime. I guessed to avoid one layer of dispatch in state machines. Anyway, it's an "optimisation" that will hurt pypy.</p>
        </div>
      </div>
      <div class="comment comment-4724970959292917104">
        <div class="comment-header">
          <a name="comment-4724970959292917104"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-24 09:11</span>:
        </div>
        <div class="comment-content">
          <p>@Marius: You are right. The trace is a bit simplified, in practice there is an indirection so that if the GC moves the object, the trace still works.<br><br>@Anonymous: can you find that place in twisted? would be very interesting to see. Also it probably means we should implement these ideas about making changing classes not quite so inefficient.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/03/controlling-tracing-of-interpreter-with_15-3281215865169782921.html" class="u-url">Controlling the Tracing of an Interpreter With Hints, Part 2: Controlling Optimization</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/03/controlling-tracing-of-interpreter-with_15-3281215865169782921.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-03-15T16:37:00Z" itemprop="datePublished" title="2011-03-15 16:37">2011-03-15 16:37</time></a>
            </p>
                <p class="commentline">2 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>This is part 2 of a series on how to speed up an interpreter written with PyPy
by adding JIT hints to the interpreter. Part 1 described how to <a class="reference external" href="../posts/2011/03/controlling-tracing-of-interpreter-with-871085470935630424.html">control the
extent of tracing</a>. In this post I will describe how to add hints that
influence the optimizer.  If applied correctly these techniques can give
really big speedups by pre-computing parts of what happens at runtime. On the other
hand, if applied incorrectly they might lead to code bloat, thus making the
resulting program actually slower.</p>
<div class="section" id="background">
<h2>Background</h2>
<p>Before sending the trace to the backend to produce actual machine code, it is
optimized.  The optimizer applies a number of techniques to remove or reduce
the number of operations: most of these are well known <a class="reference external" href="https://en.wikipedia.org/wiki/Compiler_optimization#Optimization_techniques">compiler optimization
techniques</a>, with the difference that it is easier to apply them in a tracing
JIT because it only has to deal with linear traces.  Among the techniques:</p>
<ul class="simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Constant_folding">constant folding</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Common_subexpression_elimination">common subexpression elimination</a></li>
<li>allocation removal, as described in the paper that I recently <a class="reference external" href="../posts/2011/03/us-trip-report-popl-microsoft-ibm-3874568000250679204.html">presented at
PEPM</a>
</li>
<li>store/load propagation</li>
<li><a class="reference external" href="../posts/2011/01/loop-invariant-code-motion-1998392217676829154.html">loop invariant code motion</a></li>
</ul>
<p>In some places it turns out that if the interpreter author rewrites some parts
of the interpreter with these optimizations in mind the traces that are produced
by the optimizer can be vastly improved.</p>
<p>In this post I will describe two hints that allow the interpreter author to
increase the optimization opportunities for constant folding. For constant
folding to work, two conditions need
to be met:</p>
<ul class="simple">
<li>the arguments of an operation actually need to all be constant,
i.e. statically known by the optimizer</li>
<li>the operation needs to be <em>pure</em>, i.e. always yield the same result given
the same arguments.</li>
</ul>
<p>The PyPy JIT generator automatically detects the majority of these conditions.
However, for the cases in which the automatic detection does not work, the
interpreter author can apply <strong>hints</strong> to improve the optimization
opportunities. There is one kind of hint for both of the conditions above.</p>
<p><strong>Note</strong>: These hints are written by an interpreter developer and applied to the
RPython source of the interpreter. Normal Python users will never see them.</p>
</div>
<div class="section" id="where-do-all-the-constants-come-from">
<h2>Where Do All the Constants Come From</h2>
<p>It is worth clarifying what is a "constant" in this context.  A variable of
the trace is said to be constant if its value is statically known by the
optimizer.</p>
<p>The simplest example of constants are literal values.  For example, if in the
RPython source code we have a line like <tt class="docutils literal">y = x + 1</tt>, the second operand will
be a constant in the trace.</p>
<p>However, the optimizer can statically know the value of a variable even if it
is not a constant in the original source code. For example, consider the
following fragment of RPython code:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">if</span> x <span style="color: #555555;">==</span> <span style="color: #FF6600;">4</span>:
    y <span style="color: #555555;">=</span> y <span style="color: #555555;">+</span> x
</pre></div>
<p>If the fragment is traced with <tt class="docutils literal">x</tt> being <tt class="docutils literal">4</tt>, the following trace is
produced:</p>
<pre class="literal-block">
guard(x == 4)
y = y + x
</pre>
<p>In the trace above, the value of <tt class="docutils literal">x</tt> is statically known thanks to the
guard. Remember that a guard is a runtime check. The above trace will run to
completion when <tt class="docutils literal">x == 4</tt>. If the check fails, execution of the trace is
stopped and the interpreter continues to run.</p>
<p>There are cases in which it is useful to turn an arbitrary variable
into a constant value. This process is called <em>promotion</em> and it is an old idea
in partial evaluation (it's called "the trick" there). Promotion is also heavily
used by <a class="reference external" href="https://psyco.sourceforge.net/">Psyco</a> and by all older versions of PyPy's JIT. Promotion is a technique
that only works well in JIT compilers, in
static compilers it is significantly less applicable.</p>
<p>Promotion is essentially a tool for trace specialization. In some places in the
interpreter it would be very useful if a variable were constant, even though it
could have different values in practice. In such a place, promotion is used. The
typical reason to do that is if there is
a lot of computation depending on the value of that variable.</p>
<p>Let's make this more concrete. If we trace a call to the following function:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">f1</span>(x, y):
    z <span style="color: #555555;">=</span> x <span style="color: #555555;">*</span> <span style="color: #FF6600;">2</span> <span style="color: #555555;">+</span> <span style="color: #FF6600;">1</span>
    <span style="color: #006699; font-weight: bold;">return</span> z <span style="color: #555555;">+</span> y
</pre></div>
<p>We get a trace that looks like this:</p>
<pre class="literal-block">
v1 = x * 2
z = v1 + 1
v2 = z + y
return(v2)
</pre>
<p>Observe how the first two operations could be constant-folded if the value of
<tt class="docutils literal">x</tt> were known. Let's assume that the value of <tt class="docutils literal">x</tt> can vary, but does so
rarely, i.e. only takes a few different values at runtime. If this is the
case, we can add a hint to promote <tt class="docutils literal">x</tt>, like this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">f2</span>(x, y):
    x <span style="color: #555555;">=</span> hint(x, promote<span style="color: #555555;">=</span><span style="color: #336666;">True</span>)
    z <span style="color: #555555;">=</span> x <span style="color: #555555;">*</span> <span style="color: #FF6600;">2</span> <span style="color: #555555;">+</span> <span style="color: #FF6600;">1</span>
    <span style="color: #006699; font-weight: bold;">return</span> z <span style="color: #555555;">+</span> y
</pre></div>
<p>The meaning of this hint is that the tracer should pretend that <tt class="docutils literal">x</tt> is a
constant
in the code that follows. When just running the code, the function has no
effect, as it simply returns its first argument. When tracing, some extra work
is done. Let's assume that this changed function is traced with
the arguments <tt class="docutils literal">4</tt> and <tt class="docutils literal">8</tt>. The trace will be the same, except for one
operation at the beginning:</p>
<pre class="literal-block">
guard(x == 4)
v1 = x * 2
z = v1 + 1
v2 = z + y
return(v2)
</pre>
<p>The promotion is turned into a <tt class="docutils literal">guard</tt> operation in the trace. The guard
captures the value of <tt class="docutils literal">x</tt> as it was at runtime. From the point of view of the
optimizer, this guard is not any different than the one produced by the <tt class="docutils literal">if</tt>
statement in the example above. After the guard, the rest of the trace can
assume that <tt class="docutils literal">x</tt> is equal to <tt class="docutils literal">4</tt>, meaning that the optimizer will turn this
trace into:</p>
<pre class="literal-block">
guard(x == 4)
v2 = 9 + y
return(v2)
</pre>
<p>Notice how the first two arithmetic operations were constant folded. The hope is
that the guard is executed quicker than the multiplication and the addition that
was now optimized away.</p>
<p>If this trace is executed with values of <tt class="docutils literal">x</tt> other than <tt class="docutils literal">4</tt>, the guard will
fail, and execution will continue in the interpreter. If the guard fails often
enough, a new trace will be started from the guard. This other trace will
capture a different value of <tt class="docutils literal">x</tt>. If it is e.g. <tt class="docutils literal">2</tt>, then the optimized
trace looks like this:</p>
<pre class="literal-block">
guard(x == 2)
v2 = 5 + y
return(v2)
</pre>
<p>This new trace will be attached to the guard instruction of the first trace. If
<tt class="docutils literal">x</tt> takes on even more values, a new trace will eventually be made for all of them,
linking them into a chain. This is clearly not desirable, so we should promote
only variables that don't vary much. However, adding a promotion hint will never produce wrong
results. It might just lead to too much assembler code.</p>
<p>Promoting integers, as in the examples above, is not used that often.
However, the internals of dynamic language interpreters often
have values that are variable but vary little in the context of parts of a user
program. An example would be the types of variables in a user function. Even
though in principle the argument to a Python function could be any Python type,
in practise the argument types tend to not vary much. Therefore it is possible to
promote the types. In the next blog post I will give a complete example for how
this works.</p>
</div>
<div class="section" id="declaring-new-pure-operations">
<h2>Declaring New Pure Operations</h2>
<p>In the last section we saw a way to turn arbitrary variables into constants. All
pure operations on these constants can be constant-folded. This works great for
constant folding of simple types, e.g. integers. Unfortunately, in the context of an
interpreter for a dynamic
language, most operations actually manipulate objects, not simple types. The
operations on objects are often not pure and might even have side-effects. If
one reads a field out of a constant reference to an object this cannot
necessarily be folded away because the object can be mutated. Therefore, another
hint is needed.</p>
<p>As an example, take the following class:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">A</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, x, y):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>x <span style="color: #555555;">=</span> x
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>y <span style="color: #555555;">=</span> y

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">f</span>(<span style="color: #336666;">self</span>, val):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>y <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>compute() <span style="color: #555555;">+</span> val

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">compute</span>(<span style="color: #336666;">self</span>):
        <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>x <span style="color: #555555;">*</span> <span style="color: #FF6600;">2</span> <span style="color: #555555;">+</span> <span style="color: #FF6600;">1</span>
</pre></div>
<p>Tracing the call <tt class="docutils literal">a.f(10)</tt> of some instance of <tt class="docutils literal">A</tt> yields the following
trace (note how the call to <tt class="docutils literal">compute</tt> is inlined):</p>
<pre class="literal-block">
x = a.x
v1 = x * 2
v2 = v1 + 1
v3 = v2 + val
a.y = v3
</pre>
<p>In this case, adding a promote of <tt class="docutils literal">self</tt> in the <tt class="docutils literal">f</tt> method to get rid of the
computation of the first few operations does not help. Even if <tt class="docutils literal">a</tt> is a
constant reference to an object, reading the <tt class="docutils literal">x</tt> field does not necessarily
always yield the same value. To solve this problem, there is another annotation,
which lets the interpreter author communicate invariants to the optimizer. In
this case, she could decide that the <tt class="docutils literal">x</tt> field of instances of <tt class="docutils literal">A</tt> is
immutable, and therefore <tt class="docutils literal">compute</tt>
is a pure function. To communicate this, there is a <tt class="docutils literal">purefunction</tt> decorator.
If the code in <tt class="docutils literal">compute</tt> should be constant-folded away, we would change the
class as follows:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">A</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, x, y):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>x <span style="color: #555555;">=</span> x
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>y <span style="color: #555555;">=</span> y

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">f</span>(<span style="color: #336666;">self</span>, val):
        <span style="color: #336666;">self</span> <span style="color: #555555;">=</span> hint(<span style="color: #336666;">self</span>, promote<span style="color: #555555;">=</span><span style="color: #336666;">True</span>)
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>y <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>compute() <span style="color: #555555;">+</span> val

    <span style="color: #9999FF;">@purefunction</span>
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">compute</span>(<span style="color: #336666;">self</span>):
        <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>x <span style="color: #555555;">*</span> <span style="color: #FF6600;">2</span> <span style="color: #555555;">+</span> <span style="color: #FF6600;">1</span>
</pre></div>
<p>Now the trace will look like this:</p>
<pre class="literal-block">
guard(a == 0xb73984a8)
v1 = compute(a)
v2 = v1 + val
a.y = v2
</pre>
<p>Here, <tt class="docutils literal">0xb73984a8</tt> is the address of the instance of <tt class="docutils literal">A</tt> that was used
during tracing. The call to <tt class="docutils literal">compute</tt> is not inlined, so that the optimizer
has a chance to see it. Since <tt class="docutils literal">compute</tt> function is marked as pure, and its
argument
is a constant reference, the call will be removed by the optimizer. The final
trace looks like this:</p>
<pre class="literal-block">
guard(a == 0xb73984a8)
v2 = 9 + val
a.y = v2
</pre>
<p>(assuming that the <tt class="docutils literal">x</tt> field's value is <tt class="docutils literal">4</tt>).</p>
<p>On the one hand, the <tt class="docutils literal">purefunction</tt> annotation is very powerful. It can be
used to constant-fold arbitrary parts of the computation in the interpreter.
However, the annotation also gives you ample opportunity to mess things up. If a
function is annotated to be pure, but is not really, the optimizer can produce
subtly wrong code. Therefore, a lot of care has to be taken when using this
annotation.</p>
<div class="section" id="observably-pure-functions">
<h3>Observably Pure Functions</h3>
<p>Why can't we simply write an analysis to find out that the <tt class="docutils literal">x</tt> fields of the
<tt class="docutils literal">A</tt> instances is immutable and deduce that <tt class="docutils literal">compute</tt> is a pure function,
since it only reads the <tt class="docutils literal">x</tt> field and does not have side effects? This might
be possible in this particular case, but in practice the functions that are
annotate with the <tt class="docutils literal">purefunction</tt> decorator are usually more complex.
The easiest example for this is that of a function that uses memoization to
cache its results. If you analyze this function, it looks like the function has
side effects, because it changes the memoizing dictionary. However, because this side
effect is not externally visible, the function from the outside is pure. This is
a property that is not easily detectable by analysis. Therefore, the purity
of this function needs to be annotated.</p>
</div>
<div class="section" id="immutable-fields">
<h3>Immutable Fields</h3>
<p>One of the most common cases of pure functions is reading immutable
values out of objects. Since this is so common, we have special syntactic sugar
for it. A RPython class can have a class attribute <tt class="docutils literal">_immutable_fields_</tt> set to
a list of strings, listing the fields that cannot be changed. This is equivalent
to using getters and annotating them with <tt class="docutils literal">purefunction</tt>.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>In this blog post I explained two more hints that can be used in the source code
of the interpreter. They are used to influence what the optimizer does with the
trace. I realize the examples given here are a bit too small, in the <a href="../posts/2011/03/controlling-tracing-of-interpreter-with_21-6524148550848694588.html">next
installment</a> I will give a worked-out example that puts all the pieces together.</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-7994399869313286287">
        <div class="comment-header">
          <a name="comment-7994399869313286287"></a>
            <span class="author">GaÃ«tan de Menten</span> wrote on <span class="date">2011-03-16 10:56</span>:
        </div>
        <div class="comment-content">
          <p>Again a very interesting post. I would like some precisions for one sentence:<br>"If x takes on even more values, a new trace will eventually be made for all of them, linking them into a chain."<br><br>Does it mean they are all tried in sequence, or is there some dispatch mechanism? If there isn't, wouldn't it be beneficial to have one in place (probably using a hash table of some sort) when there is more than a few values? Or is the number of "generated branches" never supposed to be large enough to make such an approach worthwile?</p>
        </div>
      </div>
      <div class="comment comment-4091850799633454544">
        <div class="comment-header">
          <a name="comment-4091850799633454544"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-16 12:27</span>:
        </div>
        <div class="comment-content">
          <p>@GaÃ«tan:<br><br>Right now it's just a linear search always, which is clearly not ideal and we might very well fix this in the future. Currently we have the hope that in practice the number of values is always small, but we never measured.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/03/controlling-tracing-of-interpreter-with-871085470935630424.html" class="u-url">Controlling the Tracing of an Interpreter With Hints, Part 1: Controlling the Extent of Tracing</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/03/controlling-tracing-of-interpreter-with-871085470935630424.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-03-12T18:25:00Z" itemprop="datePublished" title="2011-03-12 18:25">2011-03-12 18:25</time></a>
            </p>
                <p class="commentline">11 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>The question I was asked most often during my recent <a class="reference external" href="../posts/2011/03/us-trip-report-popl-microsoft-ibm-3874568000250679204.html">US trip</a> was how exactly
the hints work that interpreter authors can use to improve the execution speed
of the programs running on their interpreters. Since those hints are not really
documented all that well, I decided to write blog posts about them. This is the
first one.</p>
<div class="section" id="background">
<h2>Background</h2>
<p>First, let's recap some basics: PyPy's approach to implementing dynamic
languages is to write an interpreter for
the language in RPython. This interpreter can be translated to C and then
further to machine code. The interpreter consists of code in the form of a
large number of generated C functions and some data. Similarly, the user
program consists of functions in the language the interpreter executes.</p>
<p>As was explained in a <a class="reference external" href="../posts/2009/03/applying-tracing-jit-to-interpreter-3287844903778799266.html">blog post</a> and a <a class="reference external" href="https://codespeak.net/svn/pypy/extradoc/talk/icooolps2009/bolz-tracing-jit.pdf">paper</a> two years ago, PyPy's JIT is a
meta-tracer. Since we want to re-use our tracer for a variety of languages, we
don't trace the execution of the user program, but instead trace the execution
of the <em>interpreter</em> that is running the program. This means that the traces
don't contain the bytecodes of the language in question, but RPython-level
operations that the interpreter did to execute the program.</p>
<p>On the other hand, the loops that are traced by the tracer are the loops in the
user program. This means that the tracer stops tracing after one iteration of
the loop in the user function that is being considered. At this point, it can
have traced many iterations of the interpreter main loop.</p>
<p>Here's a diagram of this process:</p>

<a href="https://3.bp.blogspot.com/-YUYgnZkPta8/TXu694dW9bI/AAAAAAAAAPY/VOCWosHnXCM/s1600/trace-levels.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5583261735346173362" src="https://3.bp.blogspot.com/-YUYgnZkPta8/TXu694dW9bI/AAAAAAAAAPY/VOCWosHnXCM/s600/trace-levels.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand;"></a>

<p>On the left you see the levels of execution. The CPU executes the binary of
PyPy's Python interpreter, which consists of RPython functions that have been
compiled first to C, then to machine code. Some of these functions contain
loops, others don't. The interpreter runs a Python program written by a
programmer (the user). If the tracer is used, it traces operations on the level
of the interpreter. However, the extent of the trace is determined by the loops
in the user program.</p>
</div>
<div class="section" id="how-far-should-tracing-go">
<h2>How Far Should Tracing Go</h2>
<p>When the tracer encounters a function call at the interpreter level, e.g. the
interpreter main loop calling a helper function, it can do one of two things:</p>
<ol class="arabic simple">
<li>it can trace into the helper function, effectively inlining it into the trace.</li>
<li>it can not trace into the function and instead record a call to that function
as an operation in the trace. Such a call operation in the trace is sometimes
called <em>residual call</em>.</li>
</ol>
<p>As a default, the tracer will try to trace into the helper because that will
give more information to the optimizer, allowing it to do a better job. This is
particularly important for the allocation removal optimization, because if a
freshly allocated object is passed as an argument to a residual call, its
allocation cannot be optimized away.</p>
<p>There is a problem however if the helper function itself contains a loop. The
tracer records the linear sequence of operations that are being executed. Thus
when it encounters a loop on the interpreter level it records all the
operations of every iteration of the loop itself, with the net effect of
unrolling it. The only places where the tracer stops and tries to close the
trace is in the main loop of the interpreter. When the tracer encounters the
main loop, it also checks whether the original user loop has been closed, and
thus whether it can stop tracing.</p>
<p>For most helper functions in the interpreter that contain loops, fully
unrolling does not make sense. If a loop is unrolled, the trace is specific to
the number of iteration that was seen during tracing. If the trace is later
executed with a different number of iterations, the trace will be left via a
guard failure, which is inefficient. Therefore the default behaviour of the
tracer is to never trace into a function on the interpreter level that contains
a loop, but to trace into all non-looping helper functions.</p>
<p>This default behaviour is essentially a heuristic, but one that usually makes
sense. We want to produce just enough traces to make the resulting code
efficient, but not more. Therefore we trace as much as possible (everything by
default) except the functions which loops where tracing would produce code that
is less general than it could be.</p>
<p>As an example for a helper with a loop, take string concatenation. It loops over
the characters of both arguments and copies them over into the result string. It
does not make sense to unroll the loops in this function. If we do that,
the resulting trace can only be used for strings of the length that was seen
during tracing. In practise, the string lengths are usually different each run,
meaning that the trace with unrolling is not run to completion in most cases.</p>
</div>
<div class="section" id="influencing-the-default-behaviour">
<h2>Influencing the Default Behaviour</h2>
<p>Sometimes the default behaviour is not actually what is wanted. This is
something the interpreter author has to decide, usually by looking at the traces
that are produced and deciding that they should be improved. There are two ways
in which the default is wrong:</p>
<ul class="simple">
<li>
<strong>false negatives:</strong> if a helper function that <strong>does</strong> contain a loop should
be traced into, unrolling the loop.</li>
<li>
<strong>false positives:</strong> if a helper function that <strong>does not</strong> contain a loop is
inlined into the trace, but the interpreter author decides that this is not
helpful.</li>
</ul>
<p>If the interpreter author finds false negatives or false positives, she can fix
that by applying a hint to the tracer. These hints take the form of function
decorators (which both live in the <tt class="docutils literal">pypy.rlib.jit</tt> module). In the next two
subsections I will describe these two function decorators and their use.</p>
<div class="section" id="unrolling-functions-with-loops">
<h3>Unrolling Functions With Loops</h3>
<p>The first decorator, used to fix false negatives, is the <tt class="docutils literal">unroll_safe</tt>
decorator. It is used to tell the tracer to always trace into a function that
has a loop, effectively unrolling the loop. This decorator should be used only
if the loop in the helper function is expected to always run for the same number
of iterations. This sounds like a strong restriction, in practise this is less
severe: The number of iterations needs to only be the same <em>in the context where
the helper functions is traced from</em>.</p>
<p>It is easiest to understand this condition via an example. Let's look at the
<tt class="docutils literal">BUILD_TUPLE</tt> bytecode in Python. It takes one argument, the length <tt class="docutils literal">n</tt> of
the tuple being built. The bytecode pops <tt class="docutils literal">n</tt> arguments from the stack, turns
them into a tuple and pushes that tuple on the stack. Thus the function that
implements <tt class="docutils literal">BUILD_TUPLE</tt> in PyPy's Python interpreter calls a helper
<tt class="docutils literal">popvalues</tt> which pops <tt class="docutils literal">n</tt> values from the stack and returns them in a list.
This helper is implemented with a loop and would thus not be traced into by
default.  The loop in the helper can run for very different numbers of
iterations, because it is used in a variety of places. However, for every
concrete <tt class="docutils literal">BUILD_TUPLE</tt> bytecode, the argument will be constant. Therefore it
is safe (and even necessary) to annotate <tt class="docutils literal">popvalues</tt> with the <tt class="docutils literal">unroll_safe</tt>
decorator.</p>
<p>A different example is the implementation of the <tt class="docutils literal">isinstance</tt> builtin. It is
used to check whether an object <tt class="docutils literal">a</tt> is an instance of a class <tt class="docutils literal">B</tt> like
this: <tt class="docutils literal">isinstance(a, B)</tt>. The second argument of the function can also be a
tuple of classes to check whether an object is an instance of one of a number of
classes: <tt class="docutils literal">isinstance(a, (A, B, C, D))</tt>. To implement this second case, the
implementation of <tt class="docutils literal">isinstance</tt> contains a loop iterating over the elements of
the tuple. The number of loop iterations can vary, but is usually fixed for each
individual call site which typically just lists a few classes in the source
code. Therefore it is also safe to annotate the implementation of <tt class="docutils literal">isinstance</tt>
with the <tt class="docutils literal">unroll_safe</tt> decorator.</p>
</div>
<div class="section" id="preventing-the-tracing-of-functions">
<h3>Preventing the Tracing of Functions</h3>
<p>The second decorator <tt class="docutils literal">dont_look_inside</tt> is used to fix false positives. It
tells the JIT to never trace into the decorated function and just always produce
a residual call instead. This decorator is in many ways less important than the
unrolling one (except for a special situation that I will describe in a
follow-up post). It is used if tracing into a function is not expected to yield
any speed benefits, because the optimizer will not be able to improve it much.
This is often the case if the called helper function does not contain any
"dynamic" behaviour. In such a situation it is better to just leave the function
call in the trace, because that produces less code.</p>
<p>An example would be the import mechanism in Python. It's very unlikely that any
performance improvement can be had by turning part of it into assembler.
Therefore we hide it from the tracer by annotating them with
<tt class="docutils literal">dont_look_inside</tt>.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>In this post we discussed two hints that can be used to control precisely which
parts of the interpreter should be meta-traced. If these hints are used
carefully, this can go a long way to making the interpreter produce traces that
contain exactly the interesting part of the execution, and will contain calls to
the functions that can not be optimized by tracing techniques.</p>
<p>In the <a href="../posts/2011/03/controlling-tracing-of-interpreter-with_15-3281215865169782921.html">next part of this series</a> I will discuss a different set of hints that can
be used to strongly optimize traces.</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-8326070612955967399">
        <div class="comment-header">
          <a name="comment-8326070612955967399"></a>
            <span class="author">Victor</span> wrote on <span class="date">2011-03-12 21:28</span>:
        </div>
        <div class="comment-content">
          <p>Would it be possible (i.e. is the code amenable) to programmatically randomly sprinkle these decorators around and compare effects on speed (or on measurable trace quality)?<br><br>It would make JIT generation a bit more meta :)</p>
        </div>
      </div>
      <div class="comment comment-4363661425795501150">
        <div class="comment-header">
          <a name="comment-4363661425795501150"></a>
            <span class="author">GaÃ«tan de Menten</span> wrote on <span class="date">2011-03-13 10:42</span>:
        </div>
        <div class="comment-content">
          <p>Thanks for the very interesting post!<br><br>Sorry if the following questions are naive, but you post makes me wonder if not tracing at all the functions which contain loops with a varying number of iteration means that no optimization is possible at all for those loops? Also, wouldn't it be possible to detect there is a loop and produce a special kind of trace in that case which do not duplicate the body of the loop? I guess that if it was possible and useful, you'd have done it, so I guess the real question is: why doesn't this work?</p>
        </div>
      </div>
      <div class="comment comment-1727117587162670099">
        <div class="comment-header">
          <a name="comment-1727117587162670099"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-14 09:54</span>:
        </div>
        <div class="comment-content">
          <p>@Victor: yes, there are probably ways to do place some of the hints more automatically. However, you will always have to look at the traces and think about how to improve them, so we chose the pragmatic path and didn't do anything magic.</p>
        </div>
      </div>
      <div class="comment comment-1689979069960067279">
        <div class="comment-header">
          <a name="comment-1689979069960067279"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-14 10:02</span>:
        </div>
        <div class="comment-content">
          <p>@GaÃ«tan: those are excellent questions!<br><br>Yes, functions in the interpreter with loops that we do not trace are not optimized at all. For most of these functions this is not a problem, e.g. string concatenation does not have much optimization potential anyway. However, there are some functions with loops (like the implementation of the map builtin) that would benefit from tracing, and we don't have a good general solution for that yet.<br><br>One of the ideas for solutions are indeed to try to start new traces in the interpreter functions with loops. We did not get around to playing with this yet, as there are not so many cases in the Python interpreter where this leads to a huge benefit.</p>
        </div>
      </div>
      <div class="comment comment-965537567419824717">
        <div class="comment-header">
          <a name="comment-965537567419824717"></a>
            <span class="author">GaÃ«tan de Menten</span> wrote on <span class="date">2011-03-14 13:50</span>:
        </div>
        <div class="comment-content">
          <p>I'm puzzled now. I fail to see why those loops "do not have much optimization potential". I can understand that it's hard to optimize them because of the trace problem but I thought they would benefit from optimization like any other code (eg avoiding boxing/unboxing temporary variables), especially since they are within a loop, hence any gain will be multiplied by the number of iterations.</p>
        </div>
      </div>
      <div class="comment comment-2464670344307874252">
        <div class="comment-header">
          <a name="comment-2464670344307874252"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-14 14:01</span>:
        </div>
        <div class="comment-content">
          <p>@GaÃ«tan:<br>is it possible that you are mixing up the two levels involved? The post talked only about functions in the interpreter, not about the functions in pure Python that a user of the interpreter might write. To clarify:<br><br>- All loops on the application level, i.e. in the program the user wrote, are traceable and will be traced if they are executed often enough.<br><br>- Some loops in the interpreter itself are not. Most of these loops do not do any boxing/unboxing, so they won't benefit from optimization. For some of the loops that would benefit we added some manual hacks to trace them anyway, e.g. for the implementation of "map". Some others still need to be improved, e.g. any, all, zip, ...</p>
        </div>
      </div>
      <div class="comment comment-4933343857625838892">
        <div class="comment-header">
          <a name="comment-4933343857625838892"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-03-15 14:52</span>:
        </div>
        <div class="comment-content">
          <p>Carl, thanks for the post. The information is very helpful.<br><br>While I understand special casing to overwrite the default tracing/not-tracing rules can help performance, I wonder how well are the default heuristics performing. Do you have any bulk part estimation of the performance loss by turning off special casing? And how many hints (related to whether to trace or unroll) do you have to introduce to PyPy?</p>
        </div>
      </div>
      <div class="comment comment-781314709244498950">
        <div class="comment-header">
          <a name="comment-781314709244498950"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-15 16:00</span>:
        </div>
        <div class="comment-content">
          <p>Hi Peng,<br><br>Thanks :-). No, I didn't really do benchmarks yet, plan to do so in the future (these blog posts will turn into a paper soonish).<br><br>There are about 20-30 unroll_safe hints and equally many dont_look_inside hints. Some of them are really important, ie the speed would be abysmal without them. Most of them are really in the bytecode dispatch area, they are cases that e.g. Jython would not have, because in Jython the Python-to-Java compiler takes care of them.</p>
        </div>
      </div>
      <div class="comment comment-8391486534209894437">
        <div class="comment-header">
          <a name="comment-8391486534209894437"></a>
            <span class="author">GaÃ«tan de Menten</span> wrote on <span class="date">2011-03-16 10:45</span>:
        </div>
        <div class="comment-content">
          <p>No, I wasn't confusing the two levels involved (if pypy wasn't optimizing variable-length loops in userlevel code, it wouldn't optimize much I guess). <br><br>My point was more theoretical: I guess that, in theory, those loops would benefit from optimizations like any other part of the interpreter. Your answer leads me to believe that *in practice* this isn't an issue because there are either not that many of them in the interpreter and/or they are not in speed critical parts and most of those that are important speed-wise have been taken care of manually in some way or another.</p>
        </div>
      </div>
      <div class="comment comment-8364446666492635032">
        <div class="comment-header">
          <a name="comment-8364446666492635032"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-16 12:15</span>:
        </div>
        <div class="comment-content">
          <p>@GaÃ«tan: yes, that's a good interpretation. At some point we might still think about a more general solution for this problem, to get the remaining rare cases fixed, but for now we have a lot of the common ones covered.</p>
        </div>
      </div>
      <div class="comment comment-5640768429293734401">
        <div class="comment-header">
          <a name="comment-5640768429293734401"></a>
            <span class="author">Matty</span> wrote on <span class="date">2017-06-07 12:50</span>:
        </div>
        <div class="comment-content">
          <p>@GaÃ«tan<br>Untraceable Interpreter-level loops don't need to be optimized by the jit because they are agressively optimized by the C compiler (remeber that rpython is translated to C)</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/03/bay-area-2011-tour-summary-9117372109664978472.html" class="u-url">Bay Area 2011 Tour Summary</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/03/bay-area-2011-tour-summary-9117372109664978472.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-03-10T23:01:00Z" itemprop="datePublished" title="2011-03-10 23:01">2011-03-10 23:01</time></a>
            </p>
                <p class="commentline">7 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>We spent the week in the San Francisco Bay Area showing off PyPy.
Here are notes and photos of the tour.</p>
<div class="section" id="day-1-google-sf">
<h3>Day 1: Google SF</h3>
<p>Google has offices in downtown San Francisco.  They are at a beautiful
place and the views are spectacular.  We thank Wesley Chun and Guido van
Rossum for organizing this meeting.  Between 25 and 30 engineers showed
up.  Some of them were Python programmers, but others were C++
programmers; and they all seem to have real problems that they want to
solve with PyPy.  We didn't have prepared slides so far, so we mostly
ran demos and talked.  As predicted, Google would love SWIG support.
They suggested that we rename the translation toolchain (as we vaguely
thought too) to separate it more from PyPy's Python interpreter; up
until today, many had no idea that they could use PyPy for other
languages.  All in all, it was very positive and people looked forward
to meeting up at PyCon.</p>
</div>
<div class="section" id="day-2-stanford">
<h3>Day 2: Stanford</h3>

<a href="https://1.bp.blogspot.com/-RKzgLEY5xqQ/TXlY0zNaRBI/AAAAAAAABI4/d63d9FhMO3Q/s1600/stanford.jpg"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5582590877225337874" src="https://1.bp.blogspot.com/-RKzgLEY5xqQ/TXlY0zNaRBI/AAAAAAAABI4/d63d9FhMO3Q/s320/stanford.jpg" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 320px; height: 213px;"></a>


<p>This was the most academically-oriented talk.  You can find the
abstract, the <a class="reference external" href="https://pypy.org/talk/stanford-ee380-2011/talk.html">slides</a> (PgUp/PgDown to navigate) and the video <a class="reference external" href="https://www.stanford.edu/class/ee380/">here</a>.
There were around 35 people in the audience, and maybe 1000 real-time
video watchers (who didn't get to ask questions).  The live audience
seemed to be a mixture of students, professors, and people from the
local industry.  We thank David Allison and Andy Freeman for organizing
it.  It has been two or three years since they invited me (Armin) and I
finally managed to get here <tt class="docutils literal"><span class="pre">:-)</span></tt></p>
<p>The slides are longer than the talk; we focused on the JIT because that
was what the audience was most interested in.  They were really
impressed at the stability, the tests, and that we don't have lots of
bugs reported in the JIT of our latest public release.  We later found
out that many who came to the talk believed that they were going to get
a talk about how we jitted a subset of python because real python is too
hard -- impossible to do.  They came to heckle with examples of how
python was impossible.  So they were amazed when the first slide of
Armin's presentation was "Python is complicated", and the next slide
"Python is messy".  It was a positive outcome.  We made new fans <tt class="docutils literal"><span class="pre">:-)</span></tt></p>
</div>
<div class="section" id="day-3-yelp">
<h3>Day 3: Yelp</h3>


<a href="https://1.bp.blogspot.com/-X7T4FF6I3Gc/TXlY-K0ptnI/AAAAAAAABJA/O48dKSCPlW0/s1600/yelp.jpg"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5582591038182766194" src="https://1.bp.blogspot.com/-X7T4FF6I3Gc/TXlY-K0ptnI/AAAAAAAABJA/O48dKSCPlW0/s320/yelp.jpg" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 320px; height: 213px;"></a>


<p>As you can see in the image, tons of people showed up -- ~140.  Thanks
to Grace Law, who is the coordinator for the SF Python Meet-up, and to
Jimmy Retzlaff and Ashley King-Bishof from Yelp.  Yelp is also located
in downtown San Francisco.  This looks like the place to be if you are a
start-up in California (and not in Silicon Valley): lots of enthusiastic
young people are here, and they are hiring.  Yelp has an enormous open
space, suitable for huge parties, and the coolest beer dispensers on the
planet, made as a hack-a-thon project by three Yelp engineers (pictured
below):</p>




<a href="https://3.bp.blogspot.com/-Kz3CQ_cGrM0/TXlZHu5pF6I/AAAAAAAABJI/AjO3ZrVZ4h8/s1600/beer.jpg"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5582591202486196130" src="https://3.bp.blogspot.com/-Kz3CQ_cGrM0/TXlZHu5pF6I/AAAAAAAABJI/AjO3ZrVZ4h8/s320/beer.jpg" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 320px; height: 213px;"></a>




<p>By the way, their management structure seems to be flat.  There are
almost no line managers, i.e. managers for the engineering staff;
instead they self-organize into teams.  This is not what you expect
for the USA; things appear to have changed a lot.</p>
<p>The <a class="reference external" href="https://foss.heptapod.net/pypy/extradoc/-/blob/branch/default/tip/talk/ustour2011/yelp-talk.html">talk</a> was in two sections, "PyPy from the user's point of view" and
"How the JIT works".  Good feedback; impressed that we support all of
Python 2.7 (including all the modules that are in C in the stdlib), and
impressed that the Python 3.0 conversion is not considered a big deal by
us, although we have no precise date yet.  The plan is, of course, just
to tweak the interpreter until it supports both (by adding the necessary
conditions); the other aspects like GC and the JIT will not be affected
at all.</p>
</div>
<div class="section" id="day-4-dropbox">
<h3>Day 4: Dropbox</h3>

<a href="https://4.bp.blogspot.com/-mGn-RZj__b4/TXlZfqweYhI/AAAAAAAABJQ/9EX0-6Hjhi0/s1600/dropbox.jpg"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5582591613690864146" src="https://4.bp.blogspot.com/-mGn-RZj__b4/TXlZfqweYhI/AAAAAAAABJQ/9EX0-6Hjhi0/s320/dropbox.jpg" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 320px; height: 213px;"></a>





<p>This was another place full of excited, successful young people.  The
CTO looks like he turned 30 last week, and he's been CTO for 4 years
now.  The three of us were quite obviously the oldest people there.  We
felt old.  They have another great big open barn complex. It's
loud. Very loud.  Loud refrigerators, loud street noise, loud machinery
in the walls doing who knows what, loudly.</p>
<p>This was the first tech talk at dropbox.  Thanks to Rian Hunter for
organizing it.  They have a big kitchen, and we held the talk in there.
There was a skylight, which made the room too bright, so harder to read
the slides than would otherwise be the case.  They were jazzed about our
visit, and wanted copies of all the pictures Jacob took before he left.</p>
<p>They seemed familiar with Google V8, and thought that how long it took
to build PyPy was a great incentive for us to make PyPy faster.  They
are very interested in fast ctypes, fast SWIG, fast Cython.  They were
pleased and surprised that we don't have too much JIT bloat (typically
~10% of the total RAM usage).</p>
<p>The mobile developers want a smaller Python more than a faster one.
Python takes too much memory given the tiny amount available on a lot of
cell phones.  Not that we have an answer to this problem now.</p>
<p>They were pleased to learn that we will soon be able to JIT ctypes code.
And the fact that Armin knows many ways to segfault CPython was a bit of
a shock.  We talked for an hour after the presentation.  Again, a very
positive outcome.</p>
</div>
<div class="section" id="days-5-and-6-noisebridge-sprint">
<h3>Days 5 and 6: Noisebridge sprint</h3>

<a href="https://4.bp.blogspot.com/-RbkYn2HjfPE/TXlZpezfZhI/AAAAAAAABJY/cjyEuG1uerE/s1600/noisebridge.jpg"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5582591782280979986" src="https://4.bp.blogspot.com/-RbkYn2HjfPE/TXlZpezfZhI/AAAAAAAABJY/cjyEuG1uerE/s320/noisebridge.jpg" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 320px; height: 213px;"></a>

<p>About six people showed up for the sprint.  (Late.  Californians really
do start the day at 11.)  Noisebridge is a very eclectic place; people
show up to do pretty much everything from sewing to breaking apart
equipment to making robots and beer.  It's donation-driven.  Thanks to
Jim Stockford for volunteering the space and arranging this and helping
us set up for the sprint.</p>
<p>During the sprint, we did a little bit of everything; there was no clear
pattern.  Ademan worked on sqlite, Greg Price looked to see if his
software could run on PyPy, Will worked on the documentation, and a few
of us fixed some more 2.7 tests.  Alex Gaynor and Fijal joined us, too.</p>
</div>
<div class="section" id="day-7-google-mountain-view-and-mozilla">
<h3>Day 7: Google Mountain View and Mozilla</h3>
<p>We gave <a class="reference external" href="https://foss.heptapod.net/pypy/extradoc/-/blob/branch/default/tip/talk/ustour2011/google-talk.pdf">two talks</a> on the 7th day of our trip so we were already quite
exhausted. Fortunately new people joined, so the talks were actually split
between multiple people. We would like to thank Peter Norvig and Ben Bayer
for inviting us to Google and Andreas Gal, Brendan Eich and Dave Herman
for inviting us to Mozilla. Both talks should hopefully appear online
at some point soon, but as of now we don't have a link.</p>
<p>It was pretty incredible to find ourselves at Mozilla talking with at
least 15 people who deeply understood the ideas of tracing JITs and
also understood why we undertook the decision to generate our JIT
instead of writing it. They suffered from having to write JavaScript
JIT (even multiple ones) by hand, as Armin did with Psyco.  He deeply
sympathizes. The discussion afterwards was very successful and we're
looking forward to cooperating with them.  Many exciting things were
discussed as possibilities.</p>
<p>Next day we went to Pycon, which is ongoing and a topic for yet another
blog post.</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-4788014206368115329">
        <div class="comment-header">
          <a name="comment-4788014206368115329"></a>
            <span class="author">Luis</span> wrote on <span class="date">2011-03-11 00:29</span>:
        </div>
        <div class="comment-content">
          <p>Great post, but the links are broken...</p>
        </div>
      </div>
      <div class="comment comment-3602101230953090100">
        <div class="comment-header">
          <a name="comment-3602101230953090100"></a>
            <span class="author">ipc</span> wrote on <span class="date">2011-03-11 11:39</span>:
        </div>
        <div class="comment-content">
          <p>thank you for sharing!  The tour seems like a very good way to draw the attention of a lot of smart and influential people to the fantastic work you've been doing.</p>
        </div>
      </div>
      <div class="comment comment-194879521671468890">
        <div class="comment-header">
          <a name="comment-194879521671468890"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-03-11 14:12</span>:
        </div>
        <div class="comment-content">
          <p>@Luis thanks, fixed I hope. bitbucket is not very good at permalinks and I forgot extradoc has "tip" and not "default"</p>
        </div>
      </div>
      <div class="comment comment-2251619527570237143">
        <div class="comment-header">
          <a name="comment-2251619527570237143"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2011-03-11 15:31</span>:
        </div>
        <div class="comment-content">
          <p>fijal: bitbucket serves html files as binary or something.  This means that at least in Firefox we don't get the "ui" subdirectory, just the raw html.  Annoying.</p>
        </div>
      </div>
      <div class="comment comment-8399886524337352563">
        <div class="comment-header">
          <a name="comment-8399886524337352563"></a>
            <span class="author">Antonio Cuni</span> wrote on <span class="date">2011-03-11 15:38</span>:
        </div>
        <div class="comment-content">
          <p>@armin: I think that bitbucket's choice is the only reasonable one, else it could be probably exploited to do some sort of Cross Side Scripting attack</p>
        </div>
      </div>
      <div class="comment comment-52290111567963707">
        <div class="comment-header">
          <a name="comment-52290111567963707"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-03-11 15:52</span>:
        </div>
        <div class="comment-content">
          <p>Eh. That means we should host them somewhere else I fear.</p>
        </div>
      </div>
      <div class="comment comment-260966464056053544">
        <div class="comment-header">
          <a name="comment-260966464056053544"></a>
            <span class="author">Andreas Mueller</span> wrote on <span class="date">2012-08-16 12:29</span>:
        </div>
        <div class="comment-content">
          <p>The link to the video seems to be broken. At least I can't find the video on the page that is linked to.<br>Could you please check?<br>Thanks,<br>Andy</p>
        </div>
      </div>
         </div>

</div>
</div>
<div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
      <li>
        <a href="/posts/2024/10/jit-peephole-dsl.html" class="listtitle">A DSL for Peephole Transformation Rules of Integer Operations in the PyPy JIT</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (8)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (5)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div></div>
</main>
</div>
<div style="clear: both; width: 75%; margin: 1em auto;">
        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-19.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-17.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
         
                 <footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    Â© 2025 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
    Â 
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
    Â 
    Last built 2025-07-07T11:01
  </div>
  <div style="margin-left: auto">
  <a href="../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../assets/js/styles.js"></script></footer>
</body>
</html>