<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="A Faster Python">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>PyPy (old posts, page 44) | PyPy</title>
<link href="../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../rss.xml">
<link rel="canonical" href="https://www.pypy.org/blog/index-44.html">
<link rel="icon" href="../favicon2.ico" sizes="16x16">
<link rel="icon" href="../favicon32x32.ico" sizes="32x32">
<link rel="prev" href="index-45.html" type="text/html">
<link rel="next" href="index-43.html" type="text/html">
<!--[if lt IE 9]><script src="../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../assets/css/tipuesearch.css">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../index.html">
                    <image id="toplogo" src="../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../compat.html">Compatibility</a> </li>  
                    <li> <a href="../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href=".">Index</a> </li>  
                    <li> <a href="../categories/">Tags</a> </li>  
                    <li> <a href="../archive.html">Archive by year</a> </li>  
                    <li> <a href="../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Search…" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><div class="post">
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2024/07/toy-abstract-interpretation.html" class="u-url">Abstract interpretation in the Toy Optimizer</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/max-bernstein.html">Max Bernstein</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2024/07/toy-abstract-interpretation.html" rel="bookmark">
            <time class="published dt-published" datetime="2024-07-24T14:48:00Z" itemprop="datePublished" title="2024-07-24 14:48">2024-07-24 14:48</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>This is a <a href="https://bernsteinbear.com/blog/toy-abstract-interpretation/" rel="canonical">cross-post</a>
from Max Bernstein from his excellent blog where he writes about programming
languages, compilers, optimizations, virtual machines. He's looking for a
(dynamic language runtime or compiler related) job too.</p>
<hr>
<p>CF Bolz-Tereick wrote some excellent posts in which they <a href="https://pypy.org/posts/2022/07/toy-optimizer.html">introduce a small IR
and optimizer</a> and <a href="https://pypy.org/posts/2022/10/toy-optimizer-allocation-removal.html">extend it with allocation
removal</a>. We also did a live stream together in which
we did <a href="https://www.youtube.com/watch?v=w-UHg0yOPSE">some more heap optimizations</a>.</p>
<p>In this blog post, I'm going to write a small abstract interpreter for the Toy
IR and then show how we can use it to do some simple optimizations. It assumes
that you are familiar with the little IR, which I have reproduced unchanged in
<a href="https://gist.github.com/tekknolagi/4425b28d5267e7bae8b0d7ef8fb4a671">a GitHub Gist</a>.</p>
<p>Abstract interpretation is a general framework for efficiently computing
properties that must be true for all possible executions of a program. It's a
widely used approach both in compiler optimizations as well as offline static
analysis for finding bugs. I'm writing this post to pave the way for CF's next
post on proving abstract interpreters correct for range analysis and known bits
analysis inside PyPy.</p>
<p>Before we begin, I want to note a couple of things:</p>
<ul>
<li>The Toy IR is in SSA form, which means that every variable is defined exactly
  once. This means that abstract properties of each variable are easy to track.</li>
<li>The Toy IR represents a linear trace without control flow, meaning we won't
  talk about meet/join or fixpoints. They only make sense if the IR has a
  notion of conditional branches or back edges (loops).</li>
</ul>
<p>Alright, let's get started.</p>
<h3 id="welcome-to-abstract-interpretation">Welcome to abstract interpretation</h3>
<p>Abstract interpretation means a couple different things to different people.
There's rigorous mathematical formalism thanks to Patrick and Radhia Cousot,
our favorite power couple, and there's also sketchy hand-wavy stuff like what
will follow in this post. In the end, all people are trying to do is reason
about program behavior without running it.</p>
<p>In particular, abstract interpretation is an <em>over-approximation</em> of the
behavior of a program. Correctly implemented abstract interpreters never lie,
but they might be a little bit pessimistic. This is because instead of using
real values and running the program---which would produce a concrete result and
some real-world behavior---we "run" the program with a parallel universe of
<em>abstract</em> values. This abstract run gives us information about all possible
runs of the program.<sup id="fnref:logozzo"><a class="footnote-ref" href="../posts/2024/07/toy-abstract-interpretation.html#fn:logozzo">1</a></sup></p>
<p>Abstract values always represent sets of concrete values. Instead of literally
storing a set (in the world of integers, for example, it could get pretty
big...there are a lot of integers), we group them into a finite number of named
subsets.<sup id="fnref:lattices"><a class="footnote-ref" href="../posts/2024/07/toy-abstract-interpretation.html#fn:lattices">2</a></sup></p>
<p>Let's learn a little about abstract interpretation with an example program and
example abstract domain. Here's the example program:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">v1</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
</pre></div>

<p>And our abstract domain is "is the number positive" (where "positive" means
nonnegative, but I wanted to keep the words distinct):</p>
<div class="code"><pre class="code literal-block">       top
    /       \
positive    negative
    \       /
      bottom
</pre></div>

<p>The special <em>top</em> value means "I don't know" and the special <em>bottom</em> value
means "empty set" or "unreachable". The <em>positive</em> and <em>negative</em> values
represent the sets of all positive and negative numbers, respectively.</p>
<p>We initialize all the variables <code>v0</code>, <code>v1</code>, and <code>v2</code> to <em>bottom</em> and then walk
our IR, updating our knowledge as we go.</p>
<div class="code"><pre class="code literal-block"><span class="c1"># here</span>
<span class="n">v0</span><span class="p">:</span><span class="n">bottom</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">v1</span><span class="p">:</span><span class="n">bottom</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">v2</span><span class="p">:</span><span class="n">bottom</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
</pre></div>

<p>In order to do that, we have to have <em>transfer functions</em> for each operation.
For constants, the transfer function is easy: determine if the constant is
positive or negative. For other operations, we have to define a function that
takes the abstract values of the operands and returns the abstract value of the
result.</p>
<p>In order to be correct, transfer functions for operations have to be compatible
with the behavior of their corresponding concrete implementations. You can
think of them having an implicit universal quantifier <em>forall</em> in front of
them.</p>
<p>Let's step through the constants at least:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span><span class="p">:</span><span class="n">positive</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">v1</span><span class="p">:</span><span class="n">positive</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># here</span>
<span class="n">v2</span><span class="p">:</span><span class="n">bottom</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
</pre></div>

<p>Now we need to figure out the transfer function for <code>add</code>. It's kind of tricky
right now because we haven't specified our abstract domain very well. I keep
saying "numbers", but what kinds of numbers? Integers? Real numbers? Floating
point? Some kind of fixed-width bit vector (<code>int8</code>, <code>uint32</code>, ...) like an
actual machine "integer"?</p>
<p>For this post, I am going to use the mathematical definition of integer, which
means that the values are not bounded in size and therefore do not overflow.
Actual hardware memory constraints aside, this is kind of like a Python <code>int</code>.</p>
<p>So let's look at what happens when we add two abstract numbers:</p>
<table>
<thead><tr>
<th></th>
<th>top</th>
<th>positive</th>
<th>negative</th>
<th>bottom</th>
</tr></thead>
<tbody>
<tr>
<td><strong>top</strong></td>
<td>top</td>
<td>top</td>
<td>top</td>
<td>bottom</td>
</tr>
<tr>
<td><strong>positive</strong></td>
<td>top</td>
<td>positive</td>
<td>top</td>
<td>bottom</td>
</tr>
<tr>
<td><strong>negative</strong></td>
<td>top</td>
<td>top</td>
<td>negative</td>
<td>bottom</td>
</tr>
<tr>
<td><strong>bottom</strong></td>
<td>bottom</td>
<td>bottom</td>
<td>bottom</td>
<td>bottom</td>
</tr>
</tbody>
</table>
<p>As an example, let's try to add two numbers <code>a</code> and <code>b</code>, where <code>a</code> is positive
and <code>b</code> is negative. We don't know anything about their values other than their
signs. They could be <code>5</code> and <code>-3</code>, where the result is <code>2</code>, or they could be
<code>1</code> and <code>-100</code>, where the result is <code>-99</code>. This is why we can't say anything
about the result of this operation and have to return <em>top</em>.</p>
<p>The short of this table is that we only really know the result of an addition
if both operands are positive or both operands are negative. Thankfully, in
this example, both operands are known positive. So we can learn something about
<code>v2</code>:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span><span class="p">:</span><span class="n">positive</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">v1</span><span class="p">:</span><span class="n">positive</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">v2</span><span class="p">:</span><span class="n">positive</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
<span class="c1"># here</span>
</pre></div>

<p>This may not seem useful in isolation, but analyzing more complex programs even
with this simple domain may be able to remove checks such as <code>if (v2 &lt; 0) { ... }</code>.</p>
<p>Let's take a look at another example using an sample <code>absval</code> (absolute value)
IR operation:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">absval</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">absval</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
<span class="n">v4</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
<span class="n">v5</span> <span class="o">=</span> <span class="n">absval</span><span class="p">(</span><span class="n">v4</span><span class="p">)</span>
</pre></div>

<p>Even though we have no constant/concrete values, we can still learn something
about the states of values throughout the program. Since we know that <code>absval</code>
always returns a positive number, we learn that <code>v2</code>, <code>v3</code>, and <code>v4</code> are all
positive. This means that we can optimize out the <code>absval</code> operation on <code>v5</code>:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span><span class="p">:</span><span class="n">top</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">v1</span><span class="p">:</span><span class="n">top</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span><span class="p">:</span><span class="n">positive</span> <span class="o">=</span> <span class="n">absval</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
<span class="n">v3</span><span class="p">:</span><span class="n">positive</span> <span class="o">=</span> <span class="n">absval</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
<span class="n">v4</span><span class="p">:</span><span class="n">positive</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
<span class="n">v5</span><span class="p">:</span><span class="n">positive</span> <span class="o">=</span> <span class="n">v4</span>
</pre></div>

<p>Other interesting lattices include:</p>
<ul>
<li>Constants (where the middle row is pretty wide)</li>
<li>Range analysis (bounds on min and max of a number)</li>
<li>Known bits (using a bitvector representation of a number, which bits are
  always 0 or 1)</li>
</ul>
<p>For the rest of this blog post, we are going to do a very limited version of
"known bits", called <em>parity</em>. This analysis only tracks the least significant
bit of a number, which indicates if it is even or odd.</p>
<h3 id="parity">Parity</h3>
<p>The lattice is pretty similar to the positive/negative lattice:</p>
<div class="code"><pre class="code literal-block">    top
  /     \
even    odd
  \     /
   bottom
</pre></div>

<p>Let's define a data structure to represent this in Python code:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Parity</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre></div>

<p>And instantiate the members of the lattice:</p>
<div class="code"><pre class="code literal-block"><span class="n">TOP</span> <span class="o">=</span> <span class="n">Parity</span><span class="p">(</span><span class="s2">"top"</span><span class="p">)</span>
<span class="n">EVEN</span> <span class="o">=</span> <span class="n">Parity</span><span class="p">(</span><span class="s2">"even"</span><span class="p">)</span>
<span class="n">ODD</span> <span class="o">=</span> <span class="n">Parity</span><span class="p">(</span><span class="s2">"odd"</span><span class="p">)</span>
<span class="n">BOTTOM</span> <span class="o">=</span> <span class="n">Parity</span><span class="p">(</span><span class="s2">"bottom"</span><span class="p">)</span>
</pre></div>

<p>Now let's write a forward flow analysis of a basic block using this lattice.
We'll do that by assuming that a method on <code>Parity</code> is defined for each IR
operation. For example, <code>Parity.add</code>, <code>Parity.lshift</code>, etc.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">analyze</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="n">Block</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">parity</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">BOTTOM</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">block</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parity_of</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Parity</span><span class="o">.</span><span class="n">const</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parity</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">block</span><span class="p">:</span>
        <span class="n">transfer</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">Parity</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">parity_of</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">find</span><span class="p">())</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">parity</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

<p>For every operation, we compute the abstract value---the parity---of the
arguments and then call the corresponding method on <code>Parity</code> to get the
abstract result.</p>
<!-- TODO maybe learn more about different IRs and how they do constants.
apparently pypy/llvm are free-floating; cinder is not -->
<p>We need to special case <code>Constant</code>s due to a quirk of how the Toy IR is
constructed: the constants don't appear in the instruction stream and instead
are free-floating.</p>
<p>Let's start by looking at the abstraction function for concrete
values---constants:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Parity</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">const</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">EVEN</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ODD</span>
</pre></div>

<p>Seems reasonable enough. Let's pause on operations for a moment and consider an
example program:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">lshift</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">lshift</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v4</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
<span class="n">v5</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">(</span><span class="n">v4</span><span class="p">)</span>
</pre></div>

<p>This function (which is admittedly a little contrived) takes two inputs, shifts
them left by one bit, adds the result, and then checks the least significant
bit of the addition result. It then passes that result into a <code>dummy</code> function,
which you can think of as "return" or "escape".</p>
<p>To do some abstract interpretation on this program, we'll need to implement the
transfer functions for <code>lshift</code> and <code>add</code> (<code>dummy</code> will just always return
<code>TOP</code>). We'll start with <code>add</code>. Remember that adding two even numbers returns
an even number, adding two odd numbers returns an even number, and mixing even
and odd returns an odd number.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Parity</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">BOTTOM</span> <span class="ow">or</span> <span class="n">other</span> <span class="ow">is</span> <span class="n">BOTTOM</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BOTTOM</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">TOP</span> <span class="ow">or</span> <span class="n">other</span> <span class="ow">is</span> <span class="n">TOP</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TOP</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">EVEN</span> <span class="ow">and</span> <span class="n">other</span> <span class="ow">is</span> <span class="n">EVEN</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">EVEN</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">ODD</span> <span class="ow">and</span> <span class="n">other</span> <span class="ow">is</span> <span class="n">ODD</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">EVEN</span>
        <span class="k">return</span> <span class="n">ODD</span>
</pre></div>

<p>We also need to fill in the other cases where the operands are <em>top</em> or
<em>bottom</em>. In this case, they are both "contagious"; if either operand is
bottom, the result is as well. If neither is bottom but either operand is top,
the result is as well.</p>
<p>Now let's look at <code>lshift</code>. Shifting any number left by a non-zero number of
bits will always result in an even number, but we need to be careful about the
zero case! Shifting by zero doesn't change the number at all. Unfortunately,
since our lattice has no notion of zero, we have to over-approximate here:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Parity</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># self &lt;&lt; other</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="n">ODD</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">EVEN</span>
        <span class="k">return</span> <span class="n">TOP</span>
</pre></div>

<p>This means that we will miss some opportunities to optimize, but it's a
tradeoff that's just part of the game. (We could also add more elements to our
lattice, but that's a topic for another day.)</p>
<p>Now, if we run our abstract interpretation, we'll collect some interesting
properties about the program. If we temporarily hack on the internals of
<code>bb_to_str</code>, we can print out parity information alongside the IR operations:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span><span class="p">:</span><span class="n">top</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">v1</span><span class="p">:</span><span class="n">top</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span><span class="p">:</span><span class="n">even</span> <span class="o">=</span> <span class="n">lshift</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v3</span><span class="p">:</span><span class="n">even</span> <span class="o">=</span> <span class="n">lshift</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v4</span><span class="p">:</span><span class="n">even</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
<span class="n">v5</span><span class="p">:</span><span class="n">top</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">(</span><span class="n">v4</span><span class="p">)</span>
</pre></div>

<p>This is pretty awesome, because we can see that <code>v4</code>, the result of the
addition, is <em>always</em> even. Maybe we can do something with that information.</p>
<h3 id="optimization">Optimization</h3>
<p>One way that a program might check if a number is odd is by checking the least
significant bit. This is a common pattern in C code, where you might see code
like <code>y = x &amp; 1</code>. Let's introduce a <code>bitand</code> IR operation that acts like the
<code>&amp;</code> operator in C/Python. Here is an example of use of it in our program:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">lshift</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">lshift</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v4</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
<span class="n">v5</span> <span class="o">=</span> <span class="n">bitand</span><span class="p">(</span><span class="n">v4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># new!</span>
<span class="n">v6</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">(</span><span class="n">v5</span><span class="p">)</span>
</pre></div>

<p>We'll hold off on implementing the transfer function for it---that's left as an
exercise for the reader---and instead do something different.</p>
<p>Instead, we'll see if we can optimize operations of the form <code>bitand(X, 1)</code>. If
we statically know the parity as a result of abstract interpretation, we can
replace the <code>bitand</code> with a constant <code>0</code> or <code>1</code>.</p>
<p>We'll first modify the <code>analyze</code> function (and rename it) to return a new
<code>Block</code> containing optimized instructions:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="n">Block</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Block</span><span class="p">:</span>
    <span class="n">parity</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">BOTTOM</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">block</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parity_of</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Parity</span><span class="o">.</span><span class="n">const</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parity</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">block</span><span class="p">:</span>
        <span class="c1"># TODO: Optimize op</span>
        <span class="c1"># Emit</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="c1"># Analyze</span>
        <span class="n">transfer</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">Parity</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">parity_of</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">find</span><span class="p">())</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">parity</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

<p>We're approaching this the way that PyPy does things under the hood, which is
all in roughly a single pass. It tries to optimize an instruction away, and if
it can't, it copies it into the new block.</p>
<p>Now let's add in the <code>bitand</code> optimization. It's mostly some gross-looking
pattern matching that checks if the right hand side of a bitwise <code>and</code>
operation is <code>1</code> (TODO: the left hand side, too). CF had some neat ideas on how
to make this more ergonomic, which I might save for later.<sup id="fnref:match-args"><a class="footnote-ref" href="../posts/2024/07/toy-abstract-interpretation.html#fn:match-args">3</a></sup></p>
<p>Then, if we know the parity, optimize the <code>bitand</code> into a constant.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="n">Block</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Block</span><span class="p">:</span>
    <span class="n">parity</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">BOTTOM</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">block</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parity_of</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Parity</span><span class="o">.</span><span class="n">const</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parity</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">block</span><span class="p">:</span>
        <span class="c1"># Try to simplify</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Operation</span><span class="p">)</span> <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"bitand"</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parity_of</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">EVEN</span><span class="p">:</span>
                    <span class="n">op</span><span class="o">.</span><span class="n">make_equal_to</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">parity_of</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ODD</span><span class="p">:</span>
                    <span class="n">op</span><span class="o">.</span><span class="n">make_equal_to</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="k">continue</span>
        <span class="c1"># Emit</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="c1"># Analyze</span>
        <span class="n">transfer</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">Parity</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">parity_of</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">find</span><span class="p">())</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">parity</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

<p>Remember: because we use union-find to rewrite instructions in the optimizer
(<code>make_equal_to</code>), later uses of the same instruction get the new
optimized version "for free" (<code>find</code>).</p>
<p>Let's see how it works on our IR:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">getarg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">lshift</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">lshift</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v4</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
<span class="n">v6</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>

<p>Hey, neat! <code>bitand</code> disappeared and the argument to <code>dummy</code> is now the constant
<code>0</code> because we know the lowest bit.</p>
<h3 id="wrapping-up">Wrapping up</h3>
<p>Hopefully you have gained a little bit of an intuitive understanding of
abstract interpretation. Last year, being able to write some code made me more
comfortable with the math. Now being more comfortable with the math is helping
me write the code. It's nice upward spiral.</p>
<p>The two abstract domains we used in this post are simple and not very useful in
practice but it's possible to get very far using slightly more complicated
abstract domains. Common domains include: constant propagation, type inference,
range analysis, effect inference, liveness, etc. For example, here is a a
sample lattice for constant propagation:</p>
<figure style="display: block; margin: 0 auto;"><!--
digraph G {
    rankdir="BT";
    top [shape=Msquare];
    bottom [shape=Msquare];

    bottom -> "-inf";
    bottom -> "-2";
    bottom -> "-1";
    bottom -> 0;
    bottom -> 1;
    bottom -> 2;
    bottom -> "+inf";

    "-inf" -> negative;
    "-2" -> negative;
    "-1" -> negative;
    0 -> top;
    1 -> nonnegative;
    2 -> nonnegative;
    "+inf" -> nonnegative;

    negative -> nonzero;
    nonnegative -> nonzero;
    nonzero->top;

    {rank=same; "-inf"; "-2"; "-1"; 0; 1; 2; "+inf"}
    {rank=same; nonnegative; negative;}
}
--><object class="svg" type="image/svg+xml" data="../images/2024-complex-lattice.svg">
    </object>
</figure><p>It has multiple levels to indicate more and less precision. For example, you
might learn that a variable is either <code>1</code> or <code>2</code> and be able to encode that as
<code>nonnegative</code> instead of just going straight to <code>top</code>.</p>
<p>Check out some real-world abstract interpretation in open source projects:</p>
<ul>
<li><a href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/Support/KnownBits.cpp">Known bits in LLVM</a></li>
<li><a href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/IR/ConstantRange.cpp">Constant range in LLVM</a></li>
<li>But I am told that the ranges don't form a lattice (see <a href="https://dl.acm.org/doi/10.1145/2651360">Interval Analysis and Machine Arithmetic: Why Signedness Ignorance Is Bliss</a>)</li>
<li><a href="https://github.com/torvalds/linux/blob/master/kernel/bpf/tnum.c">Tristate numbers for known bits in Linux eBPF</a></li>
<li><a href="https://github.com/torvalds/linux/blob/28bbe4ea686a023929d907cc168430b61094811c/kernel/bpf/verifier.c#L13335">Range analysis in Linux eBPF</a></li>
<li>
<a href="https://github.com/bminor/binutils-gdb/blob/master/gdb/prologue-value.c">GDB prologue analysis</a>
  of assembly to understand the stack and find frame pointers without using
  DWARF (<a href="https://sourceware.org/gdb/wiki/Internals/Prologue%20Analysis">some
  docs</a>)</li>
</ul>
<p>If you have some readable examples, please share them so I can add.</p>
<h3 id="acknowledgements">Acknowledgements</h3>
<p>Thank you to <a href="https://cfbolz.de/">CF Bolz-Tereick</a> for the toy optimizer and
helping edit this post!</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:logozzo">
<p>In the words of abstract interpretation researchers Vincent Laviron
and Francesco Logozzo in their paper <em>Refining Abstract
Interpretation-based Static Analyses with Hints</em> (APLAS 2009):</p>
<blockquote>
<p>The three main elements of an abstract interpretation are: (i) the
abstract elements ("which properties am I interested in?"); (ii) the
abstract transfer functions ("which is the abstract semantics of basic
statements?"); and (iii) the abstract operations ("how do I combine the
abstract elements?").</p>
</blockquote>
<p>We don't have any of these "abstract operations" in this post because
there's no control flow but you can read about them elsewhere! <a class="footnote-backref" href="../posts/2024/07/toy-abstract-interpretation.html#fnref:logozzo" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:lattices">
<p>These abstract values are arranged in a <em>lattice</em>, which is a
mathematical structure with some properties but the most important ones are
that it has a top, a bottom, a partial order, a meet operation, and values
can only move in one direction on the lattice.</p>
<p>Using abstract values from a lattice promises two things:</p>
<ul>
<li>The analysis will terminate</li>
<li>The analysis will be correct for <em>any</em> run of the program, not just one
  sample run</li>
</ul>
<p><a class="footnote-backref" href="../posts/2024/07/toy-abstract-interpretation.html#fnref:lattices" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:match-args">
<p>Something about <code>__match_args__</code> and <code>@property</code>... <a class="footnote-backref" href="../posts/2024/07/toy-abstract-interpretation.html#fnref:match-args" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
</ol>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2024/07/mining-jit-traces-missing-optimizations-z3.html" class="u-url">Mining JIT traces for missing optimizations with Z3</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/cf-bolz-tereick.html">CF Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2024/07/mining-jit-traces-missing-optimizations-z3.html" rel="bookmark">
            <time class="published dt-published" datetime="2024-07-19T17:01:09Z" itemprop="datePublished" title="2024-07-19 17:01">2024-07-19 17:01</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>In my last post I've described <a href="../posts/2024/07/finding-simple-rewrite-rules-jit-z3.html">how to use Z3 to find simple local peephole
optimization patterns</a>
for the integer operations in PyPy's JIT. An example is <code>int_and(x, 0) -&gt;
0</code>. In this post I want to scale up the problem of identifying possible
optimizations to much bigger instruction sequences, also using Z3. For that, I
am starting with the JIT traces of <strong>real benchmarks</strong>, after they have been
optimized by the optimizer of PyPy's JIT. Then we can ask Z3 to find
inefficient integer operations in those traces.</p>
<p>Starting from the optimized traces of real programs has some big
advantages over the "classical" superoptimization approach of generating and
then trying all possible sequences of instructions. It avoids the
combinatorial explosion that happens with the latter approach. Also, starting
from the traces of benchmarks or (even better) actual programs makes sure that
we actually care about the missing optimizations
that are found in this way. And because the traces are analyzed after they have
been optimized by PyPy's optimizer, we only get reports for <em>missing</em>
optimizations, that the JIT isn't able to do (yet).</p>
<p>The techniques and experiments I describe in this post are again the result of
a bunch of discussions with John Regehr at a conference a few weeks ago, as
well as reading his blog posts and papers. Thanks John! Also thanks to <a href="https://bernsteinbear.com/">Max
Bernstein</a> for super helpful feedback on the drafts
of this blog post (and for poking me to write things in general).</p>
<h3 id="high-level-approach">High-Level Approach</h3>
<p>The approach that I took works as follows:</p>
<ul>
<li>Run benchmarks or other interesting programs and then dump the IR of the JIT
  traces into a file. The traces have at that point been already optimized by
  the PyPy JIT's optimizer.</li>
<li>For every trace, ignore all the operations on non-integer variables.</li>
<li>Translate every integer operation into a Z3 formula.</li>
<li>For every operation, use Z3 to find out whether the operation is redundant
  (how that is done is described below).</li>
<li>If the operation is redundant, the trace is less efficient than it could have
  been, because the optimizer could also have removed the operation. Report the
  inefficiency.</li>
<li>Minimize the inefficient programs by removing as many operations as possible
  to make the problem easier to understand.</li>
</ul>
<p>In the post I will describe the details and show some pseudocode of the
approach. I'll also make the proper code public eventually (but it needs a
healthy dose of cleanups first).</p>
<h3 id="dumping-pypy-traces">Dumping PyPy Traces</h3>
<p>PyPy will write its JIT traces into the file <code>out</code> if the environment variable
<a href="https://doc.pypy.org/en/latest/man/pypy.1.html"><code>PYPYLOG</code></a> is set as follows:</p>
<div class="code"><pre class="code literal-block">PYPYLOG=jit-log-opt:out pypy &lt;program.py&gt;
</pre></div>

<p>This environment variable works for PyPy, but also for other virtual machines
built with RPython.</p>
<p>(This is really a side point for the rest of the blog post, but since the
question came up I wanted to clarify it: Operations on integers in the Python
program that the JIT is running don't all correspond 1-to-1 with the <code>int_...</code>
operations in the traces. The <code>int_...</code> trace operations always operate on
machine words. The Python <code>int</code> type supports arbitrarily large integers. PyPy
will optimistically try to lower the operations on Python integers into machine
word operations, but adds the necessary guards into the trace to make sure that
overflow outside of the range of machine words is caught. In case one of these
guards fails the interpreter switches to a big integer heap-allocated
representation.)</p>
<h3 id="encoding-traces-as-z3-formulas">Encoding Traces as Z3 formulas</h3>
<p>The last blog post already contained the code to encode the results of
individual trace operations into Z3 formulas, so we don't need to repeat that
here. To encode traces of operations we introduce a Z3 variable for every
operation in the trace and then call the <code>z3_expression</code> function for every
single one of the operations in the trace.</p>
<p>For example, for the following trace:</p>
<div class="code"><pre class="code literal-block"><span class="k">[i1]</span>
<span class="na">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">uint_rshift(i1, 32)</span>
<span class="na">i3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">int_and(i2, 65535)</span>
<span class="na">i4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">uint_rshift(i1, 48)</span>
<span class="na">i5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">int_lshift(i4, 16)</span>
<span class="na">i6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">int_or(i5, i3)</span>
<span class="na">jump(i6, i2) # equal</span>
</pre></div>

<p>We would get the Z3 formula:</p>
<div class="code"><pre class="code literal-block">z3.And(i2 == LShR(i1, 32),
       i3 == i2 &amp; 65535,
       i4 == LShR(i1, 48),
       i5 == i4 &lt;&lt; 16)
</pre></div>

<p>Usually we won't ask for the formula of the whole trace at once. Instead we go
through the trace operation by operation and try to find inefficiencies in the
current one we are looking at. Roughly like this (pseudo-)code:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">newvar</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">find_inefficiencies</span><span class="p">(</span><span class="n">trace</span><span class="p">):</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>
    <span class="n">var_to_z3var</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">input_argument</span> <span class="ow">in</span> <span class="n">trace</span><span class="o">.</span><span class="n">inputargs</span><span class="p">:</span>
        <span class="n">var_to_z3var</span><span class="p">[</span><span class="n">input_argument</span><span class="p">]</span> <span class="o">=</span> <span class="n">newz3var</span><span class="p">(</span><span class="n">input_argument</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">trace</span><span class="p">:</span>
        <span class="n">var_to_z3var</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">z3resultvar</span> <span class="o">=</span> <span class="n">newz3var</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">resultvarname</span><span class="p">)</span>
        <span class="n">arg0</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">z3arg0</span> <span class="o">=</span> <span class="n">var_to_z3var</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">arg1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">z3arg1</span> <span class="o">=</span> <span class="n">var_to_z3var</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z3arg1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">z3arg0</span><span class="p">,</span> <span class="n">z3arg1</span><span class="p">)</span>
        <span class="c1"># checking for inefficiencies, see the next sections</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="o">...</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">"inefficient"</span><span class="p">,</span> <span class="n">op</span>

        <span class="c1"># not inefficient, assert op into the solver and continue with the next op</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3resultvar</span> <span class="o">==</span> <span class="n">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="c1"># no inefficiency found</span>
</pre></div>

<h3 id="identifying-constant-booleans-with-z3">Identifying constant booleans with Z3</h3>
<p>To get started finding inefficiencies in a trace, we can
first focus on boolean variables. For every operation in the trace that
returns a bool we can ask Z3 to prove that this variable must be always True or
always False. Most of the time, neither of these proofs will succeed. But if Z3
manages to prove one of them, we know have found an ineffiency: instead of
computing the boolean result (eg by executing a comparison) the JIT's optimizer
could have replaced the operation with the corresponding boolean constant.</p>
<p>Here's an example of an inefficiency found that way: if <code>x &lt; y</code> and <code>y &lt; z</code> are
both true, PyPy's JIT could conclude that <code>x &lt; z</code> must also
be true. However, currently the JIT cannot make that conclusion because it
only reasons about the concrete ranges (lower and upper bounds) for every
integer variable, but it has no way to remember anything about relationships
between different variables. This kind of reasoning would quite often be useful
to remove list/string bounds checks. Here's a <a href="https://www.youtube.com/watch?app=desktop&amp;v=1hm5ZVmBEvo">talk about how LLVM does
this</a> (but it might be
too heavyweight for a JIT setting).</p>
<p>Here are some more examples found that way:</p>
<ul>
<li>
<code>x - 1 == x</code> is always False</li>
<li>
<code>x - (x == -1) == -1</code> is always False. The pattern <code>x - (x == -1)</code> happens a
  lot in PyPy's hash computations: To be compatible with the CPython hashes we
  need to make sure that no object's hash is -1 (CPython uses -1 as an error
  value on the C level).</li>
</ul>
<p>Here's pseudo-code for how to implement checking boolean operations for
inefficiencies:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">find_inefficiencies</span><span class="p">(</span><span class="n">trace</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">trace</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">z3arg0</span><span class="p">,</span> <span class="n">z3arg1</span><span class="p">)</span>
        <span class="c1"># check for boolean constant result</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">has_boolean_result</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">prove</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="s2">"inefficient"</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">prove</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="s2">"inefficient"</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="mi">1</span>
        <span class="c1"># checking for other inefficiencies, see the next sections</span>
        <span class="o">...</span>

        <span class="c1"># not inefficient, add op to the solver and continue with the next op</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3resultvar</span> <span class="o">==</span> <span class="n">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="c1"># no inefficiency found</span>
</pre></div>

<h3 id="identifying-redundant-operations">Identifying redundant operations</h3>
<p>A more interesting class of redundancy is to try to find two operations in a
trace that compute the same result. We can do that by asking Z3 to prove for
each pair of different operations in the trace to prove that the result is
always the same. If a previous operation returns the same result, the JIT could
have reused that result instead of re-computing it, saving time. Doing this
search for equivalent operations with Z3 is quadratic in the number of
operations, but since traces have a maximum length it is not too bad in
practice.</p>
<p>This is the real workhorse of my script so far, it's what finds most of the
inefficiencies. Here's a few examples:</p>
<ul>
<li>The very first and super useful example the script found is <code>int_eq(b, 1) ==
  b</code> if <code>b</code> is known to be a boolean (ie and integer 0 or 1). I have already
  implemented this optimization in the JIT.</li>
<li>Similarly, <code>int_and(b, 1) == b</code> for booleans.</li>
<li><code>(x &lt;&lt; 4) &amp; -0xf == x &lt;&lt; 4</code></li>
<li>
<code>((x &gt;&gt; 63) &lt;&lt; 1) &lt;&lt; 2) &gt;&gt; 3 == x &gt;&gt; 63</code>. In general the JIT is quite bad at
  optimizing repeated shifts (the infrastructure for doing better with that is
  already in place, so this will be a relatively easy fix).</li>
<li>
<code>(x &amp; 0xffffffff) | ((x &gt;&gt; 32) &lt;&lt; 32) == x</code>. Having the JIT optimize this
  would maybe require first recognizing that <code>(x &gt;&gt; 32) &lt;&lt; 32</code> can be expressed
  as a mask: <code>(x &amp; 0xffffffff00000000)</code>, and then using <code>(x &amp; c1) | (x &amp; c2) ==
  x &amp; (c1 | c2)</code>
</li>
<li>A commonly occurring pattern is variations of this one:
  <code>((x &amp; 1345) ^ 2048) - 2048 == x &amp; 1345</code> (with different constants, of
  course). xor is add without carry, and <code>x &amp; 1345</code> does not have the bit
  <code>2048</code> set. Therefore the <code>^ 2048</code> is equivalent to <code>+ 2048</code>, which the <code>-
  2048</code> cancels. More generally, if <code>a &amp; b == 0</code>, then <code>a + b == a | b == a ^ b</code>.
  I don't understand at all why this appears so often in the traces, but I
  see variations of it a lot. LLVM can optimize this, but <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=115829">GCC
  can't</a>, thanks to
  <a href="https://hachyderm.io/@pinskia/112752641328799157">Andrew Pinski for filing the
  bug</a>!</li>
</ul>
<p>And here's some implementation pseudo-code again:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">find_inefficiencies</span><span class="p">(</span><span class="n">trace</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">trace</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">z3arg0</span><span class="p">,</span> <span class="n">z3arg1</span><span class="p">)</span>
        <span class="c1"># check for boolean constant result</span>
        <span class="o">...</span>
        <span class="c1"># searching for redundant operations</span>
        <span class="k">for</span> <span class="n">previous_op</span> <span class="ow">in</span> <span class="n">trace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">previous_op</span> <span class="ow">is</span> <span class="n">op</span><span class="p">:</span>
                <span class="k">break</span> <span class="c1"># done, reached the current op</span>
            <span class="n">previous_op_z3var</span> <span class="o">=</span> <span class="n">var_to_z3var</span><span class="p">[</span><span class="n">previous_op</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">prove</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">previous_op_z3var</span> <span class="o">==</span> <span class="n">res</span><span class="p">):</span>
                <span class="k">return</span> <span class="s2">"inefficient"</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">previous_op</span>
        <span class="o">...</span>
        <span class="c1"># more code here later</span>
        <span class="o">...</span>

        <span class="c1"># not inefficient, add op to the solver and continue with the next op</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3resultvar</span> <span class="o">==</span> <span class="n">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="c1"># no inefficiency found</span>
</pre></div>

<h3 id="synthesizing-more-complicated-constants-with-exists-forall">Synthesizing more complicated constants with exists-forall</h3>
<p>To find out whether some integer operations always return a constant result, we
can't simply use the same trick as for those operations that return boolean
results, because enumerating 2⁶⁴ possible constants and checking them all
would take too long. Like in the last post, we can use <code>z3.ForAll</code> to find out
whether Z3 can synthesize a constant for the result of an operation for us.
If such a constant exists, the JIT could have removed the operation,
and replaced it with the constant that Z3 provides.</p>
<p>Here a few examples of inefficiencies found this way:</p>
<ul>
<li>
<code>(x ^ 1) ^ x == 1</code> (or, more generally: <code>(x ^ y) ^ x == y</code>)</li>
<li>if <code>x | y == 0</code>, it follows that <code>x == 0</code> and <code>y == 0</code>
</li>
<li>if <code>x != MAXINT</code>, then <code>x + 1 &gt; x</code>
</li>
</ul>
<p>Implementing this is actually slightly annoying. The <code>solver.add</code> calls for
non-inefficient ops add assertions to the solver, which are now confusing the
<code>z3.ForAll</code> query. We could remove all assertion from the solver, then do the
<code>ForAll</code> query, then add the assertions back. What I ended doing instead was
instantiating a second solver object that I'm using for the <code>ForAll</code> queries,
that remains empty the whole time.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">find_inefficiencies</span><span class="p">(</span><span class="n">trace</span><span class="p">):</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>
    <span class="n">empty_solver</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>
    <span class="n">var_to_z3var</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">trace</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">z3arg0</span><span class="p">,</span> <span class="n">z3arg1</span><span class="p">)</span>
        <span class="c1"># check for boolean constant result</span>
        <span class="o">...</span>
        <span class="c1"># searching for redundant operations</span>
        <span class="o">...</span>
        <span class="c1"># checking for constant results</span>
        <span class="n">constvar</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVec</span><span class="p">(</span><span class="s1">'find_const'</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="p">(</span>
            <span class="n">var_to_z3var</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
            <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span>
                <span class="o">*</span><span class="n">solver</span><span class="o">.</span><span class="n">assertions</span><span class="p">(),</span>
                <span class="n">expr</span> <span class="o">==</span> <span class="n">constvar</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">empty_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">sat</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">empty_solver</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
            <span class="n">const</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="n">constvar</span><span class="p">]</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">()</span>
            <span class="k">return</span> <span class="s2">"inefficient"</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">const</span>

        <span class="c1"># not inefficient, add op to the solver and continue with the next op</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3resultvar</span> <span class="o">==</span> <span class="n">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="c1"># no inefficiency found</span>
</pre></div>

<h3 id="minimization">Minimization</h3>
<p>Analyzing an inefficiency by hand in the context of a larger trace is quite
tedious. Therefore I've implemented a (super inefficient) script to try to make
the examples smaller. Here's how that works:</p>
<ul>
<li>First throw out all the operations that occur <em>after</em> the inefficient operation
  in the trace.</li>
<li>Then we remove all "dead" operations, ie operations that don't have their
  results used (all the operations that we can analyze with Z3 are without side
  effects).</li>
<li>Now we try to remove every guard in the trace one by one and check
  afterwards, whether the resulting trace still has an inefficiency.</li>
<li>We also try to replace every single operation with a new argument to the
  trace, to see whether the inefficiency is still present.</li>
</ul>
<p>The minimization process is sort of inefficient and I should probably be using
 <a href="https://github.com/DRMacIver/shrinkray">shrinkray</a> or
 <a href="https://github.com/csmith-project/creduce">C-Reduce</a> instead. However, it
 seems to work well in practice and the runtime isn't too bad.</p>
<h3 id="results">Results</h3>
<p>So far I am using the JIT traces of three programs: 1) Booting Linux on the
<a href="https://docs.pydrofoil.org">Pydrofoil</a> RISC-V emulator, 2) booting Linux on the Pydrofoil ARM emulator, and 3)
running the PyPy bootstrap process on top of PyPy.</p>
<p>I picked these programs because most Python programs don't contain interesting
amounts of integer operations, and the traces of the emulators
contain a lot of them. I also used the bootstrap process because I still wanted
to try a big Python program and personally care about the runtime of this
program a lot.</p>
<p>The script identifies 94
inefficiencies in the traces, a lot of them come from repeating
patterns. My next steps will be to manually inspect them all, categorize them, and
implement easy optimizations identified that way. I also want a way to sort the
examples by execution count in the benchmarks, to get a feeling for which of
them are most important.</p>
<p>I didn't investigate the full set of <a href="https://speed.pypy.org">Python
benchmarks</a> that PyPy uses yet, because I don't expect
them to contain interesting amounts of integer operations, but maybe I am wrong
about that? Will have to try eventually.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This was again much easier to do than I would have expected! Given that I had
the translation of trace ops to Z3 already in place, it was a matter of about a
day's of programming to use this infrastructure to find the first problems and
minimizing them.</p>
<p>Reusing the results of existing operations or replacing operations by constants
can be seen as "zero-instruction superoptimization". I'll probably be rather
busy for a while to add the missing optimizations identified by my simple
script. But later extensions to actually synthesize one or several operations
in the attempt to optimize the traces more and find more opportunities should
be possible.</p>
<p>Finding inefficiencies in traces with Z3 is significantly less
annoying and also less error-prone than just manually inspecting traces and
trying to spot optimization opportunities.</p>
<h3 id="random-notes-and-sources">Random Notes and Sources</h3>
<p>Again, John's blog posts:</p>
<ul>
<li><a href="https://blog.regehr.org/archives/1109">Let’s Work on an LLVM Superoptimizer</a></li>
<li><a href="https://blog.regehr.org/archives/1146">Early Superoptimizer Results</a></li>
<li><a href="https://blog.regehr.org/archives/1252">A Few Synthesizing Superoptimizer Results</a></li>
<li><a href="https://blog.regehr.org/archives/1636">Synthesizing Constants</a></li>
</ul>
<p>and papers:</p>
<ul>
<li><a href="https://arxiv.org/pdf/1711.04422">A Synthesizing Superoptimizer</a></li>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3649837">Hydra: Generalizing Peephole Optimizations with Program Synthesis</a></li>
</ul>
<p>I remembered recently that I had seen the approach of optimizing the traces of
a tracing JIT with Z3 a long time ago, as part of the (now long dead, I think)
<a href="https://web.archive.org/web/20160304055149/http://research.microsoft.com/en-us/projects/spur/">SPUR
project</a>.
There's a <a href="https://web.archive.org/web/20161029162737/http://csl.stanford.edu/~christos/pldi2010.fit/tillmann.provers4jit.pdf">workshop
paper</a>
from 2010 about this. SPUR was trying to use Z3 built into the actual JIT (as
opposed to using Z3 only to find places where the regular optimizers could be
improved). In addition to bitvectors, SPUR also used the Z3 support for arrays
to model the C# heap and remove redundant stores. This is still another future
extension for all the Z3 work I've been doing in the context of the PyPy JIT.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2024/07/finding-simple-rewrite-rules-jit-z3.html" class="u-url">Finding Simple Rewrite Rules for the JIT with Z3</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/cf-bolz-tereick.html">CF Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2024/07/finding-simple-rewrite-rules-jit-z3.html" rel="bookmark">
            <time class="published dt-published" datetime="2024-07-12T19:14:09Z" itemprop="datePublished" title="2024-07-12 19:14">2024-07-12 19:14</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>In June I was at the <a href="https://pldi24.sigplan.org/">PLDI conference</a> in
Copenhagen to present a <a href="https://dl.acm.org/doi/10.1145/3652588.3663316">paper</a>
I co-authored with <a href="https://bernsteinbear.com/">Max Bernstein</a>. I also finally
met <a href="https://blog.regehr.org/">John Regehr</a>, who I'd been talking on social
media for ages but had never met. John has been working on compiler correctness
and better techniques for building compilers and optimizers since a very long
time. The blog post <a href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html">Finding JIT Optimizer Bugs using SMT Solvers and
Fuzzing</a>
was heavily inspired by this work. We talked a lot about his and his groups
work on using Z3 for
<a href="https://en.wikipedia.org/wiki/Superoptimization">superoptimization</a> and for
finding missing optimizations. I have applied some of the things John told me
about to the traces of PyPy's JIT, and wanted to blog about that. However, my
draft felt quite hard to understand. Therefore I have now written this current
post, to at least try to provide a somewhat gentler on-ramp to the topic.</p>
<p>In <em>this</em> post we will use the Python-API to Z3 to find local peephole rewrite
rules for the operations in the intermediate representation of PyPy's tracing
JIT. The code for this is simple enough that we can go through all of it.</p>
<p>The PyPy JIT produces traces of machine level instructions, which are optimized
and then turned into machine code. The optimizer uses a number of approaches to
make the traces more efficient. For integer operations it applies a number of
arithmetic simplification rules rules, for example <code>int_add(x, 0) -&gt; x</code>. When
implementing these rules in the JIT there are <strong>two problems</strong>: How do we know
that the rules are correct? And how do we know that we haven't forgotten any
rules? We'll try to answer both of these, but the first one in particular.</p>
<p>We'll be using Z3, a satisfiability module theories (SMT) solver which has good
bitvector support and most importantly an excellent Python API. We can use the
solver to reason about bitvectors, which are how we will model machine
integers.</p>
<p>To find rewrite rules, we will consider the binary operations (i.e. those
taking two arguments) in PyPy traces that take and produce integers. The
completely general form <code>op(x, y)</code> is not simplifiable on its own. But if
either <code>x == y</code>
or if one of the arguments is a constant, we can potentially simplify the
operation into a simpler form. The results are either the variable <code>x</code>, or a
(potentially different) constant. We'll ignore constant-folding where both
arguments of the binary operation are constants. The possible results for a
simplifiable binary operation are the variable <code>x</code> or another constant. This
leaves the following patterns as possibilities:</p>
<ul>
<li><code>op(x, x) == x</code></li>
<li><code>op(x, x) == c1</code></li>
<li><code>op(x, c1) == x</code></li>
<li><code>op(c1, x) == x</code></li>
<li><code>op(x, c1) == c2</code></li>
<li><code>op(c1, x) == c2</code></li>
</ul>
<p>Our approach will be to take every single supported binary integer operation,
instantiate all of these patterns, and try to ask Z3 whether the resulting
simplification is valid for all values of <code>x</code>.</p>
<h3 id="quick-intro-to-the-z3-python-api">Quick intro to the Z3 Python-API</h3>
<p>Here's a terminal session showing the use of the Z3 Python API:</p>
<div class="code"><pre class="code literal-block"><span class="go">&gt;&gt;&gt;&gt; import z3</span>
<span class="go">&gt;&gt;&gt;&gt; # construct a Z3 bitvector variable of width 8, with name x:</span>
<span class="go">&gt;&gt;&gt;&gt; x = z3.BitVec('x', 8)</span>
<span class="go">&gt;&gt;&gt;&gt; # construct a more complicated formula by using operator overloading:</span>
<span class="go">&gt;&gt;&gt;&gt; x + x</span>
<span class="go">x + x</span>
<span class="go">&gt;&gt;&gt;&gt; x + 1</span>
<span class="go">x + 1</span>
</pre></div>

<p>Z3 checks the "satisfiability" of a formula. This means that it tries to find
an example set of concrete values for the variables that occur in a formula,
such that the formula becomes true. Examples:</p>
<div class="code"><pre class="code literal-block"><span class="go">&gt;&gt;&gt;&gt; solver = z3.Solver()</span>
<span class="go">&gt;&gt;&gt;&gt; solver.check(x * x == 3)</span>
<span class="go">unsat</span>
<span class="go">&gt;&gt;&gt;&gt; # meaning no x fulfils this property</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;&gt; solver.check(x * x == 9)</span>
<span class="go">sat</span>
<span class="go">&gt;&gt;&gt;&gt; model = solver.model()</span>
<span class="go">&gt;&gt;&gt;&gt; model</span>
<span class="go">[x = 253]</span>
<span class="go">&gt;&gt;&gt;&gt; model[x].as_signed_long()</span>
<span class="go">-3</span>
<span class="go">&gt;&gt;&gt;&gt; # 253 is the same as -3 in two's complement arithmetic with 8 bits</span>
</pre></div>

<p>In order to use Z3 to prove something, we can ask Z3 to find counterexamples
for the statement, meaning concrete values that would make the negation of the
statement true:</p>
<div class="code"><pre class="code literal-block"><span class="go">&gt;&gt;&gt;&gt; solver.check(z3.Not(x ^ -1 == ~x))</span>
<span class="go">unsat</span>
</pre></div>

<p>The result <code>unsat</code> means that we just proved that <code>x ^ -1 == ~x</code> is true for
all <code>x</code>, because there is no value for <code>x</code> that makes <code>not (x ^ -1 == ~x)</code>
true (this works because -1 has all the bits set).</p>
<p>If we try to prove something incorrect in this way, the following happens:</p>
<div class="code"><pre class="code literal-block"><span class="go">&gt;&gt;&gt;&gt; solver.check(z3.Not(x ^ -1 == x))</span>
<span class="go">sat</span>
</pre></div>

<p><code>sat</code> shows that <code>x ^ -1 == x</code> is (unsurprisingly) not always true, and we can
ask for a counterexample:</p>
<div class="code"><pre class="code literal-block"><span class="go">&gt;&gt;&gt;&gt; solver.model()</span>
<span class="go">[x = 0]</span>
</pre></div>

<p>This way of proving this works because the <code>check</code> calls try to solve an
(implicit) "exists" quantifier, over all the Z3 variables used in the formula.
<code>check</code> will either return <code>z3.unsat</code>, which means that no concrete values make
the formula true; or <code>z3.sat</code>, which means that you can get some concrete
values that make the formula true by calling <code>solver.model()</code>.</p>
<p>In math terms we prove things using <code>check</code> by de-Morgan's rules for quantifiers:</p>
<p>$$ \lnot \exists x: \lnot f(x) \implies \forall x: f(x) $$</p>
<p>Now that we've seen the basics of using the Z3 API on a few small examples,
we'll use it in a bigger program.</p>
<h3 id="encoding-the-integer-operations-of-rpythons-jit-into-z3-formulas">Encoding the integer operations of RPython's JIT into Z3 formulas</h3>
<p>Now we'll use the API to reason about the integer operations of the PyPy JIT
intermediate representation (IR). The binary integer operations are:</p>
<div class="code"><pre class="code literal-block"><span class="n">opnames2</span> <span class="o">=</span> <span class="p">[</span>
<span class="s2">"int_add"</span><span class="p">,</span>
<span class="s2">"int_sub"</span><span class="p">,</span>
<span class="s2">"int_mul"</span><span class="p">,</span>
<span class="s2">"int_and"</span><span class="p">,</span>
<span class="s2">"int_or"</span><span class="p">,</span>
<span class="s2">"int_xor"</span><span class="p">,</span>
<span class="s2">"int_eq"</span><span class="p">,</span>
<span class="s2">"int_ne"</span><span class="p">,</span>
<span class="s2">"int_lt"</span><span class="p">,</span>
<span class="s2">"int_le"</span><span class="p">,</span>
<span class="s2">"int_gt"</span><span class="p">,</span>
<span class="s2">"int_ge"</span><span class="p">,</span>
<span class="s2">"uint_lt"</span><span class="p">,</span>
<span class="s2">"uint_le"</span><span class="p">,</span>
<span class="s2">"uint_gt"</span><span class="p">,</span>
<span class="s2">"uint_ge"</span><span class="p">,</span>
<span class="s2">"int_lshift"</span><span class="p">,</span>
<span class="s2">"int_rshift"</span><span class="p">,</span>
<span class="s2">"uint_rshift"</span><span class="p">,</span>
<span class="s2">"uint_mul_high"</span><span class="p">,</span>
<span class="s2">"int_pydiv"</span><span class="p">,</span>
<span class="s2">"int_pymod"</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

<p>There's not much special about the integer operations. Like in LLVM, most of
them are signedness-independent: <code>int_add</code>, <code>int_sub</code>, <code>int_mul</code>, ... work
correctly for unsigned integers but also for
<a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's-complement</a> signed
integers. Exceptions for that are order comparisons like <code>int_lt</code> etc. for
which we have unsigned variants <code>uint_lt</code> etc. All operations that produce a
boolean result return a full-width integer <code>0</code> or <code>1</code> (the PyPy JIT supports
only word-sized integers in its intermediate representation)</p>
<p>In order to reason about the IR operations, some ground work:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">z3</span>

<span class="n">INTEGER_WIDTH</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">"timeout"</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span> <span class="c1"># milliseconds, ie 10s</span>
<span class="n">xvar</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVec</span><span class="p">(</span><span class="s1">'x'</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>
<span class="n">constvar</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVec</span><span class="p">(</span><span class="s1">'const'</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>
<span class="n">constvar2</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVec</span><span class="p">(</span><span class="s1">'const2'</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>
<span class="n">TRUEBV</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVecVal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>
<span class="n">FALSEBV</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVecVal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>
</pre></div>

<p>And here's the a function to turn an integer IR operation of PyPy's JIT into Z3
formulas:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">""" computes a tuple of (result, valid_if) of Z3 formulas. `result` is the</span>
<span class="sd">    formula representing the result of the operation, given argument formulas</span>
<span class="sd">    arg0 and arg1. `valid_if` is a pre-condition that must be true for the</span>
<span class="sd">    result to be meaningful. """</span>
    <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">valid_if</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># the precondition is mostly True, with few exceptions</span>
    <span class="k">if</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_add"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">+</span> <span class="n">arg1</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_sub"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">-</span> <span class="n">arg1</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_mul"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">*</span> <span class="n">arg1</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_and"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">&amp;</span> <span class="n">arg1</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_or"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">|</span> <span class="n">arg1</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_xor"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">^</span> <span class="n">arg1</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_eq"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">arg0</span> <span class="o">==</span> <span class="n">arg1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_ne"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">arg0</span> <span class="o">!=</span> <span class="n">arg1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_lt"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">arg0</span> <span class="o">&lt;</span> <span class="n">arg1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_le"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">arg0</span> <span class="o">&lt;=</span> <span class="n">arg1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_gt"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">arg0</span> <span class="o">&gt;</span> <span class="n">arg1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_ge"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">arg0</span> <span class="o">&gt;=</span> <span class="n">arg1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"uint_lt"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">ULT</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"uint_le"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">ULE</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"uint_gt"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">UGT</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"uint_ge"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">UGE</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_lshift"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">&lt;&lt;</span> <span class="n">arg1</span>
        <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">arg1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">&lt;</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_rshift"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">&lt;&lt;</span> <span class="n">arg1</span>
        <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">arg1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">&lt;</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"uint_rshift"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">LShR</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>
        <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">arg1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">&lt;</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"uint_mul_high"</span><span class="p">:</span>
        <span class="c1"># zero-extend args to 2*INTEGER_WIDTH bit, then multiply and extract</span>
        <span class="c1"># highest INTEGER_WIDTH bits</span>
        <span class="n">zarg0</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">ZeroExt</span><span class="p">(</span><span class="n">INTEGER_WIDTH</span><span class="p">,</span> <span class="n">arg0</span><span class="p">)</span>
        <span class="n">zarg1</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">ZeroExt</span><span class="p">(</span><span class="n">INTEGER_WIDTH</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Extract</span><span class="p">(</span><span class="n">INTEGER_WIDTH</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">,</span> <span class="n">zarg0</span> <span class="o">*</span> <span class="n">zarg1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_pydiv"</span><span class="p">:</span>
        <span class="n">valid_if</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">/</span> <span class="n">arg1</span>
        <span class="n">psubx</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">arg1</span> <span class="o">-</span> <span class="n">arg0</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">If</span><span class="p">(</span><span class="n">arg1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">psubx</span><span class="p">,</span> <span class="o">-</span><span class="n">psubx</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">INTEGER_WIDTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_pymod"</span><span class="p">:</span>
        <span class="n">valid_if</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">%</span> <span class="n">arg1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="n">arg1</span> <span class="o">&amp;</span> <span class="n">z3</span><span class="o">.</span><span class="n">If</span><span class="p">(</span><span class="n">arg1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">INTEGER_WIDTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_is_true"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">arg0</span> <span class="o">!=</span> <span class="n">FALSEBV</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_is_zero"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">arg0</span> <span class="o">==</span> <span class="n">FALSEBV</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_neg"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">arg0</span>
    <span class="k">elif</span> <span class="n">opname</span> <span class="o">==</span> <span class="s2">"int_invert"</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">~</span><span class="n">arg0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"unknown operation "</span> <span class="o">+</span> <span class="n">opname</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span>

<span class="k">def</span><span class="w"> </span><span class="nf">cond</span><span class="p">(</span><span class="n">z3expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">""" helper function to turn a Z3 boolean result z3expr into a 1 or 0</span>
<span class="sd">    bitvector, using z3.If """</span>
    <span class="k">return</span> <span class="n">z3</span><span class="o">.</span><span class="n">If</span><span class="p">(</span><span class="n">z3expr</span><span class="p">,</span> <span class="n">TRUEBV</span><span class="p">,</span> <span class="n">FALSEBV</span><span class="p">)</span>
</pre></div>

<p>We map the semantics of a PyPy JIT operation to Z3 with the <code>z3_expression</code>
function. It takes the name of a JIT operation and its two (or one) arguments
into a pair of Z3 formulas, <code>result</code> and <code>valid_if</code>. The resulting formulas are
constructed with the operator overloading of Z3 variables/formulas.</p>
<p>The first element <code>result</code> of the result of <code>z3_expression</code> represents the result
of performing the operation. <code>valid_if</code> is a bool that represents a condition that
needs to be <code>True</code> in order for the result of the operation to be defined. E.g.
<code>int_pydiv(a, b)</code> is only valid if <code>b != 0</code>. Most operations are always valid,
so they return <code>True</code> as that condition (we'll ignore <code>valid_if</code> for a bit, but it
will become more relevant further down in the post).</p>
<p>We can define a helper function to prove things by finding counterexamples:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">prove</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
<span class="w">    </span><span class="sd">""" Try to prove a condition cond by searching for counterexamples of its negation. """</span>
    <span class="n">z3res</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">cond</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">z3res</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">unsat</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">z3res</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">unknown</span><span class="p">:</span> <span class="c1"># eg on timeout</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">z3res</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">sat</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"should be unreachable"</span>
</pre></div>

<h3 id="finding-rewrite-rules">Finding rewrite rules</h3>
<p>Now we can start finding our first rewrite rules, following the first pattern
<code>op(x, x) -&gt; x</code>. We do this by iterating over all the supported binary
operation names, getting the z3 expression for <code>op(x, x)</code> and then asking Z3 to
prove <code>op(x, x) == x</code>.</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span> <span class="n">opname</span> <span class="ow">in</span> <span class="n">opnames2</span><span class="p">:</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">xvar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prove</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">xvar</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(x, x) -&gt; x, </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>

<p>This yields the simplifications:</p>
<div class="code"><pre class="code literal-block"><span class="n">int_and</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
</pre></div>

<h3 id="synthesizing-constants">Synthesizing constants</h3>
<p>Supporting the next patterns is harder: <code>op(x, x) == c1</code>, <code>op(x, c1) == x</code>, and
<code>op(c1, x) == x</code>. We don't know which constants to pick to try to get Z3 to
prove the equality. We could iterate over common constants like <code>0</code>, <code>1</code>,
<code>MAXINT</code>, etc, or even over all the 256 values for a bitvector of length 8.
However, we will instead ask Z3 to find the constants for us too.</p>
<p>This can be done by using quantifiers, in this case <code>z3.ForAll</code>. The query we
pose to Z3 is "does there exist a constant <code>c1</code> such that for all <code>x</code> the
following is true: <code>op(x, c1) == x</code>? Note that the constant <code>c1</code> is not
necessarily unique, there could be many of them. We generate several matching
constant, and add that they must be different to the condition of the second
and further queries.</p>
<p>We can express this in a helper function:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">find_constant</span><span class="p">(</span><span class="n">z3expr</span><span class="p">,</span> <span class="n">number_of_results</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="p">(</span>
        <span class="p">[</span><span class="n">xvar</span><span class="p">],</span>
        <span class="n">z3expr</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_results</span><span class="p">):</span>
        <span class="n">checkres</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">checkres</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">sat</span><span class="p">:</span>
            <span class="c1"># if a solver check succeeds, we can ask for a model, which is</span>
            <span class="c1"># concrete values for the variables constvar</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
            <span class="n">const</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="n">constvar</span><span class="p">]</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">const</span>
            <span class="c1"># make sure we don't generate the same constant again on the</span>
            <span class="c1"># next call</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">constvar</span> <span class="o">!=</span> <span class="n">const</span><span class="p">,</span> <span class="n">condition</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no (more) constants found</span>
            <span class="k">break</span>
</pre></div>

<p>We can use this new function for the three mentioned patterns:</p>
<div class="code"><pre class="code literal-block"><span class="c1"># try to find constants for op(x, x) == c</span>
<span class="k">for</span> <span class="n">opname</span> <span class="ow">in</span> <span class="n">opnames2</span><span class="p">:</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">xvar</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">find_constant</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">constvar</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(x, x) -&gt; </span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="c1"># try to find constants for op(x, c) == x and op(c, x) == x</span>
<span class="k">for</span> <span class="n">opname</span> <span class="ow">in</span> <span class="n">opnames2</span><span class="p">:</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">constvar</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">find_constant</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">xvar</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(x, </span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s2">) -&gt; x"</span><span class="p">)</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">constvar</span><span class="p">,</span> <span class="n">xvar</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">find_constant</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">xvar</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s2">, x) -&gt; x"</span><span class="p">)</span>
<span class="c1"># this code is not quite correct, we'll correct it later</span>
</pre></div>

<p>Together this yields the following new simplifications:</p>
<div class="code"><pre class="code literal-block"><span class="cp"># careful, these are not all correct!</span>
<span class="n">int_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">int_ne</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_le</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">int_gt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">uint_lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_le</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">uint_gt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">uint_rshift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_pymod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_add</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_mul</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_and</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_and</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_or</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_xor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_lshift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_rshift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">uint_rshift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_pydiv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_pymod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
</pre></div>

<p>Most of these look good at first glance, but the last one reveals a problem:
we've been ignoring the <code>valid_if</code> expression up to now. We can stop doing that by
changing the code like this, which adds <code>z3.And(valid_if, ...)</code> to the argument of
the calls to <code>find_constant</code>:</p>
<div class="code"><pre class="code literal-block"><span class="c1"># try to find constants for op(x, x) == c, op(x, c) == x and op(c, x) == x</span>
<span class="k">for</span> <span class="n">opname</span> <span class="ow">in</span> <span class="n">opnames2</span><span class="p">:</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">xvar</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">find_constant</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">valid_if</span><span class="p">,</span> <span class="n">result</span> <span class="o">==</span> <span class="n">constvar</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(x, x) -&gt; </span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="c1"># try to find constants for op(x, c) == x and op(c, x) == x</span>
<span class="k">for</span> <span class="n">opname</span> <span class="ow">in</span> <span class="n">opnames2</span><span class="p">:</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">constvar</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">find_constant</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">valid_if</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(x, </span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s2">) -&gt; x"</span><span class="p">)</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">constvar</span><span class="p">,</span> <span class="n">xvar</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">find_constant</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">valid_if</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s2">, x) -&gt; x"</span><span class="p">)</span>
</pre></div>

<p>And we get this list instead:</p>
<div class="code"><pre class="code literal-block"><span class="n">int_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">int_ne</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_le</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">int_gt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">uint_lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_le</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">uint_gt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">int_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_add</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_mul</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_and</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_and</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_or</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_xor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_lshift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_rshift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">uint_rshift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="n">int_pydiv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
</pre></div>

<h3 id="synthesizing-two-constants">Synthesizing two constants</h3>
<p>For the patterns <code>op(x, c1) == c2</code> and <code>op(c1, x) == c2</code> we need to synthesize
two constants. We can again write a helper method for that:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">find_2consts</span><span class="p">(</span><span class="n">z3expr</span><span class="p">,</span> <span class="n">number_of_results</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="p">(</span>
        <span class="p">[</span><span class="n">xvar</span><span class="p">],</span>
        <span class="n">z3expr</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_results</span><span class="p">):</span>
        <span class="n">checkres</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">checkres</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">sat</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
            <span class="n">const</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="n">constvar</span><span class="p">]</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">()</span>
            <span class="n">const2</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="n">constvar2</span><span class="p">]</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">const</span><span class="p">,</span> <span class="n">const2</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Or</span><span class="p">(</span><span class="n">constvar</span> <span class="o">!=</span> <span class="n">const</span><span class="p">,</span> <span class="n">constvar2</span> <span class="o">!=</span> <span class="n">const2</span><span class="p">),</span> <span class="n">condition</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
</pre></div>

<p>And then use it like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span> <span class="n">opname</span> <span class="ow">in</span> <span class="n">opnames2</span><span class="p">:</span>
    <span class="c1"># try to find constants c1, c2 such that op(c1, x) -&gt; c2</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">constvar</span><span class="p">,</span> <span class="n">xvar</span><span class="p">)</span>
    <span class="n">consts</span> <span class="o">=</span> <span class="n">find_2consts</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">valid_if</span><span class="p">,</span> <span class="n">result</span> <span class="o">==</span> <span class="n">constvar2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">const</span><span class="p">,</span> <span class="n">const2</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s2">, x) -&gt; </span><span class="si">{</span><span class="n">const2</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="c1"># try to find constants c1, c2 such that op(x, c1) -&gt; c2</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">constvar</span><span class="p">)</span>
    <span class="n">consts</span> <span class="o">=</span> <span class="n">find_2consts</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">valid_if</span><span class="p">,</span> <span class="n">result</span> <span class="o">==</span> <span class="n">constvar2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">const</span><span class="p">,</span> <span class="n">const2</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="s2">(x, </span><span class="si">%s</span><span class="s2">) -&gt; </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">const2</span><span class="p">))</span>
</pre></div>

<p>Which yields some straightforward simplifications:</p>
<div class="code"><pre class="code literal-block"><span class="n">int_mul</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_and</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_and</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_le</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">uint_gt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">int_lshift</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_rshift</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_rshift</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_mul_high</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_mul_high</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_mul_high</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_mul_high</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_pymod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_pymod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
</pre></div>

<p>A few require a bit more thinking:</p>
<div class="code"><pre class="code literal-block"><span class="n">int_or</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="n">int_or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
</pre></div>

<p>The are true because in two's complement, <code>-1</code> has all bits set.</p>
<p>The following ones require recognizing that <code>-9223372036854775808 == -2**63</code> is
the most negative signed 64-bit integer, and <code>9223372036854775807 == 2 ** 63 -
1</code> is the most positive one:</p>
<div class="code"><pre class="code literal-block"><span class="n">int_lt</span><span class="p">(</span><span class="mi">9223372036854775807</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_le</span><span class="p">(</span><span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">int_le</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">9223372036854775807</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">int_gt</span><span class="p">(</span><span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_gt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">9223372036854775807</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">int_ge</span><span class="p">(</span><span class="mi">9223372036854775807</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">int_ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
</pre></div>

<p>The following ones are true because the bitpattern for <code>-1</code> is the largest
unsigned number:</p>
<div class="code"><pre class="code literal-block"><span class="n">uint_lt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_le</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="n">uint_gt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="n">uint_ge</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
</pre></div>

<h3 id="strength-reductions">Strength Reductions</h3>
<p>All the patterns so far only had a variable or a constant on the target of the
rewrite. We can also use the machinery to do strengh-reductions where we
generate a single-argument operation <code>op1(x)</code> for input operations <code>op(x, c1)</code>
or <code>op(c1, x)</code>. To achieve this, we try all combinations of binary and unary
operations. (We won't consider strength reductions where a binary operation
gets turned into a "cheaper" other binary operation here.)</p>
<div class="code"><pre class="code literal-block"><span class="n">opnames1</span> <span class="o">=</span> <span class="p">[</span>
<span class="s2">"int_is_true"</span><span class="p">,</span>
<span class="s2">"int_is_zero"</span><span class="p">,</span>
<span class="s2">"int_neg"</span><span class="p">,</span>
<span class="s2">"int_invert"</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">opname</span> <span class="ow">in</span> <span class="n">opnames2</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">opname1</span> <span class="ow">in</span> <span class="n">opnames1</span><span class="p">:</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">constvar</span><span class="p">)</span>
        <span class="c1"># try to find a constant op(x, c) == g(x)</span>
        <span class="n">result1</span><span class="p">,</span> <span class="n">valid_if1</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname1</span><span class="p">,</span> <span class="n">xvar</span><span class="p">)</span>
        <span class="n">consts</span> <span class="o">=</span> <span class="n">find_constant</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">valid_if</span><span class="p">,</span> <span class="n">valid_if1</span><span class="p">,</span> <span class="n">result</span> <span class="o">==</span> <span class="n">result1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(x, </span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="n">opname1</span><span class="si">}</span><span class="s2">(x)"</span><span class="p">)</span>

        <span class="c1"># try to find a constant op(c, x) == g(x)</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">valid_if</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">constvar</span><span class="p">,</span> <span class="n">xvar</span><span class="p">)</span>
        <span class="n">result1</span><span class="p">,</span> <span class="n">valid_if1</span> <span class="o">=</span> <span class="n">z3_expression</span><span class="p">(</span><span class="n">opname1</span><span class="p">,</span> <span class="n">xvar</span><span class="p">)</span>
        <span class="n">consts</span> <span class="o">=</span> <span class="n">find_constant</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">valid_if</span><span class="p">,</span> <span class="n">valid_if1</span><span class="p">,</span> <span class="n">result</span> <span class="o">==</span> <span class="n">result1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">opname</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s2">, x) -&gt; </span><span class="si">{</span><span class="n">opname1</span><span class="si">}</span><span class="s2">(x)"</span><span class="p">)</span>
</pre></div>

<p>Which yields the following new simplifications:</p>
<div class="code"><pre class="code literal-block"><span class="n">int_sub</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_neg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_sub</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_invert</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_neg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_mul</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_neg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_invert</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_xor</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_invert</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_eq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_ne</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_true</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_ne</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_true</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">uint_lt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_true</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">uint_lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">uint_le</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_true</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">uint_le</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">uint_gt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_true</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">uint_gt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">uint_ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_true</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">uint_ge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_is_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">int_pydiv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int_neg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<h3 id="conclusions">Conclusions</h3>
<p>With not very little code we managed to generate a whole lot of local
simplifications for integer operations in the IR of PyPy's JIT. The rules
discovered that way are "simple", in the sense that they only require looking
at a single instruction, and not where the arguments of that instruction came
from. They also don't require any knowledge about the properties of the
arguments of the instructions (e.g. that they are positive).</p>
<p>The rewrites in this post have mostly been in PyPy's JIT already. But now we
mechanically confirmed that they are correct. I've also added the remaining
useful looking ones, in particular <code>int_eq(x, 0) -&gt; int_is_zero(x)</code> etc.</p>
<p>If we wanted to scale this approach up, we would have to work much harder!
There are a bunch of problems that come with generalizing the approach to
looking at sequences of instructions:</p>
<ul>
<li>
<p>Combinatorial explosion: if we look at sequences of instructions, we very
  quickly get a combinatorial explosion and it becomes untractable to try all
  combinations.</p>
</li>
<li>
<p>Finding non-minimal patterns: Some complicated simplifications can be
  instances of simpler ones. For example, because <code>int_add(x, 0) -&gt; x</code>, it's
  also true that <code>int_add(int_sub(x, y), 0) -&gt; int_sub(x, y)</code>. If we simply
  generate all possible sequences, we will find the latter simplification rule,
  which we would usually not care about.</p>
</li>
<li>
<p>Unclear usefulness: if we simply generate all rewrites up to a certain number
  of instructions, we will get a lot of patterns that are useless in the sense
  that they typically aren't found in realistic programs. It would be much
  better to somehow focus on the patterns that real benchmarks are using.</p>
</li>
</ul>
<p>In the <a href="../posts/2024/07/mining-jit-traces-missing-optimizations-z3.html">next blog post</a> I'll discuss an alternative approach to simply generating
all possible sequences of instructions, that tries to address these problems.
This works by analyzing the real traces of benchmarks and mining those for
inefficiencies, which only shows problems that occur in actual programs.</p>
<h3 id="sources">Sources</h3>
<p>I've been re-reading a lot of blog posts from John's blog:</p>
<ul>
<li><a href="https://blog.regehr.org/archives/1109">Let’s Work on an LLVM Superoptimizer</a></li>
<li><a href="https://blog.regehr.org/archives/1146">Early Superoptimizer Results</a></li>
<li><a href="https://blog.regehr.org/archives/1252">A Few Synthesizing Superoptimizer Results</a></li>
<li><a href="https://blog.regehr.org/archives/1636">Synthesizing Constants</a></li>
</ul>
<p>but also papers:</p>
<ul>
<li><a href="https://arxiv.org/pdf/1711.04422">A Synthesizing Superoptimizer</a></li>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3649837">Hydra: Generalizing Peephole Optimizations with Program Synthesis</a></li>
</ul>
<p>Another of my favorite blogs has been <a href="https://www.philipzucker.com/">Philipp Zucker's
blog</a> in the last year or two, lots of excellent
posts about/using Z3 on there.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2024/05/vmprof-firefox-converter.html" class="u-url">Profiling PyPy using the Firefox profiler user interface</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/christoph-jung.html">Christoph Jung</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2024/05/vmprof-firefox-converter.html" rel="bookmark">
            <time class="published dt-published" datetime="2024-04-26T14:38:00Z" itemprop="datePublished" title="2024-04-26 14:38">2024-04-26 14:38</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <h3 id="introduction">Introduction</h3>
<p>If you ever wanted to profile your Python code on PyPy, you probably came across <a href="https://vmprof.readthedocs.io/en/latest/vmprof.html">VMProf</a> — a statistical profiler for PyPy.</p>
<p>VMProf's console output can already give some insights into where your code spends time, 
but it is far from showing all the information captured while profiling.</p>
<p>There have been some tools around to visualize VMProf's output.
Unfortunately the vmprof.com user interface is no longer available and vmprof-server is not as easy to use, you may want to take a look at a local viewer or converter.
Those so far could give you some general visualizations of your profile, but do not show any PyPy related context like PyPy's log output (<a href="https://rpython.readthedocs.io/en/latest/logging.html">PyPyLog</a>, which is output when using the PYPYLOG environment variable to log JIT actions).</p>
<p>To bring all of those features together in one tool, you may take a look at the vmprof-firefox-converter.</p>
<p>Created in the context of my bachelor's thesis, the vmprof-firefox-converter is a tool for analyzing VMProf profiles with the <a href="https://profiler.firefox.com/">Firefox profiler</a> user interface. 
Instead of building a new user interface from scratch, this allows us to reuse the user interface work Mozilla put into the Firefox profiler.
The Firefox profiler offers a timeline where you can zoom into profiles and work with different visualizations like a flame graph or a stack chart.
To understand why there is time spent inside a function, you can revisit the source code and even dive into the intermediate representation of functions executed by PyPy's just-in-time compiler.
Additionally, there is a visualization for PyPy's log output, to keep track whether PyPy spent time inside the interpreter, JIT or GC throughout the profiling time.</p>
<h3 id="profiling-word-count">Profiling word count</h3>
<p>In this blog post, I want to show an example of how to use the vmprof-firefox-converter for a simple Python program.
Based on Ben Hoyt's blog <a href="https://benhoyt.com/writings/count-words/">Performance comparison: counting words in Python, Go, C++, C, AWK, Forth, and Rust</a> we will profile two python versions of a word counter running on PyPy. One being a bit more optimized. For this, VMProf will be used, but instead of just going with the console output, we will use the Firefox profiler user interface.</p>
<p>At first, we are going to look at a simple way of counting words with <code>Collections.Counter</code>.
This will read one line from the standard input at a time and count the words with <code>counter.update()</code></p>
<div class="code"><pre class="code literal-block">counts = collections.Counter()
for line in sys.stdin:
    words = line.lower().split()
    counts.update(words)

for word, count in counts.most_common():
    print(word, count)
</pre></div>

<p>To start profiling, simply execute:
<code>pypy -m vmprofconvert -run simple.py &lt;kjvbible_x10.txt</code></p>
<p>This will run the above code with vmprof, automatically capture and convert the results and finally open the Firefox profiler. </p>
<p>The input file is the king James version of the bible concatenated ten times.</p>
<p>To get started, we take a look at the call stack.</p>
<p><img src="https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/simple_call_stack_crp.png?raw=true">
Here we see that most of the time is spent in native code (marked as blue) e.g., the <code>counter.update()</code> or <code>split()</code> C implementation.</p>
<p>Now let's proceed with the more optimized version.
This time we read 64 Kb of data from the standard input and count the words with <code>counter.update()</code>.</p>
<div class="code"><pre class="code literal-block">counts = collections.Counter()
remaining = ''
while True:
    chunk = remaining + sys.stdin.read(64*1024)
    if not chunk:
        break
    last_lf = chunk.rfind('\n')  # process to last LF character
    if last_lf == -1:
        remaining = ''
    else:
        remaining = chunk[last_lf+1:]
        chunk = chunk[:last_lf]
    counts.update(chunk.lower().split())

for word, count in counts.most_common():
    print(word, count)
</pre></div>

<p>As we did before, we are going to take a peek at the call stack.</p>
<p><img src="https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/optimized_call_stack_crp.png?raw=true"></p>
<p>Now there is more time spent in native code, caused by larger chunks of text passed to  <code>counter.update()</code>.</p>
<p>This becomes even more clear by comparing the stack charts.</p>
<p><img src="https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/simple_stack_chart.png?raw=true"></p>
<p>Here, in the unoptimized case, we only read in one line at each loop iteration.
This results in small "spikes" in the stack chart. </p>
<p>But let's take an even closer look.</p>
<p><img src="https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/simple_stack_chart_zoom.png?raw=true"></p>
<p>Zoomed in, we see the call stack alternating between <code>_count_elements()</code> and (unfortunately unsymbolized) native calls coming from reading and splitting the input text (e.g., <code>decode()</code>).</p>
<p>Let us now take a look at the optimized case.</p>
<p><img src="https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/optimized_stack_chart.png?raw=true"></p>
<p>And if we look closer at the same interval as before, we see some spikes, but slightly different.</p>
<p><img src="https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/optimized_stack_chart_zoom.png?raw=true"></p>
<p>Even though we do not want to compare the (amount of) milliseconds directly, we clearly see that the spikes are wider, i.e. the time spent in those function calls is longer.
You may already know where this comes from.
We read a 64 Kb chunk of data from std in and pass that to <code>counter.update()</code>, so both these tasks do more work and take longer.
Bigger chunks mean there is less alternating between reading and counting, so there is more time spent doing work than "doing" loop iterations.</p>
<h3 id="getting-started">Getting started</h3>
<p>You can get the converter from <a href="https://github.com/Cskorpion/vmprof-firefox-converter">GitHub</a>.</p>
<p>Both VMProf and the vmprof-firefox-converter were created for profiling PyPy, but you can also use them with CPython. </p>
<p>This project is still somewhat experimental, so if you want to try it out, please let us know whether it worked for you.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2024/04/pypy-v7316-release.html" class="u-url">PyPy v7.3.16 release</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/mattip.html">mattip</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2024/04/pypy-v7316-release.html" rel="bookmark">
            <time class="published dt-published" datetime="2024-04-23T12:22:08Z" itemprop="datePublished" title="2024-04-23 12:22">2024-04-23 12:22</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <section id="pypy-v7-3-16-release-of-python-2-7-3-9-and-3-10"><h2>PyPy v7.3.16: release of python 2.7, 3.9, and 3.10</h2>
<p>The PyPy team is proud to release version 7.3.16 of PyPy.</p>
<p>This release includes security fixes from upstream CPython, and bugfixes to the
garbage collector, described in a <a class="reference external" href="https://www.pypy.org/posts/2024/03/fixing-bug-incremental-gc.html">gc bug-hunt blog post</a>.</p>
<p>The release includes three different interpreters:</p>
<blockquote>
<ul class="simple">
<li><p>PyPy2.7, which is an interpreter supporting the syntax and the features of
Python 2.7 including the stdlib for CPython 2.7.18+ (the <code class="docutils literal">+</code> is for
backported security updates)</p></li>
<li><p>PyPy3.9, which is an interpreter supporting the syntax and the features of
Python 3.9, including the stdlib for CPython 3.9.19.</p></li>
<li><p>PyPy3.10, which is an interpreter supporting the syntax and the features of
Python 3.10, including the stdlib for CPython 3.10.14.</p></li>
</ul>
</blockquote>
<p>The interpreters are based on much the same codebase, thus the multiple
release. This is a micro release, all APIs are compatible with the other 7.3
releases. It follows after 7.3.15 release on Jan 15, 2024</p>
<p>We recommend updating. You can find links to download the v7.3.16 releases here:</p>
<blockquote>
<p><a class="reference external" href="https://pypy.org/download.html">https://pypy.org/download.html</a></p>
</blockquote>
<p>We would like to thank our donors for the continued support of the PyPy
project. If PyPy is not quite good enough for your needs, we are available for
<a class="reference external" href="https://www.pypy.org/pypy-sponsors.html">direct consulting</a> work. If PyPy is helping you out, we would love to hear
about it and encourage submissions to our <a class="reference external" href="https://pypy.org/blog">blog</a> via a pull request
to <a class="reference external" href="https://github.com/pypy/pypy.org">https://github.com/pypy/pypy.org</a></p>
<p>We would also like to thank our contributors and encourage new people to join
the project. PyPy has many layers and we need help with all of them: bug fixes,
<a class="reference external" href="https://doc.pypy.org/">PyPy</a> and <a class="reference external" href="https://rpython.readthedocs.org">RPython</a> documentation improvements, or general <a class="reference external" href="https://doc.pypy.org/en/latest/project-ideas.html">help</a> with
making RPython's JIT even better.</p>
<p>If you are a python library maintainer and use C-extensions, please consider
making a <a class="reference external" href="https://hpyproject.org/">HPy</a> / <a class="reference external" href="https://cffi.readthedocs.io">CFFI</a> / <a class="reference external" href="https://cppyy.readthedocs.io">cppyy</a> version of your library that would be performant
on PyPy. In any case, both <a class="reference external" href="https://github.com/joerick/cibuildwheel">cibuildwheel</a> and the <a class="reference external" href="https://github.com/matthew-brett/multibuild">multibuild system</a> support
building wheels for PyPy.</p>
<section id="what-is-pypy"><h3>What is PyPy?</h3>
<p>PyPy is a Python interpreter, a drop-in replacement for CPython
It's fast (<a class="reference external" href="https://speed.pypy.org">PyPy and CPython 3.7.4</a> performance
comparison) due to its integrated tracing JIT compiler.</p>
<p>We also welcome developers of other <a class="reference external" href="https://rpython.readthedocs.io/en/latest/examples.html">dynamic languages</a> to see what RPython
can do for them.</p>
<p>We provide binary builds for:</p>
<blockquote>
<ul class="simple">
<li><p><strong>x86</strong> machines on most common operating systems
(Linux 32/64 bits, Mac OS 64 bits, Windows 64 bits)</p></li>
<li><p>64-bit <strong>ARM</strong> machines running Linux (<code class="docutils literal">aarch64</code>).</p></li>
<li><p>Apple <strong>M1 arm64</strong> machines (<code class="docutils literal">macos_arm64</code>).</p></li>
<li><p><strong>s390x</strong> running Linux</p></li>
</ul>
</blockquote>
<p>PyPy support Windows 32-bit, Linux PPC64 big- and little-endian, and Linux ARM
32 bit, but does not release binaries. Please reach out to us if you wish to
sponsor binary releases for those platforms. Downstream packagers provide
binary builds for debian, Fedora, conda, OpenBSD, FreeBSD, Gentoo, and more.</p>
</section><section id="what-else-is-new"><h3>What else is new?</h3>
<p>For more information about the 7.3.16 release, see the <a class="reference external" href="https://doc.pypy.org/en/latest/release-v7.3.16.html#changelog">full changelog</a>.</p>
<p>Please update, and continue to help us make pypy better.</p>
<p>Cheers,
The PyPy Team</p>
</section></section>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2024/03/fixing-bug-incremental-gc.html" class="u-url">Fixing a Bug in PyPy's Incremental GC</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/cf-bolz-tereick.html">CF Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2024/03/fixing-bug-incremental-gc.html" rel="bookmark">
            <time class="published dt-published" datetime="2024-03-26T19:14:09Z" itemprop="datePublished" title="2024-03-26 19:14">2024-03-26 19:14</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <h2 id="introduction">Introduction</h2>
<p>Since last summer, I've been looking on and off into a weird and hard to
reproduce <a href="https://github.com/pypy/pypy/issues/3959">crash bug in PyPy</a>. It was
manifesting only on CI, and it seemed to always happen in the AST rewriting
phase of <a href="https://pytest.org">pytest</a>, the symptoms being that PyPy would crash
with a segfault. All my attempts to reproduce it locally failed, and my
attempts to try to understand the problem by dumping the involved ASTs lead
nowhere.</p>
<p>A few weeks ago, we got <a href="https://github.com/PyO3/pyo3/issues/3766">two more</a>
<a href="https://github.com/orgs/pypy/discussions/4923">bug reports</a>, the last one by
the authors of the <a href="https://nanobind.readthedocs.io/">nanobind</a> binding
generator, with the same symptoms: crash in AST rewriting, only on CI. I
decided to make a more serious push to try to find the bug this time.
Ultimately the problem turned out to be several bugs in PyPy's garbage
collector (GC) that had been there since its inception in
<a href="../posts/2013/10/incremental-garbage-collector-in-pypy-8956893523842234676.html">2013</a>.
Understanding the
situation turned out to be quite involved, additionally complicated by this
being the first time that I was working on this particular aspect of PyPy's GC.
Since the bug was so much work to find, I thought I'd write a blog post about
it.</p>
<p>The blog post consists of three parts: first a chronological description of
what I did to find the bug, a technical explanation of what goes wrong, some
reflections on the bug (and then a bonus bug I also found in the process).</p>
<h2 id="finding-the-bug">Finding the Bug</h2>
<p>I started from the failing <a href="https://github.com/wjakob/nanobind/actions/runs/8234561874/job/22516568891">nanobind CI
runs</a>
that ended with a segfault of the PyPy interpreter. This was only an
intermittent problem, not every run was failing. When I tried to just run the
test suite locally, I couldn't get it to fail. Therefore at first I tried to
learn more about what was happening by looking on the CI runners.</p>
<h3 id="running-on-ci">Running on CI</h3>
<p>I forked the nanobind repo and hacked the CI script in order to get it to use a
PyPy build with <a href="https://doc.pypy.org/en/latest/build.html#making-a-debug-build-of-pypy">full debug information and more assertions turned on</a>. In order
to increase the probability of seeing the crash I added an otherwise unused
<a href="https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs">matrix</a>
variable to the CI script that just contained 32 parameters. This means every
build is done 32 times (sorry Github for wasting your CPUs 😕). With that
amount of repetition, I got at least one job of every build that was crashing.</p>
<p>Then I added the <code>-Xfaulthandler</code> option to the PyPy command which will use the
<a href="https://docs.python.org/3.11/library/faulthandler.html">faulthandler</a> module
try to print a Python stacktrace if the VM segfaults to confirm that PyPy was
indeed crashing in the <a href="https://docs.python.org/3/library/ast.html">AST</a>
<a href="https://github.com/pytest-dev/pytest/blob/main/src/_pytest/assertion/rewrite.py">rewriting
phase</a>
of pytest, which pytest uses for <a href="https://docs.pytest.org/en/7.1.x/how-to/assert.html#asserting-with-the-assert-statement">nicer
assertions</a>.
I experimented with hacking our faulthandler implementation to also give me a
C-level callstack, but that didn't work as well as I hoped.</p>
<p>Then I tried to run <a href="https://sourceware.org/gdb/">gdb</a> on CI to try to get it
to print a C callstack at the crash point. You can get gdb to execute commands
as if typed at the prompt with the <code>-ex</code> commandline option, I used something
like this:</p>
<div class="code"><pre class="code literal-block">gdb -ex "set confirm off" -ex "set pagination off" -ex \
    "set debuginfod enabled off" -ex run -ex where -ex quit \
    --args &lt;command&gt; &lt;arguments&gt;
</pre></div>

<p>But unfortunately the crash never occurred when running in gdb.</p>
<p>Afterwards I tried the next best thing, which was configuring the CI runner to
<a href="https://github.com/itamarst/gha-upload-cores">dump a core file and upload it as a build
artifact</a>, which worked. Looking
at the cores locally only sort of worked, because I am running a different
version of Ubuntu than the CI runners. So I used
<a href="https://mxschmitt.github.io/action-tmate/">tmate</a> to be able to log into the
CI runner after a crash and interactively used gdb there. Unfortunately what I
learned from that was that the bug was some kind of <strong>memory corruption</strong>,
which is always incredibly unpleasant to debug. Basically the header word of a
Python object had been corrupted somehow at the point of the crash, which means
that it's <a href="https://en.wikipedia.org/wiki/Virtual_method_table">vtable</a> wasn't
usable any more.</p>
<p>(Sidenote: <a href="../posts/2009/10/gc-improvements-6174120095428192954.html#unifying-the-vtable-ptr-with-the-gc-header">PyPy doesn't really use a vtable
pointer</a>,
instead it uses half a word in the header for the vtable, and the other half
for flags that the GC needs to keep track of the state of the object.
Corrupting all this is still bad.)</p>
<h3 id="reproducing-locally">Reproducing Locally</h3>
<p>At that point it was clear that I had to push to reproduce the problem on my
laptop, to allow me to work on the problem more directly and not to always have
to go via the CI runner. Memory corruption bugs often have a lot of randomness
(depending on which part of memory gets modified, things might crash or more
likely just happily keep running). Therefore I decided to try to brute-force
reproducing the crash by simply running the tests many many times. Since the
crash happened in the AST rewriting phase of pytest, and that happens only if
no <a href="https://stackoverflow.com/questions/2998215/if-python-is-interpreted-what-are-pyc-files">pyc
files</a>
of the bytecode-compiled rewritten ASTs exist, I made sure to delete them
before every test run.</p>
<p>To repeat the test runs I used
<a href="https://tratt.net/laurie/src/multitime/">multitime</a>, which is a simple program
that runs a command repeatedly. It's meant for lightweight benchmarking
purposes, but it also halts the execution of the command if that command exits
with an error (and it sleeps a small random time between runs, which might help
with randomizing the situation, maybe). Here's a demo:</p>
<script src="https://asciinema.org/a/648877.js" id="asciicast-648877" async="true"></script><p>(<a href="https://bernsteinbear.com/">Max</a> pointed out
<a href="https://github.com/silentbicycle/autoclave">autoclave</a> to me when reviewing
this post, which is a more dedicated tool for this job.)</p>
<p>Thankfully, running the tests repeatedly eventually lead to a crash, solving my
"only happens on CI" problem. I then tried various variants to exclude possible
sources of errors. The first source of errors to exclude in PyPy bugs is the
just-in-time compiler, so I reran the tests with <code>--jit off</code> to see whether I
could still get it to crash, and thankfully I eventually could (JIT bugs are
often very annoying).</p>
<p>Next source of bugs to exclude where C-extensions. Since those were the tests
of nanobind, a framework for creating C-extension modules I was a bit worried
that the bug might be in our emulation of CPython's C-API. But running PyPy
with the <code>-v</code> option (which will print all the imports as they happen)
confirmed that at the point of crash no C-extension had been imported yet.</p>
<h3 id="using-rr">Using <code>rr</code>
</h3>
<p>I still couldn't get the bug to happen in GDB, so the tool I tried next was
<a href="https://rr-project.org/">rr, the "reverse debugger"</a>. rr can record the execution of a program and
later replay it arbitrarily often. This gives you a time-traveling debugger
that allows you to execute the program backwards in addition to forwards.
Eventually I managed to get the crash to happen when running the tests with
<code>rr record --chaos</code> (<code>--chaos</code> randomizes some decisions that rr takes, to try to
increase the chance of reproducing bugs).</p>
<p>Using rr well is quite hard, and I'm not very good at it. The main approach I
use with rr to debug memory corruption is to replay the crash, then set a
<a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Set-Watchpoints.html">watchpoint</a>
for the corrupted memory location, then use the command <code>reverse-continue</code> to
find the place in the code that mutated the memory location. <code>reverse-continue</code>
is like <code>continue</code>, except that it will execute the program backwards from the
current point. Here's a little demo of this:</p>
<script src="https://asciinema.org/a/648814.js" id="asciicast-648814" async="true"></script><p>Doing this for my bug revealed that the object that was being corrupted was
erroneously collected by the garbage collector. For some reason the GC had
wrongly decided that the object was no longer reachable and therefore put the
object into a freelist by writing a pointer to the next entry in the freelist
into the first word of the object, overwriting the object's header. The next
time the object was used things crashed.</p>
<h3 id="side-quest-wrong-gc-assertions">Side-quest: wrong GC assertions</h3>
<p>At this point in the process, I got massively side-tracked. PyPy's GC has a
number of debug modes that you can optionally turn on. Those slow down the
program execution a lot, but they should in theory help to understand why the
GC goes wrong. When I turned them on, I was getting a failing assertion really
early in the test execution, complaining about an invariant violation in the GC
logic. At first this made me very happy. I thought that this would help me fix
the bug more quickly.</p>
<p>Extremely frustratingly, after two days of work I concluded that the assertion
logic itself was wrong. I have fixed that in the meantime too, the details
of that are in the bonus section at the end of the post.</p>
<h3 id="using-gdb-scripting-to-find-the-real-bug">Using GDB scripting to find the real bug</h3>
<p>After that disaster I went back to the earlier rr recording without GC assertions
and tried to understand in more detail why the GC decided to free an object
that was still being referenced. To be able to do that I used the <a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Python-API.html">GDB Python
scripting
API</a> to
write some helper commands to understand the state of the GC heap (rr is an
extension of GDB, so the GDB scripting API works in rr too).</p>
<p>The first (small) helper command I wrote with the GDB scripting API was a way
to pretty-print the currently active GC flags of a random PyPy object, starting
just from the pointer. The more complex command I wrote was an object tracer,
which follows pointers to GC objects starting from a root object to explore the
object graph. The object tracer isn't complete, it doesn't deal with all the
complexities of PyPy's GC. But it was good enough to help me with my problem, I
found out that the corrupted object was stored in an array.</p>
<p>As an example, here's a function that uses the GDB API to walk one of the
helper data structures of the GC, a stack of pointers:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">walk_addr_stack</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">""" walk an instance of the AddressStack class (which is a linked list of</span>
<span class="sd">    arrays of 1019 pointers).</span>

<span class="sd">    the first of the arrays is only partially filled with used_in_last_chunk</span>
<span class="sd">    items, all the other chunks are full."""</span>
    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">code</span> <span class="o">==</span> <span class="n">gdb</span><span class="o">.</span><span class="n">TYPE_CODE_PTR</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">dereference</span><span class="p">()</span>
    <span class="n">used_in_last_chunk</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">"used_in_last_chunk"</span><span class="p">)</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">"inst_chunk"</span><span class="p">)</span><span class="o">.</span><span class="n">dereference</span><span class="p">()</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="s2">"items"</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">used_in_last_chunk</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="s2">"next"</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">chunk</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">dereference</span><span class="p">()</span>
        <span class="n">used_in_last_chunk</span> <span class="o">=</span> <span class="mi">1019</span>
</pre></div>

<p>The full file of supporting code I wrote can be found in <a href="https://gist.github.com/cfbolz/13cadcbbef321d93fc9790dff6f60a6a">this
gist</a>. This is
pretty rough throw-away code, however.</p>
<p>In the following recording I show a staged debugging session with some of the
extra commands I wrote with the Python API. The details aren't important, I
just wanted to give a bit of a flavor of what inspecting objects looks like:</p>
<script src="https://asciinema.org/a/648889.js" id="asciicast-648889" async="true"></script><p>The next step was to understand why the array content wasn't being correctly
traced by the GC, which I eventually managed with some <a href="https://www.fayewilliams.com/2011/07/13/gdb-conditional-breakpoints/">conditional
breakpoints</a>,
more watchpoints, and using <code>reverse-continue</code>. It turned out to be a bug that
occurs when the content of one array was memcopied into another array. The
technical details of why the array wasn't traced correctly are described in
detail in the next section.</p>
<h3 id="writing-a-unit-test">Writing a unit test</h3>
<p>To try to make sure I really understood the bug correctly I then wrote a GC
unit test that shows the problem. Like most of PyPy, our GC is written in
RPython, a (somewhat strange) subset/dialect of Python2, which can be compiled
to C code. However, since it is also valid Python2 code, it can be <a href="../posts/2022/04/how-is-pypy-tested.html">unit-tested
on top of a Python2
implementation</a>
(which is one of the reasons why we keep maintaining PyPy2).</p>
<p>In the GC unit tests you have a lot of control about what order things happen
in, e.g. how objects are allocated, when garbage collection phases happen, etc.
After some trying I managed to write a test that crashes with the same kind of
memory corruption that my original crash exhibited: an object that is still
reachable via an array is collected by the GC. To give you a flavor of what
this kind of test looks like, here's an (edited for clarity) version of the
test I eventually managed to write</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_incrementality_bug_arraycopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">malloc</span><span class="p">(</span><span class="n">VAR</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1"># first array</span>
    <span class="c1"># the stackroots list emulates the C stack</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stackroots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">malloc</span><span class="p">(</span><span class="n">VAR</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1"># second array</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stackroots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">malloc</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="c1"># unrelated object, will be collected</span>
    <span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="c1"># store reference into source array, calling the write barrier</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">collect_step</span><span class="p">()</span>
    <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stackroots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># reload arrays, they might have moved</span>
    <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stackroots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># this GC step traces target</span>
    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">collect_step</span><span class="p">()</span>

    <span class="c1"># emulate what a memcopy of arrays does</span>
    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">writebarrier_before_copy</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">res</span>
    <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># copy two elements of the arrays</span>
    <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># now overwrite the reference to node in source</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lltype</span><span class="o">.</span><span class="n">nullptr</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
    <span class="c1"># this GC step traces source</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">collect_step</span><span class="p">()</span>
    <span class="c1"># some more collection steps, crucially target isn't traced again</span>
    <span class="c1"># but node is deleted</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">collect_step</span><span class="p">()</span>
    <span class="c1"># used to crash, node got collected</span>
    <span class="k">assert</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>

<p>One of the good properties of testing our GC that way is that all the memory is
emulated. The crash in the last line of the test isn't a segfault at all,
instead you get a nice exception saying that you tried to access a freed chunk
of memory and you can then debug this with a python2 debugger.</p>
<h3 id="fixing-the-bug">Fixing the Bug</h3>
<p>With the unit test in hand, fixing the test was relatively straightforward (the
diff in its simplest form is anyway only a <a href="https://github.com/pypy/pypy/commit/78bbeb93471b5f38438004e971f4b4f84ab17a84">single line
change</a>).
After this first version of my fix, I
<a href="https://github.com/pypy/pypy/issues/4925#issuecomment-2014459454">talked to Armin
Rigo</a> who
helped me find different case that was still wrong, in the same area of the
code.</p>
<p>I also got help by the developers at <a href="https://portaone.com/">PortaOne</a>
who are using PyPy on their servers and had seen some <a href="https://github.com/pypy/pypy/issues/4900">mysterious PyPy
crashes</a>
recently, that looked related to the GC. They did test deployments of my fixes
in their various stages to their servers to try to see whether stability
improved for them. Unfortunately in the end it turned out that their crashes
are an unrelated GC bug related to object pinning, which we haven't resolved
yet.</p>
<h3 id="writing-a-gc-fuzzerproperty-based-test">Writing a GC fuzzer/property based test</h3>
<p>Finding bugs in the GC is always extremely disconcerting, particularly since
this one managed to hide for so long (more than ten years!). Therefore I wanted
to use these bugs as motivation to try to find more problems in PyPy's GC. Given
the ridiculous effectiveness of fuzzing, I used
<a href="https://hypothesis.readthedocs.io/en/latest/">hypothesis</a> to write a
property-based test. Every test performs a sequence of randomly chosen steps
from the following list:</p>
<ul>
<li>allocate an object</li>
<li>read a random field from a random object</li>
<li>write a random reference into a random object</li>
<li>drop a random stack reference</li>
<li>perform one GC step</li>
<li>allocate an array</li>
<li>read a random index from a random array</li>
<li>write to an array</li>
<li>memcopy between two arrays</li>
</ul>
<p>This approach of doing a sequence of steps is pretty close to the <a href="https://hypothesis.readthedocs.io/en/latest/stateful.html">stateful
testing</a> approach of
hypothesis, but I just implemented it manually with the <a href="https://hypothesis.readthedocs.io/en/latest/data.html#drawing-interactively-in-tests">data
strategy</a>.</p>
<p>Every one of those steps is always performed on both the tested GC, and on some
regular Python objects. The Python objects provide the "ground truth" of what
the heap should look like, so we can compare the state of the GC objects
with the state of the Python objects to find out whether the GC made a mistake.</p>
<p>In order to check whether the test is actually useful, I reverted my bug fixes
and made sure that the test re-finds both the spurious GC assertion error and the
problems with memcopying an array.</p>
<p>In addition, the test also found corner cases in my fix. There was a situation
that I hadn't accounted for, which the test found after eventually.
I also plan on adding a bunch of other GC features as steps in the
test to stress them too (for example weakrefs, identity hashes, pinning, maybe
finalization).</p>
<p>At the point of publishing this post, the fixes got merged to the 2.7/3.9/3.10
branches of PyPy, and will be part of the next release (v7.3.16).</p>
<h2 id="the-technical-details-of-the-bug">The technical details of the bug</h2>
<p>In order to understand the technical details of the bug, I need to give some
background explanations about PyPy's GC.</p>
<h3 id="pypys-incremental-gc">PyPy's incremental GC</h3>
<p>PyPy uses an incremental generational mark-sweep GC. It's
<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC)">generational</a>
and therefore has minor collections (where only young objects get collected)
and major collections (collecting long-lived objects eventually, using a
<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na%C3%AFve_mark-and-sweep">mark-and-sweep</a>
algorithm). Young objects are allocated in a nursery using a
bump-pointer allocator, which makes allocation quite efficient. They are moved
out of the nursery by minor collections. In order to find references from old
to young objects the GC uses a write barrier to detect writes into old objects.</p>
<p>The GC is also
<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent">incremental</a>,
which means that its major collections aren't done all at once (which would
lead to long pauses). Instead, major collections are sliced up into small
steps, which are done directly after a minor collection (the GC isn't
<em>concurrent</em> though, which would mean that the GC does work in a separate
thread).</p>
<p>The incremental GC uses <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">tri-color
marking</a>
to reason about the reachable part of the heap during the marking phase, where
every old object can be:</p>
<ul>
<li>black: already marked, reachable, definitely survives the collection</li>
<li>grey: will survive, but still needs to be marked</li>
<li>white: potentially dead</li>
</ul>
<p>The color of every object is encoded by setting flags
in the object header.</p>
<p>The GC maintains the <strong>invariant</strong> that black objects must never point to white
objects. At the start of a major collection cycle the stack roots are turned
gray. During the mark phase of a major collection cycle, the GC will trace gray
objects, until
none are left. To trace a gray object, all the objects it references have to be
marked grey if they are white so far. After a grey object is traced, it can be
marked black (because all the referenced objects are now either black or gray).
Eventually, there are no gray objects left. At that point (because no white
object can be reached from a black one) all the white objects are known to be
unreachable and can therefore be freed.</p>
<p>The GC is incremental because every collection step will only trace a limited
number of gray objects, before giving control back to the program. This leads to
a problem: if an already traced (black) object is changed between two marking
steps of the GC, the program can mutate that object and write a new reference
into one of its fields. This could lead to an invariant violation, if the
referenced object is white. Therefore, the GC uses the write barrier (which it
needs anyway to find references from old to young objects) to mark all black
objects that are modified gray, and then trace them again at one of the
later collection steps.</p>
<h3 id="the-special-write-barrier-of-memcopy">The special write barrier of memcopy</h3>
<p>Arrays use a different kind of write barrier than normal objects. Since they
can be arbitrarily large, tracing them can take a long time. Therefore it's
potentially wasteful to trace them fully at a minor collection. To fix this,
the array write barrier keeps more granular information about which parts of
the array have been modified since the last collection step. Then only the
modified parts of the array need to be traced, not the whole array.</p>
<p>In addition, there is another optimization for arrays, which is that memcopy is
treated specially by the GC. If memcopy is implemented by simply writing a loop
that copies the content of one array to the other, that will invoke the write
barrier every single loop iteration for the write of every array element,
costing a lot of overhead. Here's some pseudo-code:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">arraycopy</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">source_start</span><span class="p">,</span> <span class="n">dest_start</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">source_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">dest</span><span class="p">[</span><span class="n">dest_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="c1"># &lt;- write barrier inserted here</span>
</pre></div>

<p>Therefore the GC has a special memcopy-specific
write barrier that will perform the GC logic once before the memcopy loop, and
then use a regular (typically SIMD-optimized) memcopy implementation from
<code>libc</code>. Roughly like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">arraycopy</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">source_start</span><span class="p">,</span> <span class="n">dest_start</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="n">gc_writebarrier_before_array_copy</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">source_start</span><span class="p">,</span> <span class="n">dest_start</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
    <span class="n">raw_memcopy</span><span class="p">(</span><span class="n">cast_to_voidp</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="n">source_start</span><span class="p">,</span>
                <span class="n">cast_to_voidp</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">+</span> <span class="n">dest_start</span><span class="p">,</span>
                <span class="n">sizeof</span><span class="p">(</span><span class="n">itemtype</span><span class="p">(</span><span class="n">source</span><span class="p">))</span> <span class="o">*</span> <span class="n">length</span><span class="p">)</span>
</pre></div>

<p>(this is really a rough sketch. The <a href="https://github.com/pypy/pypy/blob/789f964fff59c722b0872abcdc56d2b1373a9f3b/rpython/rlib/rgc.py#L365">real
code</a>
is much more complicated.)</p>
<h3 id="the-bug">The bug</h3>
<p>The bugs turned out to be precisely in this memcopy write barrier. When we
implemented the current GC, we adapted our previous GC, which was a
generational mark-sweep GC but <em>not</em> incremental. We started with most of the
previous GC's code, including the write barriers. The regular write barriers
were adapted to the new incremental assumptions, in particular the need for the
write barrier to also turn black objects back to gray when they are modified
during a marking phase. This was simply not done at all for the memcopy write
barrier, at least in two of the code paths. Fixing this problem fixes the unit
tests and stops the crashes.</p>
<h2 id="reflections">Reflections</h2>
<p>The way the bug was introduced is really typical. A piece of code (the memcopy
write barrier) was written under a set of assumptions. Then those assumptions
changed later. Not all the code pieces that relied on these assumptions to be
correct were updated. It's pretty hard to prevent this in all situations.</p>
<p>I still think we could have done more to prevent the bug occurring. Writing a
property-based test for the GC would have been a good idea given the complexity
of the GC, and definitely something we did in other parts of our code at the
time (just using the <code>random</code> module mostly, we started using hypothesis
later).</p>
<p>It's a bit of a mystery to me why this bug managed to be undetected for so
long. Memcopy happens in a lot of pretty core operations of e.g. lists in
Python (<code>list.extend</code>, to name just one example). To speculate, I would suspect
that all the other preconditions for the bug occurring made it pretty rare:</p>
<ul>
<li>the content of an old list that is not yet marked needs to be copied into
  another old list that is marked already</li>
<li>the source of the copy needs to also store an object that has no other
  references</li>
<li>the source of the copy then needs to be overwritten with other data</li>
<li>then the next collection steps need to be happening at the right points</li>
<li>...</li>
</ul>
<p>Given the complexity of the GC logic I also wonder whether some lightweight
formal methods would have been a good idea. Formalizing some of the core
invariants in <a href="https://en.wikipedia.org/wiki/B-Method">B</a> or
<a href="https://en.wikipedia.org/wiki/TLA%2B">TLA+</a> and then <a href="https://en.wikipedia.org/wiki/Model_checking">model
checking</a> them up to some number
of
objects would have found this problem pretty quickly. There are also correctness
proofs for GC algorithms in some research papers, but I don't have a good
overview of the literature to point to any that are particularly good or bad.
Going such a more formal route might have fixed this and probably a whole bunch
of other bugs, but of course it's a pretty expensive (and tedious) approach.</p>
<p>While it was super annoying to track this down, it was definitely good to learn
a bit more about how to use rr and the GDB scripting interface.</p>
<h2 id="bonus-section-the-wrong-assertion">Bonus Section: The Wrong Assertion</h2>
<p>Some more technical information about the wrong assertion is in this section.</p>
<h3 id="background-pre-built-objects">Background: pre-built objects</h3>
<p>PyPy's VM-building bootstrapping process can "freeze" a bunch of heap objects
into the final binary. This allows the VM to start up quickly, because those
frozen objects are loaded by the OS as part of the binary.</p>
<p>Those frozen pre-built objects are parts of the 'roots' of the garbage
collector and need to be traced. However, tracing all the pre-built objects at
every collection would be very expensive, because there are a lot of them
(about 150,000 in a PyPy 3.10 binary). Tracing them all is also not necessary,
because most of them are never modified. Unmodified pre-built objects can only reference
other pre-built objects, which can never be deallocated anyway. Therefore we
have an optimization that uses the write barrier (which we need anyway to find
old-to-young pointers) to notice when a pre-built object gets modified for the
very first time. If that happens, it gets added to the set of pre-built objects
that gets counted as a root, and is traced as a root at collections
from then on.</p>
<h3 id="the-wrong-assertion">The wrong assertion</h3>
<p>The assertion that triggered when I turned on the GC debug mode was saying that
the GC found a reference from a black to a white object, violating its
invariant. Unmodified pre-built objects count as black, and they aren't roots,
because they can only ever reference other pre-built objects. However, when a
pre-built object gets modified for the first time, it becomes part of the root
set and will be marked gray. This logic works fine.</p>
<p>The wrong assertion triggers if a pre-built object is mutated for the very
first time in the middle of an incremental marking phase. While the pre-built
object gets added to the root set just fine, and will get traced before the
marking phase ends, this is encoded slightly differently for pre-built objects,
compared to "regular" old objects. Therefore, the invariant checking code
wrongly reported a black-&gt;white pointer in this situation.</p>
<p>To fix it I also wrote a unit test checking the problem, made sure that the GC
hypothesis test also found the bug, and then fixed the wrong assertion to take
the color encoding of pre-built objects into account.</p>
<p>The bug managed to be invisible because we don't tend to turn on the GC
assertions very often. We only do that when we find a GC bug, which is of
course also when we need it the most to be correct.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to Matti Picus, Max Bernstein, Wouter van Heyst for giving me feedback on drafts of the
post. Thanks to Armin Rigo for reviewing the code and pointing out holes in my
thinking. Thanks to the original reporters of the various forms of the bug,
including Lily Foote, David Hewitt, Wenzel Jakob.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2024/01/pypy-v7315-release.html" class="u-url">PyPy v7.3.15 release</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/mattip.html">mattip</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2024/01/pypy-v7315-release.html" rel="bookmark">
            <time class="published dt-published" datetime="2024-01-15T12:22:08Z" itemprop="datePublished" title="2024-01-15 12:22">2024-01-15 12:22</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <section id="pypy-v7-3-15-release-of-python-2-7-3-9-and-3-10"><h2>PyPy v7.3.15: release of python 2.7, 3.9, and 3.10</h2>
<p>The PyPy team is proud to release version 7.3.15 of PyPy.</p>
<p>This is primarily a bug-fix release, and includes work done to migrate PyPy to
Git and Github.</p>
<p>The release includes three different interpreters:</p>
<blockquote>
<ul class="simple">
<li><p>PyPy2.7, which is an interpreter supporting the syntax and the features of
Python 2.7 including the stdlib for CPython 2.7.18+ (the <code class="docutils literal">+</code> is for
backported security updates)</p></li>
<li><p>PyPy3.9, which is an interpreter supporting the syntax and the features of
Python 3.9, including the stdlib for CPython 3.9.18.</p></li>
<li><p>PyPy3.10, which is an interpreter supporting the syntax and the features of
Python 3.10, including the stdlib for CPython 3.10.13.</p></li>
</ul>
</blockquote>
<p>The interpreters are based on much the same codebase, thus the multiple
release. This is a micro release, all APIs are compatible with the other 7.3
releases. It follows after 7.3.14 release on Dec 25, 2023</p>
<p>We recommend updating. You can find links to download the v7.3.15 releases here:</p>
<blockquote>
<p><a class="reference external" href="https://pypy.org/download.html">https://pypy.org/download.html</a></p>
</blockquote>
<p>We would like to thank our donors for the continued support of the PyPy
project. If PyPy is not quite good enough for your needs, we are available for
<a class="reference external" href="https://www.pypy.org/pypy-sponsors.html">direct consulting</a> work. If PyPy is helping you out, we would love to hear about
it and encourage submissions to our <a class="reference external" href="https://pypy.org/blog">blog</a> via a pull request
to <a class="reference external" href="https://github.com/pypy/pypy.org">https://github.com/pypy/pypy.org</a></p>
<p>We would also like to thank our contributors and encourage new people to join
the project. PyPy has many layers and we need help with all of them: bug fixes,
<a class="reference external" href="https://doc.pypy.org/">PyPy</a> and <a class="reference external" href="https://rpython.readthedocs.org">RPython</a> documentation improvements, or general <a class="reference external" href="https://doc.pypy.org/en/latest/project-ideas.html">help</a> with
making RPython's JIT even better.</p>
<p>If you are a python library maintainer and use C-extensions, please consider
making a <a class="reference external" href="https://hpyproject.org/">HPy</a> / <a class="reference external" href="https://cffi.readthedocs.io">CFFI</a> / <a class="reference external" href="https://cppyy.readthedocs.io">cppyy</a> version of your library that would be performant
on PyPy. In any case, both <a class="reference external" href="https://github.com/joerick/cibuildwheel">cibuildwheel</a> and the <a class="reference external" href="https://github.com/matthew-brett/multibuild">multibuild system</a> support
building wheels for PyPy.</p>
<section id="what-is-pypy"><h3>What is PyPy?</h3>
<p>PyPy is a Python interpreter, a drop-in replacement for CPython
It's fast (<a class="reference external" href="https://speed.pypy.org">PyPy and CPython 3.7.4</a> performance
comparison) due to its integrated tracing JIT compiler.</p>
<p>We also welcome developers of other <a class="reference external" href="https://rpython.readthedocs.io/en/latest/examples.html">dynamic languages</a> to see what RPython
can do for them.</p>
<p>We provide binary builds for:</p>
<blockquote>
<ul class="simple">
<li><p><strong>x86</strong> machines on most common operating systems
(Linux 32/64 bits, Mac OS 64 bits, Windows 64 bits)</p></li>
<li><p>64-bit <strong>ARM</strong> machines running Linux (<code class="docutils literal">aarch64</code>).</p></li>
<li><p>Apple <strong>M1 arm64</strong> machines (<code class="docutils literal">macos_arm64</code>).</p></li>
<li><p><strong>s390x</strong> running Linux</p></li>
</ul>
</blockquote>
<p>PyPy support Windows 32-bit, Linux PPC64 big- and little-endian, and Linux ARM
32 bit, but does not release binaries. Please reach out to us if you wish to
sponsor binary releases for those platforms. Downstream packagers provide
binary builds for debian, Fedora, conda, OpenBSD, FreeBSD, Gentoo, and more.</p>
</section><section id="what-else-is-new"><h3>What else is new?</h3>
<p>For more information about the 7.3.15 release, see the <a class="reference external" href="https://doc.pypy.org/en/latest/release-v7.3.15.html#changelog">full changelog</a>.</p>
<p>Please update, and continue to help us make pypy better.</p>
<p>Cheers,
The PyPy Team</p>
</section></section>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2023/12/pypy-moved-to-git-github.html" class="u-url">PyPy has moved to Git, GitHub</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/mattip.html">mattip</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2023/12/pypy-moved-to-git-github.html" rel="bookmark">
            <time class="published dt-published" datetime="2023-12-29T14:19:55Z" itemprop="datePublished" title="2023-12-29 14:19">2023-12-29 14:19</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>PyPy has moved its canonical repo and issue tracker from
<a href="https://foss.heptapod.net/pypy/pypy">https://foss.heptapod.net/pypy/pypy</a> to <a href="https://github.com/pypy/pypy">https://github.com/pypy/pypy</a>. Obviously,
this means development will now be tracked in Git rather than Mercurial.</p>
<h3 id="motivation">Motivation</h3>
<p>We still feel Mercurial is a better version control system. The named branch
model and user interface are superior. But</p>
<ul>
<li>
<p>foss.heptapod.net is not well indexed in google/bing/duckduckgo
  search, so people find it harder to search for issues in the project.</p>
</li>
<li>
<p>Since Heptapod has tightened its spam control, we get reports that
  users create issues only to have them flagged as spam.</p>
</li>
<li>
<p>Open Source has become synonymous with GitHub, and we are too small to
  change that.</p>
</li>
<li>
<p>Much of the current development comes as a reaction to fixing issues.
  Tracking interlocking issues is easier if all the code is on the same
  platform.</p>
</li>
<li>
<p>The <a href="https://doc.pypy.org/en/latest/faq.html#why-doesn-t-pypy-use-git-and-move-to-github">FAQ</a>
  presents two arguments against the move. <a href="https://git-scm.com/docs/git-notes">Github notes</a>
  solves much of point (1): the difficulty of discovering provenance of
  commits, although not entirely. But the main problem is point (2), it turns
  out that <strong>not</strong> moving to GitHub is an impediment to contribution and issue
  reporting.</p>
</li>
<li>
<p>People who wish to continue to use Mercurial can use the same method below to
  push to GitHub.</p>
</li>
<li>
<p>GitHub is more resource rich than foss.heptapod.net. We could add CI
  jobs to replace some of our aging <a href="https://buildbot.pypy.org">buildbot
  infrastructure</a>.</p>
</li>
</ul>
<h3 id="method">Method</h3>
<p>The migration required two parts: migrating the code and then migrating the
issues and merge requests.</p>
<h4 id="code-migration-1-code-and-notes">Code migration 1: code and notes</h4>
<p>I used a <a href="https://github.com/mnauw/git-remote-hg">fork of git-remote-hg</a> to
create a local Git repo with all the changesets. Then I wanted to add a Git
note to each commit with the branch it came from. So I prepared a file with two
columns: the Git commit hash, and the corresponding branch from Mercurial.
Mercurial can describe each commit in two ways: either the commit hash or by a
number index. I used <code>hg log</code> to convert an index <code>i</code> to the Mercurial hash,
and then <code>git-hg-helper</code> from <code>git-remote-hg</code> to convert the Mercurial hash to
a Git hash:</p>
<div class="code"><pre class="code literal-block">$(cd pypy-git; git-hg-helper git-rev $(cd ../pypy-hg; hg log -r $i -T"{node}\n"))
</pre></div>

<p>Then I used <code>hg log</code> again to print the Mercurial branch for the index <code>i</code>:</p>
<div class="code"><pre class="code literal-block">$(cd pypy-hg; hg log -r $i -T'{branch}\n')
</pre></div>

<p>Putting these two together, I could loop over all the commits by their
numerical index to prepare the file. Then I iterated over each line in the
file, and added the Git note. Since the <code>git note add</code> command works on the
current HEAD, I needed to checkout each commit in turn and then add the note:</p>
<div class="code"><pre class="code literal-block">git checkout -q &lt;hash&gt; &amp;&amp; git notes --ref refs/notes/branch add -m branch:&lt;branch&gt;
</pre></div>

<p>I could then use <code>git push --all</code> to push to GitHub.</p>
<h4 id="code-migration-2-prepare-the-branches">Code migration 2: prepare the branches</h4>
<p>PyPy has almost 500 open branches. The code migration created all the branch
HEADs, but <code>git push --all</code> did not push them. I needed to check them out and
push each one. So I created a file with all the branch names</p>
<div class="code"><pre class="code literal-block">cd pypy-hg; hg branches | cut -f1 -d" " &gt; branches.txt
</pre></div>

<p>and then push each one to the GitHub repo</p>
<div class="code"><pre class="code literal-block"><span class="k">while</span><span class="w"> </span><span class="nv">read</span><span class="w"> </span><span class="nv">branch</span><span class="c1">; do git checkout branches/$branch &amp;&amp; git push origin branches/$branch; done &lt; branches.txt</span>
</pre></div>

<p>Note that the branches were named <code>branches/XXX</code> by the migration, not <code>branch/XXX</code>. This confuses the merge request migration, more about that later.</p>
<h4 id="issue-and-merge-request-migration">Issue and merge request migration</h4>
<p>I used the solution from
<a href="https://github.com/piceaTech/node-gitlab-2-github">node-gitlab-2-github</a> which
worked almost perfectly. It is important to do the conversion on a <strong>private
repo</strong> otherwise every mention of a successfully mapped user name notifies
the user about the transfer. This can be quite annoying for a repo the size of
PyPy with 600 merge requests and over 4000 issues. Issues transferred without a
problem: the script properly retained the issue numbers. However the script
does not convert the Mercurial hashes to Git hashes, so the bare hashes in
comments show up without a link to the commit. Merge requests are more of a problem:</p>
<ul>
<li>The Mercurial named branch "disappears" once it is merged, so a merge request
  to a merged branch does not find the target branch name in Git. The
  conversion creates an issue instead with the label <code>gitlab merge request</code>.</li>
<li>For some reason, the branches created by <code>git-remote-hg</code> are called
  <code>branches/XXX</code> and not <code>branch/XXX</code> as expected by GitLab. This messes up the
  merge request/PR conversion. For some of the branches (open PRs and main
  target branches) I manually created additional branches without the <code>es</code>. The
  net result is that open merge requests became open PRs, merged merge requests
  became issues, and closed-not-merged merge requests were not migrated.</li>
</ul>
<h4 id="layered-conversions">Layered conversions</h4>
<p>PyPy already migrated once from Bitbucket to Heptapod. Many of the issues
reflect the multiple transitions: they have lines like "Created originally on
Bitbucket by XXX" from the first transition, and an additional line "In
Heptapod" from this transition.</p>
<h3 id="credits">Credits</h3>
<p>We would like to express our gratitude to the <a href="https://octobus.net/">Octobus</a>
team who support Heptapod. The transition from Bitbucket was quite an effort,
and they have generously hosted our development since then. We wish them all
the best, and still believe that Mercurial should have "won".</p>
<h3 id="next-steps">Next steps</h3>
<p>While the repo at GitHub is live, there are still a few more things we need to
do:</p>
<ul>
<li>Documentation needs an update for the new repo and the build automation from
  readthedocs must be adjusted.</li>
<li>The wiki should be copied from Heptapod.</li>
<li>buildbot.pypy.org should also look at the new repo. I hope the code is up to
  the task of interacting with a Git repo.</li>
<li>speed.pypy.org tracks changes, it too needs to reference the new location</li>
<li>To keep tracking branches with Git notes on new commits, I activated a
  <a href="https://github.com/Julian/named-branch-action">github action</a> by Julian to
  add a Git branch note to each commit. Please see the README there for
  directions on using Git notes.</li>
<li>Some of the merge requests were not migrated. If someone wants to, they could
  migrate those once they figure out the branch naming problems.</li>
</ul>
<p>Additionally, now is the time for all of you to prove the move is worthwhile:</p>
<ul>
<li>Star the repo, let others know how to find it,</li>
<li>Help fix some of the open issues or file new ones,</li>
<li>Take advantage of the more familiar workflow to get involved in the project,</li>
<li>Suggest ways to improve the migration: are there things I missed or could
  have done better?</li>
</ul>
<h3 id="how-will-development-change">How will development change?</h3>
<p>Heptapod did not allow personal forks, so we were generous with a commit bit to
the main repo. Additionally, we (well, me) have been using a
commit-directly-to-main workflow. We will now be adopting a more structured
workflow. Please fork the repo and submit a pull request for any changes. We
can now add some pre-merge CI to check that the PR at least passes the first
stage of translation. The live and active branches will be:</p>
<ul>
<li>
<code>main</code>: what was "default" in Mercurial, it is the Python2.7 interpreter and
  the base of the RPython interpreter,</li>
<li>
<code>py3.9</code>: the Python3.9 interpreter, which also includes all RPython changes
  from <code>main</code>. This is exactly like on Mercurial, and</li>
<li>
<code>py3.10</code>: the Python3.10 interpreter, which also includes all RPython changes
  from <code>main</code> and all bugfixes from <code>py3.9</code>. This is exactly like on Mercurial.</li>
</ul>
<h4 id="working-between-the-repos">Working between the repos</h4>
<h5 id="finding-commits">Finding commits</h5>
<p>If you want to figure out how a Mercurial commit relates to a Git commit, you
can use <code>git-hg-helper</code>. You run it in the Git repo. It takes the full long
hash from one repo and gives you the corresponding hash of the other repo:</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git-hg-helper<span class="w"> </span>git-rev<span class="w"> </span>d64027c4c2b903403ceeef2c301f5132454491df
4527e62ad94b0e940a5b0f9f20d29428672f93f7
$<span class="w"> </span>git-hg-helper<span class="w"> </span>hg-rev<span class="w"> </span>4527e62ad94b0e940a5b0f9f20d29428672f93f7
d64027c4c2b903403ceeef2c301f5132454491df
</pre></div>

<h5 id="finding-branches">Finding branches</h5>
<p>Branches migrated from Mercurial will have a <code>branches</code> prefix, not <code>branch</code>.
While GitLab uses <code>branch</code> for its prefix, the <code>git-remote-hg</code> script uses
<code>branches</code>. New work should be in a PR targeting <code>main</code>, <code>py3.9</code> or <code>py3.10</code>.</p>
<p>Thanks for helping to make PyPy better.</p>
<p>Matti</p>
<h2 id="update">Update</h2>
<p>In the meantime we found out that unfortunately something went wrong in the
migration of the issues. The old <a href="https://foss.heptapod.net/pypy/pypy/-/issues/3655">issue
3655</a> got lost in the
migration. This means that after number 3655 the numbers are different between
github and heptapod, with heptapod being one larger. E.g. <a href="https://foss.heptapod.net/pypy/pypy/-/issues/3700">issue 3700 on
heptapod</a> is <a href="https://github.com/pypy/pypy/issues/3699">issue 3699 on
github</a>. We are <a href="https://github.com/pypy/pypy/issues/4979">investigating
options</a>. </p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2023/12/pypy-v7314-release.html" class="u-url">PyPy v7.3.14 release</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/mattip.html">mattip</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2023/12/pypy-v7314-release.html" rel="bookmark">
            <time class="published dt-published" datetime="2023-12-25T04:22:08Z" itemprop="datePublished" title="2023-12-25 04:22">2023-12-25 04:22</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <section id="pypy-v7-3-14-release-of-python-2-7-3-9-and-3-10"><h2>PyPy v7.3.14: release of python 2.7, 3.9, and 3.10</h2>
<p>The PyPy team is proud to release version 7.3.14 of PyPy.</p>
<p>Highlights of this release are compatibility with <a class="reference external" href="https://hpyproject.org/blog/posts/2023/10/hpy-0.9.0-fourth-public-release/">HPy-0.9</a>, cffi 1.16,
additional C-API interfaces, and more python3.10 fixes.</p>
<p>The release includes three different interpreters:</p>
<blockquote>
<ul class="simple">
<li><p>PyPy2.7, which is an interpreter supporting the syntax and the features of
Python 2.7 including the stdlib for CPython 2.7.18+ (the <code class="docutils literal">+</code> is for
backported security updates)</p></li>
<li><p>PyPy3.9, which is an interpreter supporting the syntax and the features of
Python 3.9, including the stdlib for CPython 3.9.18.</p></li>
<li><p>PyPy3.10, which is an interpreter supporting the syntax and the features of
Python 3.10, including the stdlib for CPython 3.10.13.</p></li>
</ul>
</blockquote>
<p>The interpreters are based on much the same codebase, thus the multiple
release. This is a micro release, all APIs are compatible with the other 7.3
releases. It follows after 7.3.13 release on Sept 29, 2023.</p>
<p>We recommend updating. You can find links to download the v7.3.14 releases here:</p>
<blockquote>
<p><a class="reference external" href="https://pypy.org/download.html">https://pypy.org/download.html</a></p>
</blockquote>
<p>We would like to thank our donors for the continued support of the PyPy
project. If PyPy is not quite good enough for your needs, we are available for
<a class="reference external" href="https://www.pypy.org/pypy-sponsors.html">direct consulting</a> work. If PyPy is helping you out, we would love to hear about
it and encourage submissions to our <a class="reference external" href="https://pypy.org/blog">blog</a> via a pull request
to <a class="reference external" href="https://github.com/pypy/pypy.org">https://github.com/pypy/pypy.org</a></p>
<p>We would also like to thank our contributors and encourage new people to join
the project. Since the last release we have contributions from three new
contributors.  PyPy has many layers and we need help with all of them: bug
fixes, <a class="reference external" href="https://doc.pypy.org/">PyPy</a> and <a class="reference external" href="https://rpython.readthedocs.org">RPython</a> documentation improvements, or general <a class="reference external" href="https://doc.pypy.org/en/latest/project-ideas.html">help</a>
with making RPython's JIT even better.</p>
<p>If you are a python library maintainer and use C-extensions, please consider
making a <a class="reference external" href="https://hpyproject.org/">HPy</a> / <a class="reference external" href="https://cffi.readthedocs.io">CFFI</a> / <a class="reference external" href="https://cppyy.readthedocs.io">cppyy</a> version of your library that would be performant
on PyPy. In any case, both <a class="reference external" href="https://github.com/joerick/cibuildwheel">cibuildwheel</a> and the <a class="reference external" href="https://github.com/matthew-brett/multibuild">multibuild system</a> support
building wheels for PyPy.</p>
<section id="what-is-pypy"><h3>What is PyPy?</h3>
<p>PyPy is a Python interpreter, a drop-in replacement for CPython
It's fast (<a class="reference external" href="https://speed.pypy.org">PyPy and CPython 3.7.4</a> performance
comparison) due to its integrated tracing JIT compiler.</p>
<p>We also welcome developers of other <a class="reference external" href="https://rpython.readthedocs.io/en/latest/examples.html">dynamic languages</a> to see what RPython
can do for them.</p>
<p>We provide binary builds for:</p>
<blockquote>
<ul class="simple">
<li><p><strong>x86</strong> machines on most common operating systems
(Linux 32/64 bits, Mac OS 64 bits, Windows 64 bits)</p></li>
<li><p>64-bit <strong>ARM</strong> machines running Linux (<code class="docutils literal">aarch64</code>).</p></li>
<li><p>Apple <strong>M1 arm64</strong> machines (<code class="docutils literal">macos_arm64</code>).</p></li>
<li><p><strong>s390x</strong> running Linux</p></li>
</ul>
</blockquote>
<p>PyPy support Windows 32-bit, Linux PPC64 big- and little-endian, and Linux ARM
32 bit, but does not release binaries. Please reach out to us if you wish to
sponsor binary releases for those platforms. Downstream packagers provide
binary builds for debian, Fedora, conda, OpenBSD, FreeBSD, Gentoo, and more.</p>
</section><section id="what-else-is-new"><h3>What else is new?</h3>
<p>For more information about the 7.3.14 release, see the <a class="reference external" href="https://doc.pypy.org/en/latest/release-v7.3.14.html#changelog">full changelog</a>.</p>
<p>Please update, and continue to help us make pypy better.</p>
<p>Cheers,
The PyPy Team</p>
</section></section>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2023/09/pypy-v7313-release.html" class="u-url">PyPy v7.3.13 release</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/mattip.html">mattip</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2023/09/pypy-v7313-release.html" rel="bookmark">
            <time class="published dt-published" datetime="2023-09-29T04:22:08Z" itemprop="datePublished" title="2023-09-29 04:22">2023-09-29 04:22</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <section id="pypy-v7-3-13-release-of-python-2-7-3-9-and-3-10"><h2>PyPy v7.3.13: release of python 2.7, 3.9, and 3.10</h2>
<p>The PyPy team is proud to release version 7.3.13 of PyPy.
This is primarily a security/bug-fix release. CPython released security
patches, and this release also improves the ability to use type
specifications via <code class="docutils literal">PyType_FromSpec</code> and friends. There are also some
small speed-ups.</p>
<p>The release includes three different interpreters:</p>
<blockquote>
<ul class="simple">
<li><p>PyPy2.7, which is an interpreter supporting the syntax and the features of
Python 2.7 including the stdlib for CPython 2.7.18+ (the <code class="docutils literal">+</code> is for
backported security updates)</p></li>
<li><p>PyPy3.9, which is an interpreter supporting the syntax and the features of
Python 3.9, including the stdlib for CPython 3.9.18.</p></li>
<li><p>PyPy3.10, which is an interpreter supporting the syntax and the features of
Python 3.10, including the stdlib for CPython 3.10.13. Note it requires at
least cython 0.29.35 or cython 3.0.0b3.</p></li>
</ul>
</blockquote>
<p>The interpreters are based on much the same codebase, thus the multiple
release. This is a micro release, all APIs are compatible with the other 7.3
releases. It follows after 7.3.12 release on June 16, 2023.</p>
<p>We recommend updating. You can find links to download the v7.3.13 releases here:</p>
<blockquote>
<p><a class="reference external" href="https://pypy.org/download.html">https://pypy.org/download.html</a></p>
</blockquote>
<p>We would like to thank our donors for the continued support of the PyPy
project. If PyPy is not quite good enough for your needs, we are available for
<a class="reference external" href="https://www.pypy.org/pypy-sponsors.html">direct consulting</a> work. If PyPy is helping you out, we would love to hear about
it and encourage submissions to our <a class="reference external" href="https://pypy.org/blog">blog</a> via a pull request
to <a class="reference external" href="https://github.com/pypy/pypy.org">https://github.com/pypy/pypy.org</a></p>
<p>We would also like to thank our contributors and encourage new people to join
the project. PyPy has many layers and we need help with all of them: bug fixes,
<a class="reference external" href="https://doc.pypy.org/">PyPy</a> and <a class="reference external" href="https://rpython.readthedocs.org">RPython</a> documentation improvements, or general <a class="reference external" href="https://doc.pypy.org/en/latest/project-ideas.html">help</a> with making
RPython's JIT even better.</p>
<p>If you are a python library maintainer and use C-extensions, please consider
making a <a class="reference external" href="https://hpyproject.org/">HPy</a> / <a class="reference external" href="https://cffi.readthedocs.io">CFFI</a> / <a class="reference external" href="https://cppyy.readthedocs.io">cppyy</a> version of your library that would be performant
on PyPy. In any case, both <a class="reference external" href="https://github.com/joerick/cibuildwheel">cibuildwheel</a> and the <a class="reference external" href="https://github.com/matthew-brett/multibuild">multibuild system</a> support
building wheels for PyPy.</p>
<section id="what-is-pypy"><h3>What is PyPy?</h3>
<p>PyPy is a Python interpreter, a drop-in replacement for CPython
It's fast (<a class="reference external" href="https://speed.pypy.org">PyPy and CPython 3.7.4</a> performance
comparison) due to its integrated tracing JIT compiler.</p>
<p>We also welcome developers of other <a class="reference external" href="https://rpython.readthedocs.io/en/latest/examples.html">dynamic languages</a> to see what RPython
can do for them.</p>
<p>We provide binary builds for:</p>
<blockquote>
<ul class="simple">
<li><p><strong>x86</strong> machines on most common operating systems
(Linux 32/64 bits, Mac OS 64 bits, Windows 64 bits)</p></li>
<li><p>64-bit <strong>ARM</strong> machines running Linux (<code class="docutils literal">aarch64</code>).</p></li>
<li><p>Apple <strong>M1 arm64</strong> machines (<code class="docutils literal">macos_arm64</code>).</p></li>
<li><p><strong>s390x</strong> running Linux</p></li>
</ul>
</blockquote>
<p>PyPy support Windows 32-bit, Linux PPC64 big- and little-endian, and Linux ARM
32 bit, but does not release binaries. Please reach out to us if you wish to
sponsor binary releases for those platforms. Downstream packagers provide
binary builds for debian, Fedora, conda, OpenBSD, FreeBSD, Gentoo, and more.</p>
</section><section id="what-else-is-new"><h3>What else is new?</h3>
<p>For more information about the 7.3.13 release, see the <a class="reference external" href="https://doc.pypy.org/en/latest/release-v7.3.13.html#changelog">full changelog</a>.</p>
<p>Please update, and continue to help us make pypy better.</p>
<p>Cheers,
The PyPy Team</p>
</section></section>
</div>
    </article>
</div>
</div>
<div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/12/toy-load-store.html" class="listtitle">Load and store forwarding in the Toy Optimizer</a>
      </li>
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (9)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (6)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div></div>
</main>
</div>
<div style="clear: both; width: 75%; margin: 1em auto;">
        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-45.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-43.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
         
                 <footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    © 2026 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
     
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
     
    Last built 2026-01-17T00:22
  </div>
  <div style="margin-left: auto">
  <a href="../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../assets/js/styles.js"></script></footer>
</body>
</html>