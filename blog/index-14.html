<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="A Faster Python">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>PyPy (old posts, page 14) | PyPy</title>
<link href="../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../rss.xml">
<link rel="canonical" href="https://www.pypy.org/blog/index-14.html">
<link rel="icon" href="../favicon2.ico" sizes="16x16">
<link rel="icon" href="../favicon32x32.ico" sizes="32x32">
<link rel="prev" href="index-15.html" type="text/html">
<link rel="next" href="index-13.html" type="text/html">
<!--[if lt IE 9]><script src="../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../assets/css/tipuesearch.css">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../index.html">
                    <image id="toplogo" src="../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../compat.html">Compatibility</a> </li>  
                    <li> <a href="../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href=".">Index</a> </li>  
                    <li> <a href="../categories/">Tags</a> </li>  
                    <li> <a href="../archive.html">Archive by year</a> </li>  
                    <li> <a href="../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Searchâ€¦" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><div class="post">
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/07/play-on-regular-expression-9014941705636345998.html" class="u-url">A Play on Regular Expression</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/07/play-on-regular-expression-9014941705636345998.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-07-27T10:18:00Z" itemprop="datePublished" title="2010-07-27 10:18">2010-07-27 10:18</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>The paper where the algorithms we described in the recent <a href="../posts/2010/05/efficient-and-elegant-regular-2727904462179540436.html">blog</a> <a href="../posts/2010/06/jit-for-regular-expression-matching-3877859053629057968.html">posts</a> come from is <a href="https://sebfisch.github.com/haskell-regexp/regexp-play.pdf">now available</a>. It  is written as a play in three Acts with a cast of three and is very readable and funny. The Haskell code is at <a href="https://sebfisch.github.com/haskell-regexp/">Sebastian Fischer's github pages</a>.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/07/europython-2010-report-7803731360759120212.html" class="u-url">EuroPython 2010 report</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/antonio-cuni.html">Antonio Cuni</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/07/europython-2010-report-7803731360759120212.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-07-26T11:06:00Z" itemprop="datePublished" title="2010-07-26 11:06">2010-07-26 11:06</time></a>
            </p>
                <p class="commentline">2 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>So, EuroPython 2010 is over, I am flying home and it's time to write a report
about the conference from the PyPy point of view.</p>
<p>As usual, the conference was very interesting and went very well. The quality
of the talks I attended to was high on average and most importantly I could
meet a lot of interesting people to discuss various things.</p>
<p>On the first day, Armin, Amaury and I presented the usual <a class="reference external" href="https://www.europython.eu/talks/talk_abstracts/index.html#talk124">PyPy status talk</a>
(here are the <a class="reference external" href="https://codespeak.net/svn/pypy/extradoc/talk/ep2010/talk/talk.pdf">slides</a>):
the talk is an extended version of <a class="reference external" href="https://www.pycon.it/conference/talks/pypy-12-snakes-never-crawled-so-fast">the one</a> that I and Armin presented at
<a class="reference external" href="https://www.pycon.it">Pycon Italia</a> in May and is divided in three parts: first I talked about the
current status of the project, what is the content of the recent 1.2 and 1.3
releases and showed a <a class="reference external" href="https://codespeak.net/svn/pypy/extradoc/talk/ep2010/pypy_demo/">demo</a> of a simple Django application that renders a
Mandelbrot fractal and is measurably faster on PyPy than on CPython.  In the
second part of the talk, Armin gave an introduction about the ideas that stand
behind the JIT.  Finally, in the third part Amaury explained how the new
<a class="reference external" href="../posts/2010/04/using-cpython-extension-modules-with-5864754772659599217.html">cpyext</a> module lets PyPy to compile and load existing CPython extensions
written in C.</p>
<p>I think that the talk was well received: the only drawback is that there was
no time to answer questions at the end of the presentation.  However, we
received a lot of "offline" questions after the talk finished and thorough the
whole conference: it is always great to see that people are interested in our
work, and I'd like to thank everybody for the feedback that they gave to us.</p>
<p>PyPy was also mentioned in the interesting <a class="reference external" href="https://www.europython.eu/talks/talk_abstracts/index.html#talk40">Mark Shannon's talk</a>, where he
compared the optimization techniques used by PyPy, <a class="reference external" href="https://code.google.com/p/unladen-swallow/">Unladen Swallow</a> and
<a class="reference external" href="https://code.google.com/p/hotpy/">HotPy</a>, which is Mark's own PhD project.  Moreover, Henrik Vendelbo
gave a <a class="reference external" href="https://www.europython.eu/talks/talk_abstracts/index.html#talk117">talk about how to tweak PyPy</a> to produce a standalone
executable which embeds a whole python application to make deployment easier,
while Andrew Francis explained his implementation of the Go <a class="reference external" href="https://www.europython.eu/talks/talk_abstracts/index.html#talk117">select
statement</a> based on the <tt class="docutils literal">stackless.py</tt> module implemented in PyPy.  Personally,
I am glad to see that people start to think of PyPy as a useful starting
point to experiment with new features and use cases that we did not think
about: after all, one of PyPy explicit goals is to be <a class="reference external" href="https://codespeak.net/pypy/dist/pypy/doc/getting-started.html#id3">"flexible and easy to
experiment with"</a>.</p>
<p>After the conference there were the usual <a class="reference external" href="https://wiki.europython.eu/Sprints">post EuroPython sprints</a>: this
year we had not planned a PyPy sprint, but some people showed interest
in it and since Armin and I happened to be still around the day after the
conference, we decided to do a mini 1-day sprint, with 6 or 7 people
present. Since there were only two core developers it was impossible to use
our usual pairing scheme, in which every newcomer pairs with someone who is
experienced with the source code to gain knowledge of it.  However, I think it
was still a successful day of work, and we managed to fix a couple of bugs
that was standing in our issue tracker.  Again, I'd like to thank all the
people that came and worked with us during the sprint.</p>
<p>In conclusion I really enjoyed the EuroPython 2010 experience: the fact that I
managed to find a place in Birmingham where to eat a good Italian-style "gelato"
helped a lot :-).</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-3130188955954708352">
        <div class="comment-header">
          <a name="comment-3130188955954708352"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-07-26 12:22</span>:
        </div>
        <div class="comment-content">
          <p>Just awesome.</p>
        </div>
      </div>
      <div class="comment comment-1659028314515153967">
        <div class="comment-header">
          <a name="comment-1659028314515153967"></a>
            <span class="author">Paul Boddie</span> wrote on <span class="date">2010-08-09 23:03</span>:
        </div>
        <div class="comment-content">
          <p>Finding gelato hopefully won't be a problem at next year's EuroPython. ;-)</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/07/cern-sprint-report-wrapping-c-libraries-6547377950791793143.html" class="u-url">CERN Sprint Report â€“ Wrapping C++ Libraries</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/07/cern-sprint-report-wrapping-c-libraries-6547377950791793143.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-07-09T22:40:00Z" itemprop="datePublished" title="2010-07-09 22:40">2010-07-09 22:40</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>The last five days we have been sprinting in a meeting room in the Computing
Center at <a class="reference external" href="https://cern.ch">CERN</a> in GenÃ¨ve, Switzerland. Present are Armin Rigo, Antonio Cuni,
Carl Friedrich Bolz and Wim Lavrijsen (<a class="reference external" href="https://www.lbl.gov">LBL</a>). The goal of the sprint was to use
some of the C++ technology developed at CERN to make it possible to use C++
libraries from PyPy's Python interpreter. For this we used the <a class="reference external" href="https://root.cern.ch/drupal/content/reflex">Reflex</a>
library, which provides reflection information for C++ classes. We discussed
using <a class="reference external" href="../posts/2008/10/sprint-discussions-c-library-bindings-249141169883996521.html">Reflex in PyPy</a> during the <a class="reference external" href="../posts/2008/10/dsseldorf-sprint-report-days-1-3-5256639868851086032.html">DÃ¼sseldorf sprint</a> of 2008, please read
that blog post if you want some more details on how Reflex works. There is
support for this sort of C++/Python integration also for CPython, using the
<a class="reference external" href="https://root.cern.ch/drupal/content/how-use-use-python-pyroot-interpreter">PyROOT</a> module.</p>
<p>The sprint was very successful. On Monday we had a few discussion about how
Reflex could best be integrated with PyPy. One of the goals of the sprint was to
make the approach JIT-friendly from the start, so that calls to C++ libraries
can be reasonably fast. After the discussion we started coding on the
<a class="reference external" href="https://codespeak.net/viewvc/pypy/branch/reflex-support">reflex-support</a> branch. This branch adds a new <tt class="docutils literal">cppyy</tt> builtin module to
PyPy's Python interpreter (why we chose that name is left as an exercise to the
reader). This module can be used to load C++ classes, construct instances and
call static and instance methods on them.</p>
<p>The work has just started, as of now, the argument and return types of the
methods are restricted to some simple C types, such as <tt class="docutils literal">int</tt>, <tt class="docutils literal">double</tt> and
<tt class="docutils literal">char*</tt> and pointers to class instances. Most of the work necessary to
properly resolve overloaded methods is done, but default arguments are not.</p>
<p>As an example, suppose there is a C++ class like this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">example01</span> {
<span style="color: #006699; font-weight: bold;">private</span><span style="color: #555555;">:</span>
    <span style="color: #006699; font-weight: bold;">static</span> <span style="color: #007788; font-weight: bold;">int</span> count;
    <span style="color: #007788; font-weight: bold;">int</span> somedata;
<span style="color: #006699; font-weight: bold;">public</span><span style="color: #555555;">:</span>

    example01(<span style="color: #007788; font-weight: bold;">int</span> a) <span style="color: #555555;">:</span> somedata(a) {
        count<span style="color: #555555;">++</span>;
    }
    <span style="color: #555555;">~</span>example01() {
        count<span style="color: #555555;">--</span>;
    }
    <span style="color: #006699; font-weight: bold;">static</span> <span style="color: #007788; font-weight: bold;">int</span> getCount() {
        <span style="color: #006699; font-weight: bold;">return</span> count;
    }

    <span style="color: #007788; font-weight: bold;">int</span> addDataToInt(<span style="color: #007788; font-weight: bold;">int</span> a) {
        <span style="color: #006699; font-weight: bold;">return</span> somedata <span style="color: #555555;">+</span> a;
    }
};
<span style="color: #007788; font-weight: bold;">int</span> example01<span style="color: #555555;">::</span>count <span style="color: #555555;">=</span> <span style="color: #FF6600;">0</span>;
</pre></div>
<p>You can now use it from PyPy's Python interpreter in the following way, after
you have used Reflex to generate reflection information for the class:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">import</span> <span style="color: #00CCFF; font-weight: bold;">cppyy</span>
cppyy<span style="color: #555555;">.</span>load_lib(<span style="color: #CC3300;">"example01Dict.so"</span>) <span style="color: #0099FF; font-style: italic;"># contains the Reflex information</span>
example01_class <span style="color: #555555;">=</span> cppyy<span style="color: #555555;">.</span>gbl<span style="color: #555555;">.</span>example01
instance <span style="color: #555555;">=</span> example01_class(<span style="color: #FF6600;">7</span>)
<span style="color: #006699; font-weight: bold;">assert</span> example01_class<span style="color: #555555;">.</span>getCount() <span style="color: #555555;">==</span> <span style="color: #FF6600;">1</span>
res <span style="color: #555555;">=</span> instance<span style="color: #555555;">.</span>addDataToInt(<span style="color: #FF6600;">4</span>)
<span style="color: #006699; font-weight: bold;">assert</span> res <span style="color: #555555;">==</span> <span style="color: #FF6600;">11</span>
res <span style="color: #555555;">=</span> instance<span style="color: #555555;">.</span>addDataToInt(<span style="color: #555555;">-</span><span style="color: #FF6600;">4</span>)
<span style="color: #006699; font-weight: bold;">assert</span> res <span style="color: #555555;">==</span> <span style="color: #FF6600;">3</span>
instance<span style="color: #555555;">.</span>destruct() <span style="color: #0099FF; font-style: italic;"># so far explicit destruction needed</span>
<span style="color: #006699; font-weight: bold;">assert</span> example01_class<span style="color: #555555;">.</span>getCount() <span style="color: #555555;">==</span> <span style="color: #FF6600;">0</span>
</pre></div>
<p>We also did some very early JIT work and some early performance measurements.
The rough figures are that <tt class="docutils literal">cppyy</tt> is two times faster at calling a simple C++
method from Python than <tt class="docutils literal">PyROOT</tt>. To get a feeling for how fast things could
go in the end, we also implemented a proof-of-concept for some more advanced JIT
technology (which requires a patch for Reflex and uses a GCC extension). With
this, the speedup over <tt class="docutils literal">PyROOT</tt> is a factor of 20. Of course, this is still a
lot slower than a C++ to C++ method call (probably by at least an order of
magnitude).</p>
<p>The sprint was very productive because we managed to get the right people into
the same room working together. Wim has a lot of experience with C++ and Reflex,
and is the author of <tt class="docutils literal">PyROOT</tt>, and of course the others know a lot about PyPy
(at the end of the sprint, Anto was very glad that he stopped using C++ a long
time ago). Also, working at CERN was very cool. The atmosphere is amazing, and
we got to visit the <a class="reference external" href="https://atlas.ch/news/2006/control-room.html">ATLAS control room</a>. Extremely advanced technology, and
also research on a completely different scale than what we are used to.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/07/comparing-spur-to-pypy-8835011873209414462.html" class="u-url">Comparing SPUR to PyPy</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/07/comparing-spur-to-pypy-8835011873209414462.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-07-03T14:48:00Z" itemprop="datePublished" title="2010-07-03 14:48">2010-07-03 14:48</time></a>
            </p>
                <p class="commentline">2 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Recently, I've become aware of the <a class="reference external" href="https://research.microsoft.com/en-us/projects/spur/">SPUR project</a> of Microsoft Research and
read some of their papers (the tech report "SPUR: A Trace-Based JIT Compiler
for CIL" is very cool). I found the project to be very interesting and since
their approach is in many ways related to what PyPy is doing, I now want to
compare and contrast the two projects.</p>
<div class="section" id="a-tracing-jit-for-net">
<h2>A Tracing JIT for .NET</h2>
<p>SPUR consist of two parts: On the one hand it is a VM for CIL, the
bytecode of the .NET VM. This VM uses a tracing JIT compiler to compile the
programs it is running to machine code. As opposed to most existing VMs that
have a tracing JIT it does not use an interpreter at all. Instead it
contains various variants of a JIT compiler that produce different versions of
each method. Those are:</p>
<ul class="simple">
<li>a <em>profiling JIT</em> which produces code that does lightweight profiling when
running the compiled method</li>
<li>a <em>tracing JIT</em> which produces code that produces a trace when running the
compiled method</li>
<li>a <em>transfer-tail JIT</em> which is used to produce code which is run to get from a
failing guard back to the normal profiling version of a method</li>
<li>an <em>optimizing JIT</em> that actually optimizes traces and turns them into machine code</li>
</ul>
<div class="section" id="optimizations-done-by-the-optimizing-jit">
<h3>Optimizations Done by the Optimizing JIT</h3>
<p>SPUR's optimizing JIT does a number of powerful optimizations on the traces before it
turns them into machine code. Among them are usual compiler optimizations such
as register allocation, common subexpression elimination, loop invariant code
motion, etc.</p>
<p>It also performs some optimizations that are specific to the tracing context and
are thus not commonly found in "normal" compilers:</p>
<ul class="simple">
<li>
<em>guard implication</em>: if a guard is implied by an earlier guard, it is removed</li>
<li>
<em>guard strengthening</em>: if there is a sequence of guards that become stronger
and stronger (i.e. each guard implies the previous one), the first guard in
the sequence is replaced by the last one, and all others are removed. This can
greatly reduce the number of guards and is generally safe. It can shift a
guard failure to an earlier point in the trace, but the failure would have
occurred at some point in the trace anyway.</li>
<li>
<em>load/store optimizations</em>: this is an optimization for memory reads/writes.
If several loads from the same memory location occur without writes in
between, all but the first one are removed. Similarly, if a write to a memory
location is performed, this write is delayed as much as possible. If there is
a write to the same location soon afterwards, the first write can be removed.</li>
<li>
<em>escape analysis</em>: for allocations that occur in a loop, the optimizer checks
whether the resulting object escapes the loop. If not, the allocation is moved
before the loop, so that only one object needs to be allocated, instead of one
every loop iteration.</li>
<li>
<em>user-controlled loop unrolling</em>: not exactly an optimization, but an
interesting feature anyway. It is possible to annotate a CIL method with a
special decorator <tt class="docutils literal">[TraceUnfold]</tt> and then the tracing JIT will fully unroll
the loops it contains. This can be useful for loops than are known to run a
small and fixed number of iterations for each call-site.</li>
<li>
<em>user controlled tracing</em>: The user can also control tracing up to a point.
Methods can be annotated with <tt class="docutils literal">[NativeCall]</tt> to tell the tracer to never
trace their execution. Instead they appear as a direct call in the trace.</li>
</ul>
</div>
</div>
<div class="section" id="a-javascript-implementation">
<h2>A JavaScript Implementation</h2>
<p>In addition to the tracing JIT I just described, SPUR also contains a JavaScript
implementation for .NET. The approach of this implementation is to translate
JavaScript to CIL bytecode, doing some amount of type inference to detect
variables that have fixed types. All operations where no precise type could be
determined are implemented with calls to a JavaScript runtime system, which does
the necessary type dispatching. The JavaScript runtime is implemented in C#.</p>
<p>The JavaScript implementation and the CLI VM with a tracing JIT sound quite
unrelated at first, but together they amplify each other. The tracing JIT traces
the JavaScript functions that have been translated to CLI bytecode. Since the
JavaScript runtime is in C#, it exists as CLI bytecode too. Thus it can be
inlined into the JavaScript functions by the tracer. This is highly beneficial,
since it exposes the runtime type dispatching of the JavaScript operations to
the optimizations of the tracing JIT. Particularly the common expression
elimination helps the JavaScript code. If a series of operations is performed on
the same object, the operations will all do the same type checks. All but the
type checks of the first operation can be removed by the optimizer.</p>
<div class="section" id="performance-results">
<h3>Performance Results</h3>
<p>The speed results of the combined JavaScript implementation and tracing JIT are
quite impressive. It beats TraceMonkey for most benchmarks in SunSpider (apart
from some string-heavy benchmarks that are quite slow) and can compete with V8
in many of them. However, all this is steady-state performance and it seems
SPUR's compile time is rather bad currently.</p>
</div>
<div class="section" id="further-possibilities">
<h3>Further Possibilities</h3>
<p>A further (so far still hypothetical) advantage of SPUR is that the approach can
optimize cases where execution crosses the border of two different systems. If
somebody wrote an HTML layout engine and a DOM in C# to get a web browser and
integrated it with the JavaScript implementation described above, the tracing
JIT could optimize DOM manipulations performed by JavaScript code as well as
callbacks from the browser into JavaScript code.</p>
<p>Of course the approach SPUR takes to implement JavaScript is completely
generalizable. It should be possible to implement other dynamic languages in the
same way as JavaScript using SPUR. One would have to write a runtime system for
the language in C#, as well as a compiler from the language into CIL bytecode.
Given these two elements, SPUR's tracing JIT compiler would probably do a
reasonable job at optimizing this other language (of course in practise, the
language implementation would need some tweaking and annotations to make it
really fast).</p>
</div>
</div>
<div class="section" id="comparison-with-pypy">
<h2>Comparison With PyPy</h2>
<p>The goals of PyPy and SPUR are very similar. Both projects want to implement
dynamic languages in an efficient way by using a tracing JIT. Both apply the
tracing JIT "one level down", i.e. the runtime system of the dynamic language is
visible to the tracing JIT. This is the crucial point of the approach of both
projects. Since the runtime system of the dynamic language is visible to the
tracing JIT, the JIT can optimize programs in that dynamic language. It does not
itself need to know about the semantics of the dynamic language. This makes the
tracing JIT usable for a variety of dynamic languages. It also means that the
two halves can be implemented and debugged independently.</p>
<p>In SPUR, C# (or another language that is compilable to CIL) plays the role of
RPython, and CIL is equivalent to the intermediate format that PyPy's
translation toolchain uses. Both formats operate on a similar abstraction level,
they are quite close to C, but still have support for the object system of their
respective language and are garbage-collected.</p>
<p>SPUR supports only a JavaScript implementation so far, which could maybe change in
the future. Thus JavaScript in SPUR corresponds to Python in PyPy, which was the
first dynamic language implemented in PyPy (and is also the reason for PyPy's
existence).</p>
<p>There are obviously also differences between the two projects, although many of
them are only skin-deep. The largest difference is the reliance of SPUR on
compilers on all levels. PyPy takes the opposite approach of using interpreters
almost everywhere. The parts of PyPy that correspond to SPUR's compilers are (I
will use the Python implementation of PyPy as an example):</p>
<ul class="simple">
<li>the <em>JavaScript-to-CIL compiler</em> corresponds to the Python interpreter of PyPy</li>
<li>the <em>profiling JIT</em> corresponds to a part of PyPy's translation toolchain
which adds some profiling support in the process of turning RPython code into
C code,</li>
<li>the <em>tracing JIT</em> corresponds to a special interpreter in the PyPy JIT which
executes an RPython program and produces a trace of the execution</li>
<li>the <em>transfer-tail JIT</em> corresponds to PyPy's <a class="reference external" href="../posts/2010/06/blackhole-interpreter-2752965445510091289.html">blackhole interpreter</a>, also
called fallback interpreter</li>
<li>the <em>optimizing JIT</em> corresponds to the optimizers and backends of PyPy's JIT</li>
</ul>
<div class="section" id="pypy-s-optimizations">
<h3>PyPy's Optimizations</h3>
<p>Comparing the optimizations that the two projects perform, the biggest
difference is that PyPy does "trace stitching" instead of fully supporting trace
trees. The difference between the two concerns what happens when a new trace
gets added to an existing loop. The new trace starts from a guard in the
existing loop that was observed to fail often. Trace stitching means that the
loop is just patched with a jump to the new trace. SPUR instead recompiles the
whole trace tree, which gives the optimizers more opportunities, but also makes
compilation a lot slower. Another difference is that PyPy does not perform
loop-invariant code motion yet.</p>
<p>Many of the remaining optimizations are very similar. PyPy supports guard
implication as well as guard strengthening. It has some load/store
optimizations, but PyPy's alias analysis is quite rudimentary. On the other
hand, PyPy's escape analysis is very powerful. PyPy also has support for the
annotations that SPUR supports, using some decorators in the <tt class="docutils literal">pypy.rlib.jit</tt>
module. User-controlled loop unrolling is performed using the <tt class="docutils literal">unroll_safe</tt>
decorator, tracing of a function can be disabled with the <tt class="docutils literal">dont_look_inside</tt>
decorator.</p>
<p>PyPy has a few more annotations that were not mentioned in the SPUR tech report.
Most importantly, it is possible to declare a function as pure, using the
<tt class="docutils literal">purefunction</tt> decorator. PyPy's optimizers will remove calls to a function
decorated that way if the arguments to the call are all constant. In addition it
is possible to declare instances of classes to be immutable, which means that
field accesses on constant instances can be folded away. Furthermore there is
the promote hint, which is spelled <tt class="docutils literal">x = hint(x, promote=True)</tt>. This will
produce a guard in the trace, to turn <tt class="docutils literal">x</tt> into a constant after the guard.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>Given the similarity between the projects' goals, it is perhaps not so
surprising to see that PyPy and SPUR have co-evolved and reached many similar
design decisions. It is still very good to see another project that does many
things in the same way as PyPy.</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-8658762782913680475">
        <div class="comment-header">
          <a name="comment-8658762782913680475"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-07-04 09:27</span>:
        </div>
        <div class="comment-content">
          <p>Besides being similar projects, is it possible to cross the streams? Could PyPy's CLI backend take the place of the JavaScript-to-CIL compiler (or is that the wrong parallel)?</p>
        </div>
      </div>
      <div class="comment comment-712203472780832940">
        <div class="comment-header">
          <a name="comment-712203472780832940"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-07-04 21:55</span>:
        </div>
        <div class="comment-content">
          <p>@Anonymous: I guess you could program stuff in RPython, compile to CIL and get it jitted by SPUR. However, this wouldn't work well for our main RPython programs, which are all interpreters. Using a tracing JIT on an interpreter without doing anything special is not helping much.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/06/blackhole-interpreter-2752965445510091289.html" class="u-url">"Blackhole" interpreter</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/armin-rigo.html">Armin Rigo</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/06/blackhole-interpreter-2752965445510091289.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-06-26T16:56:00Z" itemprop="datePublished" title="2010-06-26 16:56">2010-06-26 16:56</time></a>
            </p>
                <p class="commentline">8 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Hi all,</p>

<p>Here are a few words about the JIT's "great speedup in compiling
time" advertized on the PyPy 1.3 release (see the
<a href="../posts/2010/06/pypy-13-released-8546085566902489304.html">
previous blog post</a>).
The exact meaning behind these words needs a fair bit of
explanation, so here it is in case you are interested.</p>

<p>If you download a version of PyPy 1.3 that includes a JIT
compiler, you get an executable that could be qualified as rather
fat: it actually contains <b>three</b> interpreters.  You have on the
one hand the regular Python interpreter.  It is here because it's
not possible to JIT-compile every single piece of Python code you
try to run; only the most executed loops are JIT-compiled.  They
are JIT-compiled with a tracing interpreter that operates one
level down.  This is the second interpreter.  This tracing step
is quite slow, but it's all right because it's only invoked on
the most executed loops (on the order of 100 to 1000 times in
total in a run of a Python script that takes anyway seconds or
minutes to run).</p>

<p>So apart from the JIT compilation itself, we have two worlds in
which the execution proceeds: either by regular interpretation,
or by the execution of assembler code generated by the JIT
compiler.  And of course, we need to be able to switch from one
world to the other quickly: during regular interpretation we have
to detect if we already have generated assembler for this piece
of code and if so, jump to it; and during execution of the
assembler, when a "guard" fails, i.e. when we meet a path of
execution for which we did not produce assembler, then we need to
switch back to regular interpretation (or occasionally invoke the
JIT compiler again).</p>

<p>Let us consider the cost of switching from one world to another.
During regular interpretation, if we detect that we already have
assembler corresponding to this Python loop, then we just jump to
it instead of interpreting the Python loop.  This is fairly
cheap, as it involves just one fast extra check per Python loop.
The reverse is harder because "guard" failures can occur at any
point in time: it is possible that the bit of assembler that we
already executed so far corresponds to running the first 4 Python
opcodes of the loop <b>and a half.</b>  The guard that failed just now
is somewhere in the middle of interpreting that opcode -- say,
multiplying these two Python objects.</p>

<p>It's almost impossible to just "jump" at the right place in the
code of the regular interpreter -- how do you jump inside a
regular function compiled in C, itself in a call chain, resuming
execution of the function from somewhere in the middle?</p>

<p>So here is the important new bit in PyPy 1.3.  Previously, what
we would do is invoke the JIT compiler again in order to follow
what needs to happen between the guard failure and the real end
of the Python opcode.  We would then throw away the trace
generated, as the only purpose was to finish running the current
opcode.  We call this "blackhole interpretation".  After the end
of the Python opcode, we can jump to the regular interpreter
easily.</p>

<p>Doing so was straightforward, but slow, in case it needs to be
done very often (as in the case in some examples, but not all).
In PyPy 1.3, this blackhole interpretation step has been
redesigned as a time-critical component, and that's where the
third interpreter comes from.  It is an interpreter that works
like the JIT compiler, but without the overhead of tracing (e.g.
it does not need to box all values).  It was designed from the
ground up for the sole purpose of finishing the execution of the
current Python opcode.  The bytecode format that it interprets is
also new, designed for that purpose, and the JIT compiler itself
(the second interpreter) was adapted to it.
The old bytecode format in PyPy 1.2 is gone
(it was more suited for the JIT compiler, but less for blackhole
interpretation).</p>

<p>In summary, it was a lot of changes in the most front-end-ish
parts of the JIT compiler, even though it was mostly hidden
changes.  I hope that this longish blog post helped bring it a
bit more to the light :-)</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-1441880642803555722">
        <div class="comment-header">
          <a name="comment-1441880642803555722"></a>
            <span class="author">GRon</span> wrote on <span class="date">2010-06-26 21:06</span>:
        </div>
        <div class="comment-content">
          <p>Interesting, is there any documentation for the different bytecode sets you have/had?<br><br>I would be especially interested in the differences, and the reasons for those design decisions.</p>
        </div>
      </div>
      <div class="comment comment-5616958369044142996">
        <div class="comment-header">
          <a name="comment-5616958369044142996"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2010-06-26 23:11</span>:
        </div>
        <div class="comment-content">
          <p>I fear not.  The bytecode set is quite custom, made to represent RPython code, which is at the level (roughly speaking) of Java -- with a few additional instructions to guide the JIT compiler.  The latest version uses a register-based machine, which is more convenient than a Java-like stack-based approach starting from the control flow graphs of RPython functions.  It has three independent sets of registers: integers, pointers, and floating-point (pointers are different from integers at this level because the GC needs to track them and possibly move them).  Register numbers are encoded in one byte, so there is room for 256 registers of each kind, but in practice doing a simple register allocation step on each graph means that no bytecode ends up using more than ~15 registers.  A few parts are needed only by the JIT compiler and not by the blackhole interpreter; these are encoded "off-line" to avoid slowing down the blackhole interpreter.<br><br>Well, I could talk at length about all the details of the format, but in truth there is nothing very deep there :-)  See the comments in https://codespeak.net/svn/pypy/trunk/pypy/jit/codewriter/codewriter.py as well as the tests like test/test_flatten.py and test/test_regalloc.py.</p>
        </div>
      </div>
      <div class="comment comment-6743227580682071405">
        <div class="comment-header">
          <a name="comment-6743227580682071405"></a>
            <span class="author">Zeev</span> wrote on <span class="date">2010-06-27 01:40</span>:
        </div>
        <div class="comment-content">
          <p>Does the PyPy JIT replace a running interpreted loop with a compiled one mid-run or only on the next iteration or only the next time this loop starts?<br><br>Is there a way to ask the PyPy interpreter to tell me what it jitted as it ran some code? <br><br>Or will it be too difficult for me to relate the produced machine code with my python source code (because it's not a straightforward method jit)?</p>
        </div>
      </div>
      <div class="comment comment-5643690073582497501">
        <div class="comment-header">
          <a name="comment-5643690073582497501"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-06-27 17:00</span>:
        </div>
        <div class="comment-content">
          <p>Hi Zeev.<br><br>Only at the next iteration of the loop. However, you have to have at least ~1000 iterations before it happens.<br><br>There is a variety of tools that we use for inspecting generated loops. There is no programmable interface from python yet, but there are some external tools.<br><br>Run: PYPYJITLOG=jit-log-opt:log pypy <br><br>and you'll get a file log which contains all the loops. There are tools in the source checkout pypy/jit/tool, loopviewer.py, showstats.py and traceviewer.py which can help you viewing those loops. They'll contain debug_merge_points which are with info about python opcodes (including functions and file), but they can span several functions. Have fun :)<br><br>If you want more info, drop by on #pypy at irc.freenode.net.<br><br>Cheers,<br>fijal</p>
        </div>
      </div>
      <div class="comment comment-78038086288113139">
        <div class="comment-header">
          <a name="comment-78038086288113139"></a>
            <span class="author">Luis</span> wrote on <span class="date">2010-06-30 02:20</span>:
        </div>
        <div class="comment-content">
          <p>Is this Blackhole interpreter the Jaegermonkey of pypy?</p>
        </div>
      </div>
      <div class="comment comment-3093444930825975525">
        <div class="comment-header">
          <a name="comment-3093444930825975525"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2010-07-08 16:26</span>:
        </div>
        <div class="comment-content">
          <p>Luis: no.</p>
        </div>
      </div>
      <div class="comment comment-5405860422710615418">
        <div class="comment-header">
          <a name="comment-5405860422710615418"></a>
            <span class="author">Antonio Cuni</span> wrote on <span class="date">2010-07-08 16:47</span>:
        </div>
        <div class="comment-content">
          <p>@Luis: just to expand a bit Armin's answer :-).<br><br>Jaegermonkey is a method-by-method compiler that Tracemonkey uses *before* the tracing compiler enters in action. In pypy, this is equivalent to the normal Python interpreter that profiles your loops to find the hot ones, with the obvious difference that Jaegermonkey is a compiler, while ours is an interpreter.<br><br>The blackhole interpreter is something that it's used internally by our tracing jit compiler, and AFAIK it has no equivalent in tracemonkey.</p>
        </div>
      </div>
      <div class="comment comment-8789568275892407486">
        <div class="comment-header">
          <a name="comment-8789568275892407486"></a>
            <span class="author">Luis</span> wrote on <span class="date">2010-07-08 23:27</span>:
        </div>
        <div class="comment-content">
          <p>I see. Thanks Armin and Antonio.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/06/pypy-13-released-8546085566902489304.html" class="u-url">PyPy 1.3 released</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/06/pypy-13-released-8546085566902489304.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-06-26T00:21:00Z" itemprop="datePublished" title="2010-06-26 00:21">2010-06-26 00:21</time></a>
            </p>
                <p class="commentline">2 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Hello.</p>
<p>We're please to announce the release of <a href="https://pypy.org/download.html">PyPy 1.3</a>. This release has two major
improvements. First of all, we stabilized the JIT compiler since 1.2 release,
answered user issues, fixed bugs, and generally improved speed.</p>
<p>We're also pleased to announce alpha support for loading CPython extension
modules written in C. While the main purpose of this release is increased
stability, this feature is in alpha stage and it is not yet suited for
production environments.</p>
<div class="section" id="highlight-of-this-release">
<h3>Highlights of this release</h3>
<ul>
<li>
<p class="first">We introduced support for CPython extension modules written in C. As of now,
this support is in alpha, and it's very unlikely unaltered C extensions will
work out of the box, due to missing functions or refcounting details. The
support is disabled by default, so you have to do:</p>
<pre class="literal-block">
import cpyext
</pre>
<p>before trying to import any .so file. Also, libraries are source-compatible
and not binary-compatible. That means you need to recompile binaries, using
for example:</p>
<pre class="literal-block">
pypy setup.py build
</pre>
<p>Details may vary, depending on your build system. Make sure you include
the above line at the beginning of setup.py or put it in your PYTHONSTARTUP.</p>
<p>This is alpha feature. It'll likely segfault. You have been warned!</p>
</li>
<li>
<p class="first">JIT bugfixes. A lot of bugs reported for the JIT have been fixed, and its
stability greatly improved since 1.2 release.</p>
</li>
<li>
<p class="first">Various small improvements have been added to the JIT code, as well as a great
speedup of compiling time.</p>
</li>
</ul>
</div>
<p>
Cheers,<br>
Maciej Fijalkowski, Armin Rigo, Alex Gaynor, Amaury Forgeot d'Arc and the PyPy team
</p>
<p>
<b>Update:</b>The correct command to build extension is "pypy setup.py build", not "python setup.py build" as it was stated before.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-5648441706428326477">
        <div class="comment-header">
          <a name="comment-5648441706428326477"></a>
            <span class="author">Isaac Gouy</span> wrote on <span class="date">2010-06-27 23:18</span>:
        </div>
        <div class="comment-content">
          <p>fyi <a href="https://shootout.alioth.debian.org/u32/compare.php?lang=pypy&amp;lang2=python" rel="nofollow">benchmarks game</a></p>
        </div>
      </div>
      <div class="comment comment-2996214905147318391">
        <div class="comment-header">
          <a name="comment-2996214905147318391"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-06-28 07:04</span>:
        </div>
        <div class="comment-content">
          <p>Thanks. I don't think we improved in any of the areas measured by those benchmarks (even if, only by a tiny bit).<br><br>Cheers,<br>fijal</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/06/jit-for-regular-expression-matching-3877859053629057968.html" class="u-url">A JIT for Regular Expression Matching</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/06/jit-for-regular-expression-matching-3877859053629057968.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-06-08T12:53:00Z" itemprop="datePublished" title="2010-06-08 12:53">2010-06-08 12:53</time></a>
            </p>
                <p class="commentline">11 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>This is <strong>part 2</strong> of a series, see <a class="reference external" href="../posts/2010/05/efficient-and-elegant-regular-2727904462179540436.html">Part 1</a> for an introduction. In this post
I want to describe how the JIT generator of the PyPy project can be used to turn
the elegant but not particularly fast regular expression matcher from the first
part into a rather fast implementation. In addition, I will show some speed
measurements against various regular expression implementations.</p>
<p>Again, note the <strong>disclaimer</strong>: This technology could not easily be used
to implement Python's <tt class="docutils literal">re</tt>-module.</p>
<div class="section" id="example-expression-and-first-numbers">
<h2>Example Expression and First Numbers</h2>
<p>The regular expression I will use as an example in the rest of this paper is
the expression <tt class="docutils literal"><span class="pre">(a|b)*a(a|b){20}a(a|b)*</span></tt>. It matches all strings that have two
<tt class="docutils literal">a</tt> with exactly 20 characters between them. This regular expression has
the property that the corresponding DFA needs <tt class="docutils literal"><span class="pre">2**(n+1)</span></tt> different states. As
an input string, we use a random string (of varying lengths) that does <em>not</em>
match the regular expression. I will give all results as number of chars matched
per second. While this is not a particularly typical regular expression, it
should still be possible to get some ballpark numbers for the speeds of various
implementations â€“ as we will see, the differences between implementations are
huge anyway.</p>
<p>All the benchmarks were performed on my laptop, which has an Intel Core2 Duo
P8400 processor with 2.26 GHz and 3072 KB of cache on a machine with 3GB RAM
running Ubuntu Linux 10.04.</p>
<p>To get a feeling for the orders of magnitude involved, the <a class="reference external" href="https://docs.python.org/library/re.html">CPython re module</a>
(which is implemented in C and quite optimized) can match 2'500'000 chars/s.
Google's new <a class="reference external" href="https://code.google.com/p/re2/">re2 implementation</a> still matches 550'000 chars/s. Google's
implementation is slower, but their algorithm gives complexity and space
guarantees similar to our implementation in the last blog post.</p>
<p>On the other end of the performance scale is the pure-Python code from the last
blog post running on CPython. It can match only 12'200 chars/s and is thus 200
times slower than the <tt class="docutils literal">re</tt> module.</p>
</div>
<div class="section" id="translating-the-matcher">
<h2>Translating the Matcher</h2>
<p>The code described in the last blog post is not only normal Python code, but
also perfectly valid RPython code. Nothing particularly dynamic is going on in
the code, thus it can be translated with PyPy's translation toolchain to C code.
The resulting binary is considerably faster and can match 720'000 chars/s, 60
times faster than the untranslated version.</p>
<p>Another approach is to write equivalent versions of the algorithms in lower
level languages. This has been done for C++ by Sebastian Fischer and for Java by
Baltasar TrancÃ³n y Widemann. The algorithm is object-oriented enough to be
mapped very closely to the respective languages. The C++ version is
a little bit faster than the RPython version translated to C, at 750'000 chars/s. That's
not very surprising, given their similarity. The Java version is more than twice
as fast, with 1'920'000 chars/s. Apparently the Java JIT compiler is a lot
better at optimizing the method calls in the algorithm or does some other
optimizations. One reason for this could be that the Java JIT can assume that
the classes it sees are all there are (and it will invalidate the generated
machine code if more classes are loaded), whereas the C++ compiler needs to
generate code that works even in the presence of more regular expression
classes.</p>
</div>
<div class="section" id="generating-a-jit">
<h2>Generating a JIT</h2>
<p>To get even more performance out of the RPython code, it is possible to generate
a JIT for it with the help of the PyPy translation toolchain. To do this, the
matching code needs to be extended somewhat by some hints that tell PyPy's JIT
generator how this is to be done. The JIT generator can automatically produce a
JIT compiler from an RPython interpreter of the source language. In our case,
we view the regular expression matcher as an interpreter for regular
expressions. Then the <tt class="docutils literal">match</tt> function corresponds to the
dispatch loop of a traditional interpreter.</p>
<p>Our regular expression matcher is a very peculiar interpreter. The matcher
works by running exactly one loop (the one in <tt class="docutils literal">match</tt>) as many times as the
input string is long, irrespective of the "program", i.e. the particular
regular expressions. In addition, within the loop there are no conditions (e.g.
if statements) at all, it is just linear code. This makes it almost perfectly
suited
to the JIT generator, which produces a tracing JIT. A tracing JIT compiles the
hot loops of a program (i.e. regular expression) and has to do extra work if
there are conditions in the loop. In our case, there is exactly one loop per
regular expression, without any condition.</p>
<div class="section" id="jit-hints">
<h3>JIT Hints</h3>
<p>The hints that are needed for the <tt class="docutils literal">match</tt> function of the last blog post can
be seen here (the function is slightly rewritten, e.g. the JIT does only
properly support a <tt class="docutils literal">while</tt> loop as the main dispatch loop):</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;">jitdriver <span style="color: #555555;">=</span> jit<span style="color: #555555;">.</span>JitDriver(reds<span style="color: #555555;">=</span>[<span style="color: #CC3300;">"i"</span>, <span style="color: #CC3300;">"result"</span>, <span style="color: #CC3300;">"s"</span>], greens<span style="color: #555555;">=</span>[<span style="color: #CC3300;">"re"</span>])

<span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">match</span>(re, s):
    <span style="color: #006699; font-weight: bold;">if</span> <span style="color: #000000; font-weight: bold;">not</span> s:
        <span style="color: #006699; font-weight: bold;">return</span> re<span style="color: #555555;">.</span>empty
    <span style="color: #0099FF; font-style: italic;"># shift a mark in from the left</span>
    result <span style="color: #555555;">=</span> re<span style="color: #555555;">.</span>shift(s[<span style="color: #FF6600;">0</span>], <span style="color: #FF6600;">1</span>)
    i <span style="color: #555555;">=</span> <span style="color: #FF6600;">1</span>
    <span style="color: #006699; font-weight: bold;">while</span> i <span style="color: #555555;">&lt;</span> <span style="color: #336666;">len</span>(s):
        jitdriver<span style="color: #555555;">.</span>can_enter_jit(i<span style="color: #555555;">=</span>i, result<span style="color: #555555;">=</span>result, s<span style="color: #555555;">=</span>s, re<span style="color: #555555;">=</span>re)
        jitdriver<span style="color: #555555;">.</span>jit_merge_point(i<span style="color: #555555;">=</span>i, result<span style="color: #555555;">=</span>result, s<span style="color: #555555;">=</span>s, re<span style="color: #555555;">=</span>re)
        <span style="color: #0099FF; font-style: italic;"># shift the internal marks around</span>
        result <span style="color: #555555;">=</span> re<span style="color: #555555;">.</span>shift(s[i], <span style="color: #FF6600;">0</span>)
        i <span style="color: #555555;">+=</span> <span style="color: #FF6600;">1</span>
    re<span style="color: #555555;">.</span>reset()
    <span style="color: #006699; font-weight: bold;">return</span> result
</pre></div>
<p>The <tt class="docutils literal">jitdriver</tt> is an instance describing the data of the interpreter we are
dealing with. The arguments to the constructor need to list all local variables
of the dispatch loop. The local variables are classified into two classes, red
ones and green ones. The green ones hold the objects that make up the program
that the interpreter currently runs and which position in the program is
currently being executed. In a typical bytecode interpreter, the bytecode object
and the program counter would be green. In our case, the regular expression is
the program, so it is green. The rest of the variables are red.</p>
<p>The green variables are treated specially by the JIT generator. At runtime, for
a given value of the green variables, one piece of machine code will be
generated. This piece of machine code can therefore assume that the value of
the green variable is constant.</p>
<p>There are two additional hints, which are method calls on the
<tt class="docutils literal">jitdriver</tt> instance. The <tt class="docutils literal">jit_merge_point</tt> method marks the beginning of
the main interpreter loop. The <tt class="docutils literal">can_enter_jit</tt> function marks the point where
a loop in the user program can be closed, which in our case is trivial, it's
just at the end of the interpreter loop (for technical reasons it is put at the beginning, because nothing must happen between the <tt class="docutils literal">can_enter_jit</tt> and <tt class="docutils literal">jit_merge_point</tt> invocations).</p>
<p>Those are the hints that the JIT generator needs to function at all. We added
some additional hints, that give the JIT generator more information to work
with. Those hints are immutability information, which means that certain
instance fields can not be changed after the object has been constructed. Apart
from the <tt class="docutils literal">marked</tt> field, none of the fields of any of the <tt class="docutils literal">Regex</tt> subclasses
can change. For example for the <tt class="docutils literal">Char</tt> class this is expressed in the
following way:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Char</span>(Regex):
    _immutable_fields_ <span style="color: #555555;">=</span> [<span style="color: #CC3300;">"c"</span>]
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, c):
        <span style="color: #555555;">...</span>
</pre></div>
<p>These hints allow the generated JIT to constant-fold reads out of the immutable
fields in some situations.</p>
</div>
<div class="section" id="adaptions-to-the-original-code">
<h3>Adaptions to the Original Code</h3>
<p>In the introduction above I wrote that the code within the loop in <tt class="docutils literal">match</tt>
uses no conditions. It is indeed true that none of the <tt class="docutils literal">_shift</tt> methods
have an <tt class="docutils literal">if</tt> statement or similar. However, there are some hidden conditions
due to the fact that the <tt class="docutils literal">and</tt> and <tt class="docutils literal">or</tt> boolean operators are used, which
are short-circuiting. Therefore the JIT-version of the code needs to be adapted
to use the non-short-circuiting operators <tt class="docutils literal">&amp;</tt> and <tt class="docutils literal">|</tt>.</p>
</div>
<div class="section" id="jit-example">
<h3>JIT Example</h3>
<p>To get an impression of how the generated machine code looks like, consider the
regular expression <tt class="docutils literal">(a|b)*</tt>. As regular expression objects this would be
<tt class="docutils literal"><span class="pre">Repetition(Alternative(Char('a'),</span> <span class="pre">Char('b')))</span></tt>. The machine code in its intermediate,
machine-independent form looks as follows (I have slightly cleaned it up and
added comments for clarity):</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #0099FF; font-style: italic;"># arguments of the loop</span>
<span style="color: #0099FF; font-style: italic;"># i0 is i in the match function</span>
<span style="color: #0099FF; font-style: italic;"># result0 is result in the match function</span>
<span style="color: #0099FF; font-style: italic;"># s0 is s in the match function</span>
[i0, result0, s0] <span style="color: #0099FF; font-style: italic;"># those are the arguments to the machine code</span>
char <span style="color: #555555;">=</span> s0[i0] <span style="color: #0099FF; font-style: italic;"># read the character</span>
<span style="color: #0099FF; font-style: italic;"># read the current mark:</span>
i5 <span style="color: #555555;">=</span> ConstPtr(ptr_repetition)<span style="color: #555555;">.</span>marked
i7 <span style="color: #555555;">=</span> char <span style="color: #555555;">==</span> <span style="color: #CC3300;">'a'</span> <span style="color: #0099FF; font-style: italic;"># is the character equal to 'a'</span>
i8 <span style="color: #555555;">=</span> i5 <span style="color: #555555;">&amp;</span> i7
i10 <span style="color: #555555;">=</span> char <span style="color: #555555;">==</span> <span style="color: #CC3300;">'b'</span> <span style="color: #0099FF; font-style: italic;"># is the character equal to 'b'</span>
i11 <span style="color: #555555;">=</span> i5 <span style="color: #555555;">&amp;</span> i10
<span style="color: #0099FF; font-style: italic;"># write new mark</span>
ConstPtr(ptr_chara)<span style="color: #555555;">.</span>marked <span style="color: #555555;">=</span> i8
i13 <span style="color: #555555;">=</span> i8 <span style="color: #555555;">|</span> i11
<span style="color: #0099FF; font-style: italic;"># write new mark</span>
ConstPtr(ptr_charb)<span style="color: #555555;">.</span>marked <span style="color: #555555;">=</span> i11
<span style="color: #0099FF; font-style: italic;"># write new mark</span>
ConstPtr(ptr_alternative)<span style="color: #555555;">.</span>marked <span style="color: #555555;">=</span> i13
<span style="color: #0099FF; font-style: italic;"># increment the index</span>
i17 <span style="color: #555555;">=</span> i0 <span style="color: #555555;">+</span> <span style="color: #FF6600;">1</span>
i18 <span style="color: #555555;">=</span> <span style="color: #336666;">len</span>(s0)
<span style="color: #0099FF; font-style: italic;"># write new mark</span>
ConstPtr(ptr_repetition)<span style="color: #555555;">.</span>marked <span style="color: #555555;">=</span> i13
<span style="color: #0099FF; font-style: italic;"># check that index is smaller than the length of the string</span>
i19 <span style="color: #555555;">=</span> i17 <span style="color: #555555;">&lt;</span> i18
<span style="color: #006699; font-weight: bold;">if</span> <span style="color: #000000; font-weight: bold;">not</span> i19:
    go back to normally running match
jump(i17, i13, s0) <span style="color: #0099FF; font-style: italic;"># start from the top again</span>
</pre></div>
<p>The various <tt class="docutils literal">ConstPtr(ptr_*)</tt> denote constant addresses of parts of the regular
expression tree:</p>
<ul class="simple">
<li>
<tt class="docutils literal">ptr_repetition</tt> is the <tt class="docutils literal">Repetition</tt>
</li>
<li>
<tt class="docutils literal">ptr_chara</tt> is <tt class="docutils literal"><span class="pre">Char('a')</span></tt>
</li>
<li>
<tt class="docutils literal">ptr_charb</tt> is <tt class="docutils literal"><span class="pre">Char('b')</span></tt>
</li>
<li>
<tt class="docutils literal">ptr_alternative</tt> is the <tt class="docutils literal">Alternative</tt>
</li>
</ul>
<p>Essentially the machine code reads the next char out of the string, the current
mark out of the <tt class="docutils literal">Repetition</tt> and then performs some boolean operations on
those, writing back the new marks. Note in particular how the generated
machine code does not need to do any method calls to <tt class="docutils literal">shift</tt> and <tt class="docutils literal">_shift</tt> and
that most field reads out of the regular expression classes have been optimized
away, because the fields are immutable. Therefore the machine code does not
need to deconstruct the tree of regular expression objects at all, it just
knows where in memory the various parts of it are, and encodes that directly
into the code.</p>
</div>
<div class="section" id="performance-results-with-jit">
<h3>Performance Results With JIT</h3>
<p>With the regular expression matcher translated to C and with a generated JIT,
the regular expression performance increases significantly. Our running example
can match 16'500'000 chars/s, which is more than six times faster than the
<tt class="docutils literal">re</tt> module. This is not an entirely fair comparison, because the <tt class="docutils literal">re</tt>
module can give more information than just "matches" or "doesn't match", but
it's still interesting to see. A more relevant comparison is that between the
program with and without a JIT: Generating a JIT speeds the matcher up by more
than 20 times.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>So, what have we actually won? We translated the relatively simple and very slow
regular expression matching algorithm from the last post to C and were thus able
to speed it up significantly. The real win is gained by also generating a JIT
for the matcher, which can be regarded as a simple interpreter. The resulting
matcher is rather fast.</p>
<p>The lesson from these posts is <strong>not</strong> that you can or should write a practical
and general regular expression module in this way â€“ indeed, enhancing the
algorithm to support more features of the <tt class="docutils literal">re</tt> module would be a lot of work
and it is also unclear what the speed results for more realistic regular
expressions would be. However, it makes for a great case study of the JIT
generator. It was relatively straightforward to generate a JIT for the regex
matcher, and the speed results were great (Admittedly I know rather a lot about
PyPy's JIT though). This approach is generalizable to many programs that are
sufficiently "interpreter-like" (whatever that exactly means).</p>
<p>All the results that appeared at various points in this blog post can be seen
here:</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%">
<col width="16%">
<col width="35%">
</colgroup>
<tbody valign="top">
<tr>
<td><strong>Implementation</strong></td>
<td><strong>chars/s</strong></td>
<td><strong>speedup over pure Python</strong></td>
</tr>
<tr>
<td>Pure Python code</td>
<td>12'200</td>
<td>1</td>
</tr>
<tr>
<td>Python <tt class="docutils literal">re</tt> module</td>
<td>2'500'000</td>
<td>205</td>
</tr>
<tr>
<td>Google's <tt class="docutils literal">re2</tt> implementation</td>
<td>550'000</td>
<td>45</td>
</tr>
<tr>
<td>RPython implementation translated to C</td>
<td>720'000</td>
<td>59</td>
</tr>
<tr>
<td>C++ implementation</td>
<td>750'000</td>
<td>61</td>
</tr>
<tr>
<td>Java implementation</td>
<td>1'920'000</td>
<td>157</td>
</tr>
<tr>
<td>RPython implementation with JIT</td>
<td>16'500'000</td>
<td>1352</td>
</tr>
</tbody>
</table>
<div class="section" id="sources">
<h3>Sources</h3>
<p>All the source code can be found in my Subversion <a class="reference external" href="https://codespeak.net/svn/user/cfbolz/hack/regex">user directory</a> on Codespeak.</p>
</div>
</div>
<p><strong>Edit:</strong></p>
<p> Armin is right (see first comment). I fixed the problem.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-7148682435671001579">
        <div class="comment-header">
          <a name="comment-7148682435671001579"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2010-06-08 13:11</span>:
        </div>
        <div class="comment-content">
          <p>Warning: the first example is wrong: there should be no code executed between can_enter_jit() and jit_merge_point().  In this case, there is the exit condition of the loop.  It needs to be rewritten as a "while True:" loop with a "break" just before can_enter_jit().</p>
        </div>
      </div>
      <div class="comment comment-5216728773885194369">
        <div class="comment-header">
          <a name="comment-5216728773885194369"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-06-08 13:35</span>:
        </div>
        <div class="comment-content">
          <p>@Armin: Damn, you're right. I fixed the blog post.</p>
        </div>
      </div>
      <div class="comment comment-768245725832846480">
        <div class="comment-header">
          <a name="comment-768245725832846480"></a>
            <span class="author">Nelson Elhage</span> wrote on <span class="date">2010-06-08 15:36</span>:
        </div>
        <div class="comment-content">
          <p>What happens if you don't replace <b>and</b> and <b>or</b>?<br><br>Without those changes, the modifications for JIT really are prety small --<br>mostly just some annotations in the main loop and at toplevel for each<br>class. With those changes, though, you need to potentially check the entire<br>codebase of your interpreter.<br><br>Pretty fun performance results, though.</p>
        </div>
      </div>
      <div class="comment comment-5311693952284725836">
        <div class="comment-header">
          <a name="comment-5311693952284725836"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-06-08 16:40</span>:
        </div>
        <div class="comment-content">
          <p>@Nelson: If you don't change the "and" and "or" you get a lot of assembler code generated, and it's not particularly fast.<br><br>Note that this "and" and "or" business is quite specific to this particular example. Usually you can work more incrementally by generating a JIT, then looking at the produced assembler and then doing some small changes in the interpreter to improve parts of it. Each such change is usually localized to one part of the interpreter improves the performance of some language feature.<br><br>This example is not really large enough to show this way of working, though :-). Maybe at some point I should write a walk-through for some interpreter.</p>
        </div>
      </div>
      <div class="comment comment-4573159838151913018">
        <div class="comment-header">
          <a name="comment-4573159838151913018"></a>
            <span class="author">Kumo</span> wrote on <span class="date">2010-06-08 22:55</span>:
        </div>
        <div class="comment-content">
          <p>Would it be possible to create a pypy or cpython extension module this way?</p>
        </div>
      </div>
      <div class="comment comment-6739734310347894753">
        <div class="comment-header">
          <a name="comment-6739734310347894753"></a>
            <span class="author">Jared Forsyth</span> wrote on <span class="date">2010-06-09 21:27</span>:
        </div>
        <div class="comment-content">
          <p>Could you post your 'test runner' code? I'm running some tests (with your) code and getting drastically different numbers...</p>
        </div>
      </div>
      <div class="comment comment-7759046243692984696">
        <div class="comment-header">
          <a name="comment-7759046243692984696"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-06-10 10:51</span>:
        </div>
        <div class="comment-content">
          <p>@jabapyth: there is no test runner code. I am simply running something like<br><br>genrandom 20 1000000 | time regex-c<br><br>What performance results are you getting? Are you sure that you translated jitregex.py with -Ojit? Otherwise the JIT is not put into the executable.</p>
        </div>
      </div>
      <div class="comment comment-5523496639679186016">
        <div class="comment-header">
          <a name="comment-5523496639679186016"></a>
            <span class="author">Maxim Yegorushkin</span> wrote on <span class="date">2010-08-02 00:19</span>:
        </div>
        <div class="comment-content">
          <p>boost::regex is not mentioned. It's got both recursive and non-recursive implementations. And it is the base of the standard C++ TR1 regex. Would be interesting to stack it up against other results because it is</p>
        </div>
      </div>
      <div class="comment comment-8419051637289499089">
        <div class="comment-header">
          <a name="comment-8419051637289499089"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-08-02 08:52</span>:
        </div>
        <div class="comment-content">
          <p>We can't possibly include all regex engines (even if we would like to). However, sources are out there and you can always rerun those benchmarks and see how it compares :-)<br><br>Cheers,<br>fijal</p>
        </div>
      </div>
      <div class="comment comment-3637081753993436602">
        <div class="comment-header">
          <a name="comment-3637081753993436602"></a>
            <span class="author">Nikhil</span> wrote on <span class="date">2013-01-12 21:25</span>:
        </div>
        <div class="comment-content">
          <p>I'm not able to access the code on codespeak.net. Has the code been moved to some other place?</p>
        </div>
      </div>
      <div class="comment comment-8717716605101751071">
        <div class="comment-header">
          <a name="comment-8717716605101751071"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2013-01-12 22:40</span>:
        </div>
        <div class="comment-content">
          <p>The code has been merged to PyPy since I think. Look up cfbolz repos on bitbucket though</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/05/pypy-in-googles-summer-of-code-2010-5321939902318322352.html" class="u-url">PyPy in Google's Summer of Code 2010</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/05/pypy-in-googles-summer-of-code-2010-5321939902318322352.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-05-31T22:55:00Z" itemprop="datePublished" title="2010-05-31 22:55">2010-05-31 22:55</time></a>
            </p>
                <p class="commentline">4 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Good news everyone.</p>
<p>This year, thanks to <a class="reference external" href="https://google.com">google</a> generosity and <a class="reference external" href="https://www.python.org/psf/">PSF</a> support, we got two and a
half of students for PyPy's summer of code. We didn't cut any students, but one
of the projects is a joint project of PyPy and <a class="reference external" href="https://numpy.scipy.org/">numpy</a>. Hereby I present
descriptions, in my own words with my own opinions and in arbitrary order.  For
more details please follow links to particular blogs.</p>
<div class="section" id="jason-creighton-64bit-jit-backend-for-pypy">
<h3>
<a class="reference external" href="https://jcreigh.blogspot.com/">Jason Creighton</a>: 64bit JIT backend for PyPy</h3>
<p>Intel 64bit (and I mean <a class="reference external" href="https://en.wikipedia.org/wiki/X86_64">x86_64</a>) compatibility for JIT has been one of the top
requested features (along with GIL removal). While GIL removal is not really an
easy task, having our JIT emit 64bit assembler is sort of easy, thanks to our
JIT backend abstraction. It will likely be faster, thanks to abundance of
registers.</p>
</div>
<div class="section" id="bartosz-skowron-fast-ctypes-for-pypy">
<h3>
<a class="reference external" href="https://hack.bartskowron.com/">Bartosz Skowron</a>: Fast ctypes for PyPy</h3>
<p>Historically weak point of PyPy was compatibility with extension modules.  We
have progressed quite a bit in recent years, first introducing <a class="reference external" href="https://docs.python.org/library/ctypes.html">ctypes</a> for
pypy then progressing towards <a class="reference external" href="../posts/2010/04/using-cpython-extension-modules-with-5864754772659599217.html">CPython extension modules</a>. However, ctypes is
well known to be slow (and it's even slower on PyPy) and writing CPython
extension modules is ugly, and it's going to be only with compatibility layer
that'll keep this slow. What happens if we try to employ JIT technology to
ctypes? Maybe we can compile calls to C code from Python as a direct calls in
compiled assembler? Why not?</p>
<p>This project will look how the JIT technology can be employed to do some
sort of FFI. There is no guarantee we'll get super-fast ctypes as a result,
but it's good to see progress in that area.</p>
</div>
<div class="section" id="dan-roberts-numpy-in-pypy">
<h3>
<a class="reference external" href="https://ademan.wordpress.com/">Dan Roberts</a>: Numpy in PyPy</h3>
<p>This is a joint project of numpy and PyPy. The main objective is to bring
numpy to PyPy, possibly fast. The official mentor for this project is
Stefan van der Walt from numpy community. During initial meeting it was
agreed that probably the best way to go would be to support original numpy
with CPython extension compatibility and then provide a minimal native numpy
framework for pypy. The former would retain full compatibility, while the
latter would have JIT integration, with line of our previous
<a class="reference external" href="../posts/2009/07/pypy-numeric-experiments-2221073696038673235.html">numeric experiments</a>. There would be an explicit interface from converting
one array to another for convinience.</p>
</div>
<p>Overall, I'm very happy to see so much support for PyPy from SoC. I hope all
three proposals will be successful!</p>
<p>Cheers,<br>
fijal &amp; pypy team.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-6100242546629345697">
        <div class="comment-header">
          <a name="comment-6100242546629345697"></a>
            <span class="author">Michael Twomey</span> wrote on <span class="date">2010-06-01 11:48</span>:
        </div>
        <div class="comment-content">
          <p>Some really nice stuff in there, very interested in the potential for JIT + numpy, keep up the good work!</p>
        </div>
      </div>
      <div class="comment comment-9091852146361200513">
        <div class="comment-header">
          <a name="comment-9091852146361200513"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-06-01 11:53</span>:
        </div>
        <div class="comment-content">
          <p>Cool projects. Two of them live as PyPy branches:<br><br>https://codespeak.net/viewvc/pypy/branch/x86-64-jit-backend/<br><br>https://codespeak.net/viewvc/pypy/branch/fast-ctypes/<br><br>Where can we follow the NumPy work? :)</p>
        </div>
      </div>
      <div class="comment comment-1746825368539618487">
        <div class="comment-header">
          <a name="comment-1746825368539618487"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2010-06-07 16:16</span>:
        </div>
        <div class="comment-content">
          <p>when will pypy catch up with python 3.1? will it happen during the python language moratorium (pep 3003)?</p>
        </div>
      </div>
      <div class="comment comment-513347147875147381">
        <div class="comment-header">
          <a name="comment-513347147875147381"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-06-10 20:08</span>:
        </div>
        <div class="comment-content">
          <p>@horace<br><br>Depends when you can help :)</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/05/efficient-and-elegant-regular-2727904462179540436.html" class="u-url">An Efficient and Elegant Regular Expression Matcher in Python</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/05/efficient-and-elegant-regular-2727904462179540436.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-05-21T13:34:00Z" itemprop="datePublished" title="2010-05-21 13:34">2010-05-21 13:34</time></a>
            </p>
                <p class="commentline">11 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Two weeks ago, I was at the Workshop <a class="reference external" href="https://www-ps.informatik.uni-kiel.de/fg214/Honnef2010/">Programmiersprachen und Rechenkonzepte</a>,
a yearly meeting of German programming language researchers. At the workshop,
<a class="reference external" href="https://www-ps.informatik.uni-kiel.de/~fhu/">Frank Huch</a> and <a class="reference external" href="https://www-ps.informatik.uni-kiel.de/~sebf/">Sebastian Fischer</a> gave a really <a class="reference external" href="https://www-ps.informatik.uni-kiel.de/fg214/Honnef2010/Abstracts/Fischer.pdf">excellent talk</a> about an
elegant regular expression matcher written in Haskell. One design goal of the
matcher was to run in time linear to the length of the input string (i.e.
without backtracking) and linear in the size of the regular expression. The
memory use should also only be linear in the regular expression.</p>
<p>During the workshop, some of the Haskell people and me then implemented the
algorithm in (R)Python. Involved were Frank, Sebastian, <a class="reference external" href="https://www.bayceer.uni-bayreuth.de/mod/de/mitarbeiter/mit/mitarbeiter_detail.php?id_obj=59348">Baltasar TrancÃ³n y
Widemann</a>, <a class="reference external" href="https://www.informatik.uni-kiel.de/prog/mitarbeiter/bernd-brassel/">Bernd BraÃŸel</a> and <a class="reference external" href="https://www.informatik.uni-kiel.de/prog/mitarbeiter/fabian-reck/">Fabian Reck</a>.</p>
<p>In this blog post I want to describe this implementation and show the code of
it, because it is quite simple. In a later post I will show what optimizations
PyPy can perform on this matcher and also do some benchmarks.</p>
<p><strong>A Note on terminology:</strong> In the rest of the post "regular expression" is meant
in the <a class="reference external" href="https://en.wikipedia.org/wiki/Regular_expressions#Formal_language_theory">Computer Science sense</a>, not in the <a class="reference external" href="https://en.wikipedia.org/wiki/Regular_expressions#POSIX_.28Portable_Operating_System_Interface_.5Bfor_Unix.5D.29">POSIX sense</a>. Most importantly, that
means that back-references are not allowed.</p>
<p><strong>Another note:</strong> This algorithm could not be used to implement PyPy's <tt class="docutils literal">re</tt>
module! So it won't help to speed up this currently rather slow implementation.</p>
<div class="section" id="implementing-regular-expression-matchers">
<h2>Implementing Regular Expression Matchers</h2>
<p>There are two typical approaches to implement regular expression. A naive one is
to use a back-tracking implementation, which can lead to exponential matching
times given a sufficiently evil regular expression.</p>
<p>The other, more complex one, is to transform the regular expression into a
<a class="reference external" href="https://en.wikipedia.org/wiki/Nondeterministic_finite_state_machine">non-deterministic finite automaton</a> (NFA) and then transform the NFA into a
<a class="reference external" href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic finite automaton</a> (DFA). A DFA can be used to efficiently match
a string, the problem of this approach is that turning an NFA into a DFA can
lead to exponentially large automatons.</p>
<p>Given this problem of potential memory explosion, a more sophisticated approach
to matching is to not construct the DFA fully, but instead use the NFA for
matching. This requires some care, because it is necessary to keep track of
which set of states the automaton is in (it is not just one state, because the
automaton is non-deterministic).</p>
<p>The algorithm described here is essentially equivalent to this approach, however
it does not need an intermediate NFA and represents a state of a corresponding
DFA as marked regular expression (represented as a tree of nodes). For many
details about an alternative approach to implement regular expressions
efficiently, see <a class="reference external" href="https://swtch.com/~rsc/regexp/">Russ Cox excellent article collection</a>.</p>
</div>
<div class="section" id="the-algorithm">
<h2>The Algorithm</h2>
<p>In the algorithm the regular expression is represented as a tree of nodes. The
leaves of the nodes can match exactly one character (or the epsilon node, which
matches the empty string). The inner nodes of the tree combine other nodes in
various ways, like alternative, sequence or repetition. Every node in the tree
can potentially have a mark. The meaning of the mark is that a node is marked,
if that sub-expression matches the string seen so far.</p>
<p>The basic approach of the algorithm is that for every character of the input
string the regular expression tree is walked and a number of the nodes in the
regular expression are marked. At the end of the string, if the top-level node
is marked, the string matches, otherwise it does not. At the beginning of the
string, one mark gets shifted into the regular expression from the top, and then
the marks that are in the regex already are shifted around for every additional
character.</p>
<p>Let's start looking at some code, and an example to make this clearer. The base
class of all regular expression nodes is this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Regex</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, empty):
        <span style="color: #0099FF; font-style: italic;"># empty denotes whether the regular expression</span>
        <span style="color: #0099FF; font-style: italic;"># can match the empty string</span>
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>empty <span style="color: #555555;">=</span> empty
        <span style="color: #0099FF; font-style: italic;"># mark that is shifted through the regex</span>
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>marked <span style="color: #555555;">=</span> <span style="color: #336666;">False</span>

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">reset</span>(<span style="color: #336666;">self</span>):
        <span style="color: #CC3300; font-style: italic;">""" reset all marks in the regular expression """</span>
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>marked <span style="color: #555555;">=</span> <span style="color: #336666;">False</span>

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">shift</span>(<span style="color: #336666;">self</span>, c, mark):
        <span style="color: #CC3300; font-style: italic;">""" shift the mark from left to right, matching character c."""</span>
        <span style="color: #0099FF; font-style: italic;"># _shift is implemented in the concrete classes</span>
        marked <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>_shift(c, mark)
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>marked <span style="color: #555555;">=</span> marked
        <span style="color: #006699; font-weight: bold;">return</span> marked
</pre></div>
<p>The <tt class="docutils literal">match</tt> function which checks whether a string matches a regex is:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">match</span>(re, s):
    <span style="color: #006699; font-weight: bold;">if</span> <span style="color: #000000; font-weight: bold;">not</span> s:
        <span style="color: #006699; font-weight: bold;">return</span> re<span style="color: #555555;">.</span>empty
    <span style="color: #0099FF; font-style: italic;"># shift a mark in from the left</span>
    result <span style="color: #555555;">=</span> re<span style="color: #555555;">.</span>shift(s[<span style="color: #FF6600;">0</span>], <span style="color: #336666;">True</span>)
    <span style="color: #006699; font-weight: bold;">for</span> c <span style="color: #000000; font-weight: bold;">in</span> s[<span style="color: #FF6600;">1</span>:]:
        <span style="color: #0099FF; font-style: italic;"># shift the internal marks around</span>
        result <span style="color: #555555;">=</span> re<span style="color: #555555;">.</span>shift(c, <span style="color: #336666;">False</span>)
    re<span style="color: #555555;">.</span>reset()
    <span style="color: #006699; font-weight: bold;">return</span> result
</pre></div>
<p>The most important subclass of <tt class="docutils literal">Regex</tt> is <tt class="docutils literal">Char</tt>, which matches one
concrete character:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Char</span>(Regex):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, c):
        Regex<span style="color: #555555;">.</span>__init__(<span style="color: #336666;">self</span>, <span style="color: #336666;">False</span>)
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>c <span style="color: #555555;">=</span> c

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">_shift</span>(<span style="color: #336666;">self</span>, c, mark):
        <span style="color: #006699; font-weight: bold;">return</span> mark <span style="color: #000000; font-weight: bold;">and</span> c <span style="color: #555555;">==</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>c
</pre></div>
<p>Shifting the mark through <tt class="docutils literal">Char</tt> is easy: a <tt class="docutils literal">Char</tt> instance retains a mark
that is shifted in when the current character is the same as that in the
instance.</p>
<p>Another easy case is that of the empty regular expression <tt class="docutils literal">Epsilon</tt>:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Epsilon</span>(Regex):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>):
        Regex<span style="color: #555555;">.</span>__init__(<span style="color: #336666;">self</span>, empty<span style="color: #555555;">=</span><span style="color: #336666;">True</span>)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">_shift</span>(<span style="color: #336666;">self</span>, c, mark):
        <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">False</span>
</pre></div>
<p><tt class="docutils literal">Epsilons</tt> never get a mark, but they can match the empty string.</p>
<div class="section" id="alternative">
<h3>Alternative</h3>
<p>Now the more interesting cases remain. First we define an abstract base class
<tt class="docutils literal">Binary</tt> for the case of composite regular expressions with two children, and
then the first subclass <tt class="docutils literal">Alternative</tt> which matches if either of two regular
expressions matches the string (usual regular expressions syntax <tt class="docutils literal">a|b</tt>).</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Binary</span>(Regex):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, left, right, empty):
        Regex<span style="color: #555555;">.</span>__init__(<span style="color: #336666;">self</span>, empty)
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>left <span style="color: #555555;">=</span> left
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>right <span style="color: #555555;">=</span> right

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">reset</span>(<span style="color: #336666;">self</span>):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>left<span style="color: #555555;">.</span>reset()
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>right<span style="color: #555555;">.</span>reset()
        Regex<span style="color: #555555;">.</span>reset(<span style="color: #336666;">self</span>)

<span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Alternative</span>(Binary):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, left, right):
        empty <span style="color: #555555;">=</span> left<span style="color: #555555;">.</span>empty <span style="color: #000000; font-weight: bold;">or</span> right<span style="color: #555555;">.</span>empty
        Binary<span style="color: #555555;">.</span>__init__(<span style="color: #336666;">self</span>, left, right, empty)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">_shift</span>(<span style="color: #336666;">self</span>, c, mark):
        marked_left  <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>left<span style="color: #555555;">.</span>shift(c, mark)
        marked_right <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>right<span style="color: #555555;">.</span>shift(c, mark)
        <span style="color: #006699; font-weight: bold;">return</span> marked_left <span style="color: #000000; font-weight: bold;">or</span> marked_right
</pre></div>
<p>An <tt class="docutils literal">Alternative</tt> can match the empty string, if either of its children can.
Similarly, shifting a mark into an <tt class="docutils literal">Alternative</tt> shifts it into both its
children. If either of the children are marked afterwards, the <tt class="docutils literal">Alternative</tt>
is marked too.</p>
<p>As an example, consider the regular expression <tt class="docutils literal">a|b|c</tt>, which would be
represented by the objects <tt class="docutils literal"><span class="pre">Alternative(Alternative(Char('a'),</span> <span class="pre">Char('b')),</span> <span class="pre">Char('c'))</span></tt>.
Matching the string <tt class="docutils literal">"a"</tt> would lead to the following marks in
the regular expression objects (green nodes are marked, white ones are
unmarked):</p>

<img alt="alternativea.gif" src="https://2.bp.blogspot.com/_zICyAWqZbLA/S_Z-iZKY-8I/AAAAAAAAAKY/ShzkzFqaQgo/s1600/alternativea.gif"><p>At the start of the process, no node is marked. Then the first char is matched,
which adds a mark to the <tt class="docutils literal"><span class="pre">Char('a')</span></tt> node, and the mark will propagate up the
two <tt class="docutils literal">Alternative</tt> nodes.</p>
</div>
<div class="section" id="repetition">
<h3>Repetition</h3>
<p>The two remaining classes are slightly trickier. <tt class="docutils literal">Repetition</tt> is used to match
a regular expression any number of times (usual regular expressions syntax
<tt class="docutils literal">a*</tt>):</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Repetition</span>(Regex):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, re):
        Regex<span style="color: #555555;">.</span>__init__(<span style="color: #336666;">self</span>, <span style="color: #336666;">True</span>)
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>re <span style="color: #555555;">=</span> re

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">_shift</span>(<span style="color: #336666;">self</span>, c, mark):
        <span style="color: #006699; font-weight: bold;">return</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>re<span style="color: #555555;">.</span>shift(c, mark <span style="color: #000000; font-weight: bold;">or</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>marked)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">reset</span>(<span style="color: #336666;">self</span>):
        <span style="color: #336666;">self</span><span style="color: #555555;">.</span>re<span style="color: #555555;">.</span>reset()
        Regex<span style="color: #555555;">.</span>reset(<span style="color: #336666;">self</span>)
</pre></div>
<p>A <tt class="docutils literal">Repetition</tt> can always match the empty string. The mark is shifted into the
child, but if the <tt class="docutils literal">Repetition</tt> is already marked, this will be shifted into
the child as well, because the <tt class="docutils literal">Repetition</tt> could match a second time.</p>
<p>As an example, consider the regular expression <tt class="docutils literal">(a|b|c)*</tt> matching the string
<tt class="docutils literal">abcbac</tt>:</p>
<img alt="repetition.gif" src="https://4.bp.blogspot.com/_zICyAWqZbLA/S_Z-itgZvbI/AAAAAAAAAKg/vYe5CQxPUOo/s1600/repetition.gif"><p>For every character, one of the alternatives matches, thus the repetition matches
as well.</p>
</div>
<div class="section" id="sequence">
<h3>Sequence</h3>
<p>The only missing class is that for sequences of expressions, <tt class="docutils literal">Sequence</tt> (usual
regular expressions syntax <tt class="docutils literal">ab</tt>):</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">Sequence</span>(Binary):
    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">__init__</span>(<span style="color: #336666;">self</span>, left, right):
        empty <span style="color: #555555;">=</span> left<span style="color: #555555;">.</span>empty <span style="color: #000000; font-weight: bold;">and</span> right<span style="color: #555555;">.</span>empty
        Binary<span style="color: #555555;">.</span>__init__(<span style="color: #336666;">self</span>, left, right, empty)

    <span style="color: #006699; font-weight: bold;">def</span> <span style="color: #CC00FF;">_shift</span>(<span style="color: #336666;">self</span>, c, mark):
        old_marked_left <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>left<span style="color: #555555;">.</span>marked
        marked_left <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>left<span style="color: #555555;">.</span>shift(c, mark)
        marked_right <span style="color: #555555;">=</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>right<span style="color: #555555;">.</span>shift(
            c, old_marked_left <span style="color: #000000; font-weight: bold;">or</span> (mark <span style="color: #000000; font-weight: bold;">and</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>left<span style="color: #555555;">.</span>empty))
        <span style="color: #006699; font-weight: bold;">return</span> (marked_left <span style="color: #000000; font-weight: bold;">and</span> <span style="color: #336666;">self</span><span style="color: #555555;">.</span>right<span style="color: #555555;">.</span>empty) <span style="color: #000000; font-weight: bold;">or</span> marked_right
</pre></div>
<p>A <tt class="docutils literal">Sequence</tt> can be empty only if both its children are empty. The mark
handling is a bit delicate. If a mark is shifted in, it will be shifted to the
left child regular expression. If that left child is already marked <em>before the
shift</em>, that mark is shifted to the right child. If the left child can match the
empty string, the right child gets the mark shifted in as well.</p>
<p>The whole sequence matches (i.e. is marked), if the left child is marked after
the shift and if the right child can match the empty string, or if the right
child is marked.</p>
<p>Consider the regular expression <tt class="docutils literal">abc</tt> matching the string <tt class="docutils literal">abcd</tt>. For the
first three characters, the marks wander from left to right, when the <tt class="docutils literal">d</tt> is
reached, the matching fails.</p>
<img alt="sequence.gif" src="https://1.bp.blogspot.com/_zICyAWqZbLA/S_Z-iyBRDCI/AAAAAAAAAKo/Kam1Jvk_02s/s1600/sequence.gif">
</div>
<div class="section" id="more-complex-example">
<h3>More Complex Example</h3>
<p>As a more complex example, consider the expression <tt class="docutils literal"><span class="pre">((abc)*|(abcd))(d|e)</span></tt>
matching the string <tt class="docutils literal">abcabcabcd</tt>.</p>
<img alt="complex.gif" src="https://3.bp.blogspot.com/_zICyAWqZbLA/S_Z-iy43N0I/AAAAAAAAAKw/BbRQTkidcJM/s1600/complex.gif"><p>Note how the two branches of the first alternative match the first <tt class="docutils literal">abc</tt> in
parallel, until it becomes clear that only the left alternative <tt class="docutils literal">(abc)*</tt> can
work.</p>
</div>
<div class="section" id="complexity">
<h3>Complexity</h3>
<p>The <tt class="docutils literal">match</tt> function above loops over the entire string without going back and
forth. Each iteration goes over the whole tree every time. Thus the complexity
of the algorithm is <tt class="docutils literal">O(m*n)</tt> where <tt class="docutils literal">m</tt> is the size of the regular expression
and <tt class="docutils literal">n</tt> is the length of the string.</p>
</div>
</div>
<div class="section" id="summary-outlook">
<h2>Summary &amp; Outlook</h2>
<p>So, what have we achieved now? The code shown here can match regular expressions
with the desired complexity. It is also not much code. By itself, the Python
code shown above is not terribly efficient. In the next post I will show how the
JIT generator can be used to make the simple matcher shown above really fast.</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-8883343992294452019">
        <div class="comment-header">
          <a name="comment-8883343992294452019"></a>
            <span class="author">Marius Gedminas</span> wrote on <span class="date">2010-05-21 16:41</span>:
        </div>
        <div class="comment-content">
          <p>Have you seen Russ Cox's <a href="https://swtch.com/~rsc/regexp/" rel="nofollow">series of articles</a> about regular expressions?<br><br><a href="https://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html" rel="nofollow">Google Chrome's regexp library</a> is also interesting.<br><br>Google appears to have put a lot of research in efficient regexp algorithms while paying attention to backwards-compatibility concerns, as existing applications often rely on backtracking.</p>
        </div>
      </div>
      <div class="comment comment-8607436175890535732">
        <div class="comment-header">
          <a name="comment-8607436175890535732"></a>
            <span class="author">kay schluehr</span> wrote on <span class="date">2010-05-21 20:26</span>:
        </div>
        <div class="comment-content">
          <i>Most importantly, that means that back-references are not allowed.</i><br><br><a href="https://fiber-space.de/wordpress/?p=1441" rel="nofollow">Limited backreferences</a> can be integrated within this pattern matching scheme. General backreferences are only possible with backtracking but unless you want to solve NP complete problems using POSIX style regexps they might not be necessary.
        </div>
      </div>
      <div class="comment comment-512257614429575287">
        <div class="comment-header">
          <a name="comment-512257614429575287"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-05-21 21:48</span>:
        </div>
        <div class="comment-content">
          <p>Marius: The Russ Cox site is linked from the article :-).<br><br>Kay: Thanks for the link, will check it out.</p>
        </div>
      </div>
      <div class="comment comment-9167802587183477558">
        <div class="comment-header">
          <a name="comment-9167802587183477558"></a>
            <span class="author">Thomas</span> wrote on <span class="date">2010-05-21 22:07</span>:
        </div>
        <div class="comment-content">
          <p>I do not use regular expressions very heavily and am very new to pypy in general (1.2 works pretty good for me on my pure python code).  From this article I don't see a full explaination why this basic algorithm couldn't be used for pypy.  Is it primarily due to concerns about backward compatiblity or something more interesting?  I am looking forward to the article to come about applying the JIT.</p>
        </div>
      </div>
      <div class="comment comment-717066989714752693">
        <div class="comment-header">
          <a name="comment-717066989714752693"></a>
            <span class="author">Benjamin Peterson</span> wrote on <span class="date">2010-05-22 20:58</span>:
        </div>
        <div class="comment-content">
          <p>@Thomas Python's re library requires backtracking.</p>
        </div>
      </div>
      <div class="comment comment-9119922668849821891">
        <div class="comment-header">
          <a name="comment-9119922668849821891"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-05-23 00:24</span>:
        </div>
        <div class="comment-content">
          <p>This is just beautiful, I hope some version of this will be available for PyPy users: sandboxing + non-pathological REs sounds like a nice combo.</p>
        </div>
      </div>
      <div class="comment comment-9076179592515644706">
        <div class="comment-header">
          <a name="comment-9076179592515644706"></a>
            <span class="author">Damian Cugley</span> wrote on <span class="date">2010-05-24 16:22</span>:
        </div>
        <div class="comment-content">
          <p>Though these regexes can't be used as a drop-in replacement for the re module, if there were strikingly faster it might be worth having them as an alternative. The backtracking features are so seldom required that a faster, non-backtracking algorithm might prove popular with people who worry about matching speed.</p>
        </div>
      </div>
      <div class="comment comment-3693825132003837399">
        <div class="comment-header">
          <a name="comment-3693825132003837399"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-05-25 12:53</span>:
        </div>
        <div class="comment-content">
          <p>It would be fun to read an article where you take the real Python regexes and apply PyPy's JIT code generation to them, i.e. when you call re.compile(...), you'd get native code out of it, specialized for the regex being compiled. After all, haven't you used the JIT on "toy" languages before? Regexes are a "toy" language, albeit a useful one..</p>
        </div>
      </div>
      <div class="comment comment-1868100412814771630">
        <div class="comment-header">
          <a name="comment-1868100412814771630"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-05-25 14:21</span>:
        </div>
        <div class="comment-content">
          <p>Anonymous2: Yes, but PyPy's current implementation of the re module is a bit of a mess, and not really fast. It's rather unclear how easy/possible it would be to generate a good JIT for it.</p>
        </div>
      </div>
      <div class="comment comment-6172653337906375267">
        <div class="comment-header">
          <a name="comment-6172653337906375267"></a>
            <span class="author">Unhelpful</span> wrote on <span class="date">2010-06-04 21:17</span>:
        </div>
        <div class="comment-content">
          <p>Instead of a "special" interpreter for REs in RPython, and a JIT for it, what about "compiling" REs to Python bytecode, and letting the existing PyPy JIT trace and compile them if they end up being used often enough? This is probably slower in the case of lots of throwaway REs that are used once, but when a few REs are used repeatedly it ought to work.</p>
        </div>
      </div>
      <div class="comment comment-5088051433078506939">
        <div class="comment-header">
          <a name="comment-5088051433078506939"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2017-11-21 15:28</span>:
        </div>
        <div class="comment-content">
          <p>"As an example, consider the regular expression a|b|c, which would be represented by the objects Alternative(Alternative(Char('a'), Char('b')), Char('c'))"<br><br>But how to create such a representation, when you scan input regex literal by literal?</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/05/running-wxpython-on-top-of-pypy-52246787415886751.html" class="u-url">Running wxPython on top of pypy</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/05/running-wxpython-on-top-of-pypy-52246787415886751.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-05-03T15:28:00Z" itemprop="datePublished" title="2010-05-03 15:28">2010-05-03 15:28</time></a>
            </p>
                <p class="commentline">10 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Hello,</p>
<p>These last three weeks we have been busy working on the cpyext subsystem, which
allows pypy to execute extension modules written with the <a class="reference external" href="https://docs.python.org/c-api">Python C API</a>.</p>
<p>Today we hacked enough to have wxPython compile, and run its wonderful demo.
This:
<a href="https://imagebin.ca/img/hHtQJ9.png"><img alt="" border="0" src="https://imagebin.ca/img/hHtQJ9.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 970px; height: 720px;"></a>
cannot be distinguished from the same run with a
standard python interpreter, but this:
<a href="https://imagebin.ca/img/3nPX_sV.png"><img alt="" border="0" src="https://imagebin.ca/img/3nPX_sV.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 970px; height: 720px;"></a>
shows an exception that
CPython never produces.</p>
<p>wxPython is a big extension module: it has more than 500 classes and 7500
functions, most of the code is automatically generated by swig.  It uses
advanced techniques, like "Original Object Return" and cross-platform
polymorphism, that effectively allows the developer to seamlessly subclass C++
objects in Python and write GUI applications efficiently.</p>
<p>The demo application runs reasonably fast, it feels slower than with CPython,
but I did not activate the JIT option of pypy.  It still crashes in some places
(the demo is very comprehensive and covers all the aspects of wxPython), and
threads are expected to not work at the moment.</p>
<p>We had to modify a little the code of wxPython, mainly because it often stores
borrowed references into C++ objects.  This does not work well in pypy, where
all other counted references can disappear, and allows the address of the object
to change.  The solution is to use weak references instead.  The patch is <a class="reference external" href="https://codespeak.net/svn/user/afa/wxpython-for-pypy.diff">here</a>,
it will eventually be merged into the upstream wxPython version.</p>
<p>This first real test proves that CPython extensions can be migrated to pypy
without much pain.  It also points some places which can be improved, like
better diagnostics in crashes, better support of distutils...</p>
<p>Amaury Forgeot d'Arc</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-823463705967862446">
        <div class="comment-header">
          <a name="comment-823463705967862446"></a>
            <span class="author">RenÃ© Dudfield</span> wrote on <span class="date">2010-05-03 17:09</span>:
        </div>
        <div class="comment-content">
          <p>sweet as!</p>
        </div>
      </div>
      <div class="comment comment-3622627792300049299">
        <div class="comment-header">
          <a name="comment-3622627792300049299"></a>
            <span class="author">Dan Villiom Podlaski Christiansen</span> wrote on <span class="date">2010-05-03 18:00</span>:
        </div>
        <div class="comment-content">
          <p>Nice! Do you have any plans for making Mac nightlies with this available? I'd love to try out PyPy, but the one time I tried bootstrapping, it used all available memory. After I had let it run overnight but it didn't finish, I killed itâ€¦</p>
        </div>
      </div>
      <div class="comment comment-4130533077498478632">
        <div class="comment-header">
          <a name="comment-4130533077498478632"></a>
            <span class="author">Bourne</span> wrote on <span class="date">2010-05-03 19:59</span>:
        </div>
        <div class="comment-content">
          <p>This is very good news.<br><br>Finishing wxPython and the JIT is probably all that's needed to make PyPy a **great** alternative to CPython. (but I guess you figured that already)<br><br>Thanks!</p>
        </div>
      </div>
      <div class="comment comment-8914911271481054512">
        <div class="comment-header">
          <a name="comment-8914911271481054512"></a>
            <span class="author">Stu</span> wrote on <span class="date">2010-05-03 23:52</span>:
        </div>
        <div class="comment-content">
          <p>Sweet !  I wonder if pycairo and pygtk... at the moment I don't know if it's cairo or python slowing down my app (I have an idea it's both, but running it in pypy does seem attractive).</p>
        </div>
      </div>
      <div class="comment comment-663706552143042787">
        <div class="comment-header">
          <a name="comment-663706552143042787"></a>
            <span class="author">RenÃ© Dudfield</span> wrote on <span class="date">2010-05-04 09:33</span>:
        </div>
        <div class="comment-content">
          <p>Are there docs for how to compile extensions somewhere?  I had a quick look, but couldn't find them.</p>
        </div>
      </div>
      <div class="comment comment-7693453635911543339">
        <div class="comment-header">
          <a name="comment-7693453635911543339"></a>
            <span class="author">The Cannon Family</span> wrote on <span class="date">2010-05-04 19:28</span>:
        </div>
        <div class="comment-content">
          <p>this is a major accomplishment in terms of usability, many people use Python extension modules, way to go. (and next steps, PIL).</p>
        </div>
      </div>
      <div class="comment comment-5936091775528455256">
        <div class="comment-header">
          <a name="comment-5936091775528455256"></a>
            <span class="author">Amaury Forgeot d'Arc</span> wrote on <span class="date">2010-05-04 22:38</span>:
        </div>
        <div class="comment-content">
          <p>PIL also works with PyPy. I've only tried basic tests though (like gif-&gt;png conversion)</p>
        </div>
      </div>
      <div class="comment comment-3025050570910924885">
        <div class="comment-header">
          <a name="comment-3025050570910924885"></a>
            <span class="author">Amaury Forgeot d'Arc</span> wrote on <span class="date">2010-05-04 22:40</span>:
        </div>
        <div class="comment-content">
          <p>@illume: you have to compile pypy with the option "--withmod-cpyext", then it should be enough to run "/path/to/pypy-c setup.py build"</p>
        </div>
      </div>
      <div class="comment comment-6144260342608610872">
        <div class="comment-header">
          <a name="comment-6144260342608610872"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2010-05-07 13:44</span>:
        </div>
        <div class="comment-content">
          <p>Well done! The Italian Python Community has an article on this (<a href="https://www.python-it.org/10/05/06/pypy-supporta-quasi-wxpython" rel="nofollow">here, in Italian</a>)</p>
        </div>
      </div>
      <div class="comment comment-7800079294213102805">
        <div class="comment-header">
          <a name="comment-7800079294213102805"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-05-09 09:49</span>:
        </div>
        <div class="comment-content">
          <p>Wow. PyPy is coming along quite nicely :-)</p>
        </div>
      </div>
         </div>

</div>
</div>
<div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
      <li>
        <a href="/posts/2024/10/jit-peephole-dsl.html" class="listtitle">A DSL for Peephole Transformation Rules of Integer Operations in the PyPy JIT</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (8)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (5)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div></div>
</main>
</div>
<div style="clear: both; width: 75%; margin: 1em auto;">
        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-15.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-13.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
         
                 <footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    Â© 2025 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
    Â 
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
    Â 
    Last built 2025-07-07T11:01
  </div>
  <div style="margin-left: auto">
  <a href="../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../assets/js/styles.js"></script></footer>
</body>
</html>