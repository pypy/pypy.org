<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="A Faster Python">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>PyPy (old posts, page 17) | PyPy</title>
<link href="../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../rss.xml">
<link rel="canonical" href="https://www.pypy.org/blog/index-17.html">
<link rel="icon" href="../favicon2.ico" sizes="16x16">
<link rel="icon" href="../favicon32x32.ico" sizes="32x32">
<link rel="prev" href="index-18.html" type="text/html">
<link rel="next" href="index-16.html" type="text/html">
<!--[if lt IE 9]><script src="../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../assets/css/tipuesearch.css">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../index.html">
                    <image id="toplogo" src="../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../compat.html">Compatibility</a> </li>  
                    <li> <a href="../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href=".">Index</a> </li>  
                    <li> <a href="../categories/">Tags</a> </li>  
                    <li> <a href="../archive.html">Archive by year</a> </li>  
                    <li> <a href="../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Search…" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><div class="post">
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/03/us-trip-report-popl-microsoft-ibm-3874568000250679204.html" class="u-url">US Trip Report: POPL, Microsoft, IBM</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/03/us-trip-report-popl-microsoft-ibm-3874568000250679204.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-03-02T22:22:00Z" itemprop="datePublished" title="2011-03-02 22:22">2011-03-02 22:22</time></a>
            </p>
                <p class="commentline">6 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Some notes from my recent trip (from 23rd of January to 17th of February) to the
US where, I presented PyPy at various scientifically oriented places. In
summary, there seems to be quite a bit of interest in PyPy within the research
community, details below.</p>
<div class="section" id="pepm-popl-stop">
<h2>PEPM/POPL/STOP</h2>
<p>From the 24th to the 29th of January I was in Austin, Texas at the <a class="reference external" href="https://www.cse.psu.edu/popl/11/">POPL
conference</a>, where I gave a talk at one of the workshops, <a class="reference external" href="https://www.program-transformation.org/PEPM11">PEPM</a> (Partial
Evaluation and Program Manipulation). The title of our <a class="reference external" href="https://codespeak.net/svn/pypy/extradoc/talk/pepm2011/bolz-allocation-removal.pdf">paper</a> is
"Allocation Removal by Partial Evaluation in a Tracing JIT", the abstract is:</p>
<blockquote>
The performance of many dynamic language implementations suffers from high
allocation rates and runtime type checks. This makes dynamic languages less
applicable to purely algorithmic problems, despite their growing
popularity. In this paper we present a simple compiler optimization based
on online partial evaluation to remove object allocations and runtime type
checks in the context of a tracing JIT. We evaluate the optimization using
a Python VM and find that it gives good results for all our (real-life)
benchmarks.</blockquote>
<p>The talk (<a class="reference external" href="https://codespeak.net/svn/pypy/extradoc/talk/pepm2011/presentation/bolz-allocation-removal-talk.pdf">slides</a>) seemed to be well-received and there was
a good discussion afterwards. PEPM in general was a very enjoyable workshop
with many interesting talks on partial evaluation (which I am very interested
in) and a great keynote by Olivier Danvy about "A Walk in the Semantic Park".</p>
<p><strong>POPL</strong> itself was a bit outside of the area I am most knowledgeable in, most of
the talks being on formal topics. Some of the talks that stuck to my mind:</p>
<ul class="simple">
<li>
<em>"The Design of Kodu: A Tiny Visual Programming Language for Children on the
Xbox 360"</em>, the keynote by Matthew MacLaurin from Microsoft Research. I didn't
know about <a class="reference external" href="https://fuse.microsoft.com/project/kodu.aspx">Kodu</a> before, and was very impressed by it.</li>
</ul>
<ul class="simple">
<li>
<em>"Automating String Processing in Spreadsheets using Input-Output Examples"</em>
(<a class="reference external" href="https://research.microsoft.com/en-us/um/people/sumitg/pubs/popl10-synthesis.pdf">paper</a>) by Sumit Gulwani (also from MS Research) describes a plugin to Excel
that can automate many common string processing tasks by giving a couple of
examples, which are then abstracted into a generic string manipulation. Very
cool.</li>
</ul>
<ul class="simple">
<li>
<em>"Dynamic Inference of Static Types for Ruby"</em> (<a class="reference external" href="https://www.cs.umd.edu/~jfoster/papers/popl11.pdf">paper</a>) by   Michael Furr,
Jong-hoon (David) An, Jeffrey S. Foster and Michael Hicks describes an
approach to type inference that works by observing the actual types seen
during unit-testing. Similar things have been done a few times before,
however, the paper actually gives a correctness result.</li>
</ul>
<ul class="simple">
<li>
<em>"The Essence of Compiling with Traces"</em> (<a class="reference external" href="https://rfrn.org/~shu/papers/popl11-full.pdf">paper</a>) by Shu-Yu Guo and Jens
Palsberg describes a formalization of a simple imperative language and
proves that executing it using trace compilation will do exactly the same
thing than using an interpreter. It also looks at what conditions an
optimization on traces must fulfill to still produce valid results.</li>
</ul>
<p>After the main conference, I took part in the <a class="reference external" href="https://wrigstad.com/stop11/">STOP</a> (Scripts to Programs)
workshop. It had a great keynote <em>"Scripting in a Concurrent World"</em> by John Field
about the <a class="reference external" href="https://www.thorn-lang.org/">Thorn language</a> and a few interesting other talks.</p>
</div>
<div class="section" id="microsoft-research">
<h2>Microsoft Research</h2>
<p>After POPL I went to Redmond to visit Microsoft Research for a week,
specifically the <a class="reference external" href="https://research.microsoft.com/en-us/groups/rise/">RiSE group</a>. This is the group that did the <a class="reference external" href="https://research.microsoft.com/en-us/projects/spur/">SPUR project</a>,
a meta-tracing JIT for C# applied to a JavaScript interpreter in C#. I <a class="reference external" href="../posts/2010/07/comparing-spur-to-pypy-8835011873209414462.html">compared
PyPy to SPUR</a> last year. I am very grateful for Microsoft for inviting me
there.</p>
<p>At Microsoft I gave a talk about "PyPy's Approach to Implementing Dynamic
Languages Using a Tracing JIT Compiler", the slides of which can be found
<a class="reference external" href="https://codespeak.net/svn/pypy/extradoc/talk/microsoft-jan-2011/talk.pdf">here</a>. The talk was <a class="reference external" href="https://research.microsoft.com/apps/video/dl.aspx?id=144687">filmed and is online</a>. People seemed to be impressed
with the "product qualities" of PyPy, e.g. the buildbot infrastructure and
speed tracking website.</p>
<p>The rest of the time I discussed with various researchers in the RiSE group,
particularly with <a class="reference external" href="https://research.microsoft.com/en-us/people/nikolait/">Nikolai Tillmann</a>. We talked a lot about similarities and
differences between SPUR and PyPy and tried to understand our respective projects
better. SPUR is a really great project and I learned a lot in the discussions,
for example about the optimizations and heuristics their trace compiler uses.</p>
<p>Another very cool project done by the RiSE group that I learned more about is
<a class="reference external" href="https://research.microsoft.com/en-us/projects/pex/">PEX</a>. PEX is a unit test generator for C# that tries to produce unit tests for
so-far untested execution paths within methods. There is an <a class="reference external" href="https://www.pexforfun.com/">online puzzle
version</a> of it, if you want to get an impression of the technology (including a
very impressive C# IDE in the browser).</p>
</div>
<div class="section" id="ibm">
<h2>IBM</h2>
<p>For the last part of the trip I stayed in New York City for two weeks,
mostly as a vacation. However, I also visited IBM <a class="reference external" href="https://www.watson.ibm.com/index.shtml">Watson Research Center</a> for
two days, to which I had been invited by <a class="reference external" href="https://researcher.ibm.com/researcher/view.php?person=us-edelsohn">David Edelsohn</a>.</p>
<p>The first day I gave the same presentation I had given at Microsoft (with some
improvements to the <a class="reference external" href="https://codespeak.net/svn/pypy/extradoc/talk/ibm-feb-2011/talk.pdf">slides</a>), again it was quite well received. The rest of
the time I spent in (very fruitful) discussions with various people and teams,
among them the <a class="reference external" href="https://researcher.ibm.com/researcher/view_project.php?id=122">Liquid Metal</a> team and the <a class="reference external" href="https://www.thorn-lang.org/">Thorn</a> team.</p>
<p>The second day I met with members of the FIORANO group, who are working on
dynamic compilation for dynamic languages and Java. They explored various ways
to speed up Python, both by improving the CPython interpreter as well as with
JIT compilation techniques.</p>
<p>Another of their projects is to add a trace compiler to IBM's J9 JVM, about
which the <a class="reference external" href="https://researcher.ibm.com/researcher/files/us-pengwu/CGO2011_TraceJIT.pdf">paper</a> "A Trace-based Java JIT Compiler Retrofitted from a
Method-based Compiler" is going to appear at <a class="reference external" href="https://www.cgo.org/cgo2011/">CGO</a>. I discussed tracing JITs with
<a class="reference external" href="https://researcher.ibm.com/researcher/view.php?person=us-pengwu">Peng Wu</a>, one of the authors of that paper. Peng tries to systematically look at
the various heuristics found in the different VMs that use tracing JITs. This
is a very different perspective from the one I usually have, focusing on how to
improve PyPy's specific heuristics. Therefore that discussion helped me thinking
about the issues more generally.</p>
<p>Another goal of the group is to try to find benchmarks that are representative
for typical Python workloads, which is something that has been done very
carefully for Java e.g. when developing the <a class="reference external" href="https://dacapobench.org/">DaCapo</a> benchmark suite. The
benchmarks that the Python community uses have not been selected in such a
careful and measured way, so I think that trying to be more systematic there is
a very worthwhile endeavour.</p>
</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-2409975452420259880">
        <div class="comment-header">
          <a name="comment-2409975452420259880"></a>
            <span class="author">holger krekel</span> wrote on <span class="date">2011-03-05 14:04</span>:
        </div>
        <div class="comment-content">
          <p>Thanks for the interesting overview of your travels and research interactions!  I i agree that getting better and more systematic benchmarks for Python would be worthwhile.</p>
        </div>
      </div>
      <div class="comment comment-3939036363012356815">
        <div class="comment-header">
          <a name="comment-3939036363012356815"></a>
            <span class="author">Ivan</span> wrote on <span class="date">2011-03-07 20:36</span>:
        </div>
        <div class="comment-content">
          <p>I find this project fascinating.<br><br>I wonder what's the theoretical limit of this approach for improving the performance of python (or any other language implemented in pypy)?<br><br>Do you have any rought estimation on how far you can go? Have you reached a limit or you are just scratching the possibilities?<br><br>For example, do you think you can compete with javascript v8 or luajit?</p>
        </div>
      </div>
      <div class="comment comment-1872699736616450079">
        <div class="comment-header">
          <a name="comment-1872699736616450079"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-03-08 13:59</span>:
        </div>
        <div class="comment-content">
          <p>Hi Ivan.<br><br>In general I don't think there are limits of approach other than say time and money. Python is a complex language.<br><br>Can you come up with an example where PyPy is actually slower than V8 *other* than computer language shootout? Programs on computer language shootout are just not nicely optimized for PyPy.</p>
        </div>
      </div>
      <div class="comment comment-5129269746278596819">
        <div class="comment-header">
          <a name="comment-5129269746278596819"></a>
            <span class="author">Ivan</span> wrote on <span class="date">2011-03-08 16:10</span>:
        </div>
        <div class="comment-content">
          <p>Hi Fijall,<br><br>I'm afraid I don't know about benchmarks and comparison between these languages, other than the shootout. I guess this is the first reference someone gets when comparing languages, since it's the most popular out there.<br><br>But it would be great if there was a resource to compare against other languages. At least, from a marketing point of view, it would be very good for pypy.<br><br>May I know why the shootout is not a good parameter?<br><br>And, is there any other benchmarks comparing pypy against v8, tracemonkey/jägermonkey, etc..?</p>
        </div>
      </div>
      <div class="comment comment-3289244862590868248">
        <div class="comment-header">
          <a name="comment-3289244862590868248"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-03-08 16:21</span>:
        </div>
        <div class="comment-content">
          <p>Hi Ivan.<br><br>Shootout is not good because it contains heavily tuned programs, some of them even massively stretching the benchmark restrictions. They're tailored towards specific implementations, contain specific per-benchmark options etc. Nobody looked at python programs at detail and especially from PyPy perspective. This would need to be done first to compare those fairly, until it's not done, it's comparing naive version to a heavily optimized one and not comparing languages.<br><br>From what I measured roughly PyPy comes on par with tracemonkey and about 2x slower V8. But those were very unscientific experiments and I'll deny everything :)<br><br>I don't think there is any good cross-language comparison and that's at least partly due to the fact that workloads differ in different languages. Most shootout programs for example are tailored towards C workloads. Optimizing precisely for them (even if you have a good programs) is kind of fun, but it does not represent what we try to achieve, that is speeding up large python programs.<br><br>I hope this answers your question.<br><br>Cheers,<br>fijal</p>
        </div>
      </div>
      <div class="comment comment-1847222929704012790">
        <div class="comment-header">
          <a name="comment-1847222929704012790"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-03-10 23:15</span>:
        </div>
        <div class="comment-content">
          <p>to me it seems like you have reached the goals of unladen swallow and unladen swallow was a bit of a failure?<br><br>if google wants a faster python, why don't they fund you? it would be awesome if the core team could work on it full-time. :)</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/02/pypy-winter-sprint-report-4155886720346408516.html" class="u-url">PyPy Winter Sprint Report</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/michael-foord.html">Michael Foord</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/02/pypy-winter-sprint-report-4155886720346408516.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-02-14T12:05:00Z" itemprop="datePublished" title="2011-02-14 12:05">2011-02-14 12:05</time></a>
            </p>
                <p class="commentline">7 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>A few weeks ago I had the great fortune to attend the PyPy winter sprint in Leysin Switzerland. I've wanted to contribute to PyPy for a long time and I thought diving into a sprint might be a good way to get familiar with some of the code. What I wasn't expecting was to be using RPython to implement new methods on built-in Python objects on the first day. The main thing I took away from the sprint was just how easy it is to get involved in developing PyPy (well, some bits of it at least and being surrounded by core developers helps). I wrote up a very short description of how to get started <a href="https://bitbucket.org/pypy/pypy/wiki/How%20to%20run%20lib-python%20tests">here</a>, but I'll do a longer blog post with examples on <a href="https://www.voidspace.org.uk/python/weblog/">my own blog</a> soon(ish).<br><br>
The sprint was kicked off by Armin merging the "fast-forward" branch of PyPy onto trunk. "fast-forward" brings PyPy from Python 2.5 compatibility to Python 2.7. Along with this it brought a large number of test failures, as the sterling work done by Benjamin Peterson and Amaury Forgeot d'Arc was not complete. This immediately set the primary sprint goal to reduce the number of test failures.<br><br>
We made a great deal of progress on this front, and you can see how close PyPy is now from the <a href="https://buildbot.pypy.org/summary?branch=%3Ctrunk%3E">buildbots</a>.<br><br>
Jacob Hallén and I started working through the list of tests with failures alphabetically. We made short work of test_asyncore and moved onto test_bytes where I was stuck for the rest of the sprint. I spent much of the remaining days working with Laura Creighton on the pypy bytearray implementation to make it more compatible with Python 2.7. This meant adding new methods, changing some of the Python protocol method implementations and even changing the way that bytearray is constructed. All in all great fun and a great introduction to working with RPython.<br><br>
A big part of the compatibility with Python 2.7 work was done by Laura and Armin who basically rewrote the math module from scratch. This was needed to incorporate all the improvements made (mostly by Mark Dickinson) in CPython in 2.7. That involved a lot of head-scratching about such subtleties as whether -0.0 should be considered almost equal to 0.0 and other fun problems.<br><span id="goog_788025148"></span><span id="goog_788025149"></span><br><br></p>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><span class="Apple-style-span" style="margin-left: auto; margin-right: auto;"><img border="0" height="239" src="https://4.bp.blogspot.com/-mtUgzR-TwUA/TVkXkIjqmXI/AAAAAAAAAVc/bbynq2Dwmg8/s320/first-meal.jpg" width="320"></span></td></tr>
<tr><td class="tr-caption" style="text-align: center;"><a href="https://www.flickr.com/photos/mfoord/sets/72157625889973066/">The first meal together, before everyone had arrived</a></td></tr>
</tbody></table>
If you add on top of this the wonderful people, the beautiful scenery, the Swiss cheese fondues, managing to not kill myself with a days skiing and traditional pypy card games, I can heartily recommend pypy sprints as a close approximation of geek nirvana.<br><br><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><span class="Apple-style-span" style="margin-left: auto; margin-right: auto;"><img border="0" height="239" src="https://4.bp.blogspot.com/-qP95S6g9X9k/TVkYJKNYTQI/AAAAAAAAAVg/Pm3q36yMiLY/s320/mountains.jpg" width="320"></span></td></tr>
<tr><td class="tr-caption" style="text-align: center;"><a href="https://www.flickr.com/photos/mfoord/sets/72157625889973066/">View of the mountains from the sprint</a></td></tr>
</tbody></table>
<br>
Working on 2.7 compatibility wasn't the only work that happened during the sprint. Other activities included:<br><ul>
<li>Antonio Cuni worked on the "jittypes" branch. This is a reimplementation of the core of the PyPy ctypes code to make it jittable. The goal is that for common cases the jit should be able to turn ctypes calls from Python into direct C level calls. This work was not completed but very close and is great for the future of integrating C libraries with PyPy. As ctypes is also available in CPython and IronPython, and hopefully will be available in Jython soon, integrating C code with Python through ctypes is the most "implementation portable" technique.</li>
<li>David Schneider continued his work on the <a href="../posts/2011/01/jit-backend-for-arm-processors-5994810755839586463.html">JIT backend for ARM</a>. PyPy has been cross-compilable to ARM for a long time, but bringing the JIT to ARM will provide a *fast* PyPy for ARM, which includes platforms like Android. Again David didn't complete this work but did complete the float support.</li>
<li>Håkan Ardo was present for two days and continued his crazy-clever work on JIT optimisations, some of which are described in the <a href="../posts/2011/01/loop-invariant-code-motion-1998392217676829154.html">Loop invariant code motion</a> blog entry.</li>
<li>Holger Krekel worked on updating the PyPy test suite to the latest version of py.test and also worked with me on the interminable bytearray changes for part of the sprint.</li>
<li>No one was sure what  Maciej Fijałkowski worked on but he seemed to be quite busy.</li>
</ul>
I think that was most of the work done during the actual sprint. There was also a great deal of healthy discussion about the future of PyPy. Expect lots more interesting and exciting developments over the coming year.<br><br>
</div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-1214465088948987295">
        <div class="comment-header">
          <a name="comment-1214465088948987295"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-14 15:00</span>:
        </div>
        <div class="comment-content">
          <p>"There was also a great deal of healthy discussion about the future of PyPy."<br><br>World domination?</p>
        </div>
      </div>
      <div class="comment comment-2228137560117162628">
        <div class="comment-header">
          <a name="comment-2228137560117162628"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-02-14 16:19</span>:
        </div>
        <div class="comment-content">
          <p>Very nice report, thanks a lot Michael!</p>
        </div>
      </div>
      <div class="comment comment-8506465009652510917">
        <div class="comment-header">
          <a name="comment-8506465009652510917"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-15 01:16</span>:
        </div>
        <div class="comment-content">
          <p>&gt; world domination?<br><br>why yes of course! the ouroboros is their symbol; PyPy is, evidently, backed by the templars</p>
        </div>
      </div>
      <div class="comment comment-2793236740242124852">
        <div class="comment-header">
          <a name="comment-2793236740242124852"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-15 16:21</span>:
        </div>
        <div class="comment-content">
          <p>&gt; world domination?<br><br>Mongol General: Pypy devs! What is best in life? <br>Pypy dev: To crush your enemies, see them driven before you, and to hear the lamentation of their women. <br>Mongol General: That is good! That is good.</p>
        </div>
      </div>
      <div class="comment comment-242385373945517151">
        <div class="comment-header">
          <a name="comment-242385373945517151"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-02-15 16:41</span>:
        </div>
        <div class="comment-content">
          <p>@Anonymous: Let's not get too far off-track. Also, I don't really like being ascribed a rather violent quote by (supposedly) Genghis Khan, so stop that please.</p>
        </div>
      </div>
      <div class="comment comment-8090907768702912189">
        <div class="comment-header">
          <a name="comment-8090907768702912189"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-15 17:44</span>:
        </div>
        <div class="comment-content">
          <p>@Carl, it wasn't Genghis Khan.<br>It was Conan the Barbarian, impersonated by former California governor.<br>Not to be taken too seriously... :-)</p>
        </div>
      </div>
      <div class="comment comment-3428562026411647144">
        <div class="comment-header">
          <a name="comment-3428562026411647144"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-02-15 20:40</span>:
        </div>
        <div class="comment-content">
          <p>@Anonymous: https://www.barbariankeep.com/ctbsecrets.html</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/02/pypy-san-franciso-bay-area-tour-2011-6179180737090334330.html" class="u-url">The PyPy San Franciso Bay Area Tour 2011</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/armin-rigo.html">Armin Rigo</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/02/pypy-san-franciso-bay-area-tour-2011-6179180737090334330.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-02-10T15:10:00Z" itemprop="datePublished" title="2011-02-10 15:10">2011-02-10 15:10</time></a>
            </p>
                <p class="commentline">3 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>PyPy is coming to the San Francisco Bay Area in the beginning of March with
a series of talks and a mini sprint.</p>

<ul>
<li>
<p><i>Wednesday March 2, 4:15 p.m.</i>  Armin Rigo gives
<a href="https://www.stanford.edu/class/ee380/winter-schedule-20102011.html">a
talk at Stanford.</a>  open to the public.</p>

</li>
<li>
<p><i>Thursday March 3, 6:00 p.m.</i>  General talk at Yelp, 706 Mission St 9th Floor,
  San Francisco CA 94103 open to the public.</p>

</li>
<li>
<p><i>Saturday and Sunday March 5 and 6.</i>
  PyPy mini sprint at <a href="https://www.noisebridge.net">noisebridge.</a>
  2169 Mission street between 17th and 18th in San Francisco.  Open to the public.</p>

</li>
<li>
<p><i>Monday March 7th, 11:30 a.m.</i>  Google Tech talk in Mountain View at the
  Googleplex.  Not open to the public (but the video should be available
  later).</p>

</li>
<li>
<p><i>Monday March 7th, 2:30 p.m.</i>  Talk at Mozilla in Mountain View.  Not
  open to the public (but Mozilla developers can videoconference).</p>
</li>
</ul>
<p>From the PyPy project team we will have Armin Rigo, Maciej Fijałkowski
(from 6th March), Laura Creighton and Jacob Hallén and possibly
Christian Tismer attending.</p>

<p>Most of the talks will focus on (some of) the highlights and the
status of pypy:</p>

<ul>
<li>most Python benchmarks run much faster than with CPython or Psyco
</li>
<li>the real-world PyPy compiler toolchain itself (200 KLocs) runs twice as fast
</li>
<li>supports x86 32 and 64bit and is in the process of supporting ARM
</li>
<li>full compatibility with CPython (more than Jython/IronPython)
</li>
<li>full (and JIT-ed) ctypes support to call C libraries from Python
</li>
<li>supports Stackless Python (in-progress)
</li>
<li>new "cpyext" layer which integrates existing CPython C extensions
</li>
<li>an experimental super-fast JIT-compilation of calls to C++ libraries
</li>
</ul>
<p>As is usual for us, there is vastly more material that is available for
us to cover than time, especially when it comes to possible future
directions for PyPy.  We want to reserve a certain amount of time at
each talk purely to discuss things that are of interest to audience
members.  However, if you already know what you wish we would discuss,
and are attending a talk (or even if you aren't), please let us know.
You can either reply to this blog post, or mail Laura directly at
lac at openend.se .</p>

<p>Apart from getting more technical and project insight, our travel is
also a good possibility for companies in the SF area to talk to us
regarding contracting.  In September 2011 our current "Eurostars" research
project ends and some of us are looking for ways to continue working on
PyPy through consulting, subcontracting or hiring.  The two companies,
Open End and merlinux, have successfully done a number of such contracts
and projects in the past.  If you want to talk business or get together for
lunch or dinner, let us know! If you would like us to come to your company
and make a presentation, let us know!  If you have any ideas about what
we should discuss in a presentation so that you could use it to convince
the powers-that-be at your place of employment that investing time and
money in PyPy would be a good idea, let us know!</p>

<p>On Tuesday March 8th we will be heading for Atlanta for the Python VM
and Language Summits before attending PyCon.  Maciej Fijałkowski and
Alex Gaynor will be giving a talk entitled
<a href="https://us.pycon.org/2011/schedule/presentations/160/">Why is
Python slow and how can PyPy help?</a>
Maciej will also be giving the talk
<a href="https://us.pycon.org/2011/schedule/presentations/159/">Running
ultra large telescopes in Python</a> which is
partially about his experiences using PyPy in the  Square Kilometer Array
project in South Africa.  There will be a PyPy Sprint March 14-17.
All are welcome.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-1612084590716366444">
        <div class="comment-header">
          <a name="comment-1612084590716366444"></a>
            <span class="author">Dan</span> wrote on <span class="date">2011-02-13 01:42</span>:
        </div>
        <div class="comment-content">
          <p>I wanted to let everyone know, there is a PSF sponsored code sprint in Portland, Oregon on February 26th starting at 9am. If you're going to be in the area, it promises to be a great time. We've got a great plan for the day which can be see in this <a href="https://docs1.google.com/document/d/1UoBXWHt1K9g7D9OIwpkceCk9sOI6evu_LGvtt0KbTXQ/edit?hl=en&amp;authkey=CL6untoL#" rel="nofollow">google doc</a>. I hope to see some of you there!<br><br>--Dan</p>
        </div>
      </div>
      <div class="comment comment-4604934381919223227">
        <div class="comment-header">
          <a name="comment-4604934381919223227"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-16 00:51</span>:
        </div>
        <div class="comment-content">
          <p>We'll be giving a talk at Dropbox in San Francisco at 16:00 on Friday March 4th.</p>
        </div>
      </div>
      <div class="comment comment-4416506030938309762">
        <div class="comment-header">
          <a name="comment-4416506030938309762"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-22 05:52</span>:
        </div>
        <div class="comment-content">
          <p>And we'll be dropping by the Google building in San Francisco at 10.45 a.m.<br>on Tuesday March 1st to chat with<br>Googlers there and give an informal <br>talk.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/02/pypy-faster-than-c-on-carefully-crafted-5614784244310486765.html" class="u-url">PyPy faster than C on a carefully crafted example</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/02/pypy-faster-than-c-on-carefully-crafted-5614784244310486765.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-02-04T11:30:00Z" itemprop="datePublished" title="2011-02-04 11:30">2011-02-04 11:30</time></a>
            </p>
                <p class="commentline">30 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Good day everyone.</p>
<p>Recent round of optimizations, especially <a class="reference external" href="../posts/2011/01/loop-invariant-code-motion-1998392217676829154.html">loop invariant code motion</a>
has been very good for small to medium examples. There is work ongoing to
make them scale to larger ones, however there are few examples worth showing
how well they perform. This one following example, besides getting benefits
from loop invariants, also shows a difference between static and dynamic
compilation. In fact, after applying all the optimizations C does, only a
JIT can use the extra bit of runtime information to run even faster.</p>
<p>The example is as follows. First Python. I create two files, x.py:</p>
<pre class="literal-block">
def add(a, b):
  return a + b
</pre>
<p>And y.py:</p>
<pre class="literal-block">
from x import add

def main():
    i = 0
    a = 0.0
    while i &lt; 1000000000:
        a += 1.0
        add(a, a)
        i += 1

main()
</pre>
<p>For C, x.c:</p>
<pre class="literal-block">
double add(double a, double b)
{
  return a + b;
}
</pre>
<p>and y.c:</p>
<pre class="literal-block">
double add(double a, double b);

int main()
{
  int i = 0;
  double a = 0;
  while (i &lt; 1000000000) {
    a += 1.0;
    add(a, a);
    i++;
  }
}
</pre>
<p>Results?</p>
<ul class="simple">
<li><b>1.97s - PyPy</b></li>
<li><b>3.07s - C</b></li>
</ul>
Compilation options:
<ul class="simple">
<li>PyPy trunk (386ed41eae0c), running pypy-c y.py</li>
<li>C - gcc -O3 (GCC 4.4.5 shipped with Ubuntu Maverick)</li>
</ul>
<p>Hence, PyPy 50% faster than C on this carefully crafted example. The reason
is obvious - static compiler can't inline across file boundaries. In C,
you can somehow circumvent that, however, it wouldn't anyway work
with shared libraries. In Python however, even when the whole import system
is completely dynamic, the JIT can dynamically find out what can be inlined.
That example would work equally well for Java and other decent JITs, it's
however good to see we work in the same space :-)</p>
<p>Cheers,<br>
fijal</p>
<p>EDIT: Updated GCC version</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-6547040650574693929">
        <div class="comment-header">
          <a name="comment-6547040650574693929"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-04 11:43</span>:
        </div>
        <div class="comment-content">
          <p>&gt; The reason is obvious - static compiler can't inline across file boundaries.<br><br>That's what link-time optimizations are for, which where added to GCC in 2009; however, your point concerning shared libaries is valid...</p>
        </div>
      </div>
      <div class="comment comment-5013726738997449018">
        <div class="comment-header">
          <a name="comment-5013726738997449018"></a>
            <span class="author">Zeev</span> wrote on <span class="date">2011-02-04 11:55</span>:
        </div>
        <div class="comment-content">
          <p>I added a printf("%f\n",a) to the end of the file so the compiler wouldn't optimize the whole thing away. On my Cure 2 Duo 2.33Ghz, I got for gcc -O3:<br><br>1000000000.000000<br><br>real    0m4.396s<br>user    0m4.386s<br>sys     0m0.007s<br><br>and for gcc -O3 -flto -fwhole-program:<br><br><br>1000000000.000000                                                                                                                                                                                                                            <br><br>real    0m1.312s<br>user    0m1.308s<br>sys     0m0.003s</p>
        </div>
      </div>
      <div class="comment comment-7850956845269895581">
        <div class="comment-header">
          <a name="comment-7850956845269895581"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-04 11:59</span>:
        </div>
        <div class="comment-content">
          <p>Great work!<br><br>Now you just have to identify and remove dead code in your jit. Then you could remove the call to 'add' altogether.</p>
        </div>
      </div>
      <div class="comment comment-6186528421540923397">
        <div class="comment-header">
          <a name="comment-6186528421540923397"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2011-02-04 12:23</span>:
        </div>
        <div class="comment-content">
          <p>In this strange example, in our JIT, the call to 'add' is indeed removed because of inlining, and then the addition that occurs in there is removed because of dead code elimination.</p>
        </div>
      </div>
      <div class="comment comment-3433905986088415657">
        <div class="comment-header">
          <a name="comment-3433905986088415657"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-02-04 12:56</span>:
        </div>
        <div class="comment-content">
          <p>@Zeev yes, but C equivalent of Python import is indeed shared libraries, where -fwhole-program no longer works.</p>
        </div>
      </div>
      <div class="comment comment-4222189793884283924">
        <div class="comment-header">
          <a name="comment-4222189793884283924"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-02-04 13:01</span>:
        </div>
        <div class="comment-content">
          <p>@Armin note that even when the result is accumulated (addition is not removed, although the call is still inlined), PyPy is still faster. Not as much though: 2.5s vs 3.0s</p>
        </div>
      </div>
      <div class="comment comment-4181609366337359509">
        <div class="comment-header">
          <a name="comment-4181609366337359509"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-04 13:23</span>:
        </div>
        <div class="comment-content">
          <p>For completeness's sake, what's the output of `gcc --version` in your example?</p>
        </div>
      </div>
      <div class="comment comment-8729683441027446333">
        <div class="comment-header">
          <a name="comment-8729683441027446333"></a>
            <span class="author">klauss</span> wrote on <span class="date">2011-02-04 14:37</span>:
        </div>
        <div class="comment-content">
          <p>Not to mention specialization: python's (and pypy's) add() can add pretty much anything - strings if you will.<br><br>The JIT will inline a specialized version particular to the call site, whereas C can only apply generalized optimizations.</p>
        </div>
      </div>
      <div class="comment comment-2915353682016960888">
        <div class="comment-header">
          <a name="comment-2915353682016960888"></a>
            <span class="author">Greg Milner</span> wrote on <span class="date">2011-02-05 02:02</span>:
        </div>
        <div class="comment-content">
          <p>Everyone knows Python runs faster than C...<br><br>By about 6 weeks.</p>
        </div>
      </div>
      <div class="comment comment-3906702322431482598">
        <div class="comment-header">
          <a name="comment-3906702322431482598"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-05 13:01</span>:
        </div>
        <div class="comment-content">
          <p>There's another simple case where pypy could (in principle) do very much better than standard C: turn pow(x, i) into sqrt(x*x*x) if i == 3/2, and other reductions.  In practice if you don't know what i is at compiletime you often bundle the simplifications into a function (at the cost of some ifs) but a JIT could do a very nice job on this automagically whenever i is fixed, which it usually is.</p>
        </div>
      </div>
      <div class="comment comment-2660555958255370128">
        <div class="comment-header">
          <a name="comment-2660555958255370128"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-06 14:12</span>:
        </div>
        <div class="comment-content">
          <p>You wrote: "PyPy 50% faster than C on this carefully crafted example".<br><br>The truth is: PyPy is 35% faster than the C code (using C as the baseline), because it completes in 65% of the time required by the C version.<br><br>The C code takes 50% more time to execute (is slower by 50%, 1.5x slower) than the PyPy code (using PyPy as the baseline).</p>
        </div>
      </div>
      <div class="comment comment-2530451800553246683">
        <div class="comment-header">
          <a name="comment-2530451800553246683"></a>
            <span class="author">haypo</span> wrote on <span class="date">2011-02-08 22:58</span>:
        </div>
        <div class="comment-content">
          <p>Test with gcc (Debian 20110126-0ubuntu1) 4.6.0 20110126 (experimental) [trunk revision 169285]: "/usr/lib/gcc-snapshot/bin/gcc [OPTIONS] x.c y.c -o x &amp;&amp; time ./x". OPTIONS=-O0: 10.1s; OPTIONS=-O3: 9.1s; OPTIONS=-O3 -flto: 0.002s. Woops, 0.002 second? I checked: the result is correct :-) LTO rocks!</p>
        </div>
      </div>
      <div class="comment comment-7633989743197771887">
        <div class="comment-header">
          <a name="comment-7633989743197771887"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-02-09 06:43</span>:
        </div>
        <div class="comment-content">
          <p>@haypo print the result so the loop don't get removed as dead code. Besides, the problem is really the fact that's -flto is unfair since python imports more resemble shared libraries than statically-compiled files.</p>
        </div>
      </div>
      <div class="comment comment-2889902815854842835">
        <div class="comment-header">
          <a name="comment-2889902815854842835"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-05-05 06:40</span>:
        </div>
        <div class="comment-content">
          <p>In general, if you want to compare the performance of languages, you're actually supposed to try to write the *fastest* implementation in each language.  Not just some arbitrary one.<br><br>In this example, the program has no output, so both implementations are crap and could be made a lot faster.<br><br>Come up with a program that has testable output, and see if someone can't comment with a C program that's faster than your python.</p>
        </div>
      </div>
      <div class="comment comment-2461218623296910468">
        <div class="comment-header">
          <a name="comment-2461218623296910468"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-12-01 00:09</span>:
        </div>
        <div class="comment-content">
          <p>RIDICULOUS!</p>
        </div>
      </div>
      <div class="comment comment-5703253608854348293">
        <div class="comment-header">
          <a name="comment-5703253608854348293"></a>
            <span class="author">Eric</span> wrote on <span class="date">2012-11-20 15:46</span>:
        </div>
        <div class="comment-content">
          <p>Pypy isn't faster than C, even on this example for multiple reasons:<br><br>First it's conceptual: C is almost as optimized as assembly (it's often referred to as a super assembler) so even if Pypy ends-up generating some assembly code, it has first to evaluate the runtime environment to figure out the type of variables and emit assembly code, and all this process is not free... so Pypy can only asymptotically reach the same level as C and assembly.<br><br>Second, the test is flawed: I did a slight modification that shouldn't change the results: I've inlined the add() in both python and C. Oh! surprise: Pypy keeps the same time whereas C is 4x faster than before (without inlining).<br><br>So to make it fair, we need to use the best capabilities of both languages:<br>- python: I'm sure the author provided the best python implementation, and the fact that inlining add() doesn't change results kinda proves this)<br>- C: when you inline the function you get:<br><br>[code]<br><br>static inline double add_double(double a, double b) {<br>  return a + b;<br>}<br><br>int main()<br>{<br>  unsigned int i;<br>  double a = 0.0;<br><br>  for (i = 0; i &lt; N; i++) {<br>    a += 1.0;<br>    add_double(a, a);<br>  }<br>  printf("%f\n", a);<br>}<br><br>[/code]<br><br>Results:<br>  C inlined: 1.10s<br>  C: 3.98s<br>  Pypy inlined: 3.30s<br>  Pypy: 3.28s<br><br>Conclusion:<br>- When using the right C code, on the same example C is 3 times faster than Pypy.<br>- As demonstrated, the statement that Pypy is faster than C is simply biased by a not optimizsed C code.</p>
        </div>
      </div>
      <div class="comment comment-8668464377001730942">
        <div class="comment-header">
          <a name="comment-8668464377001730942"></a>
            <span class="author">Staff</span> wrote on <span class="date">2012-11-21 06:07</span>:
        </div>
        <div class="comment-content">
          <p>@Eric This post is not trying to argue that Python is "better" or even faster than C. It is just pointing out that certain classes of optimizations (i.e. whole program optimizations) come naturally to the PyPy JIT.  <br><br>This is, of course, only one small facet of why a program runs fast. The author admits that it is a contrived example to illustrate the point.<br><br>Taking the point to an extreme, one could see a PyPy program run faster than a C program if the C program made many calls to simple shared libraries. For example, if one dynamically links a C stdlib into their program, and uses it heavily, the equivalent python code may conceivably run faster.</p>
        </div>
      </div>
      <div class="comment comment-5517713403085287663">
        <div class="comment-header">
          <a name="comment-5517713403085287663"></a>
            <span class="author">Eric</span> wrote on <span class="date">2012-11-21 14:44</span>:
        </div>
        <div class="comment-content">
          <p>Please read the title of this article again: "<i>PyPy <b>faster than C</b> on a carefully crafted example</i>"<br><br>Based on a specific example or not it doesn't matter, I'm simply not comfortable with reading strong statement like this that are obvioulsy false to any serious computer scientist and misleading to beginners. It's false because it's the conclusion of a test which is biased.<br><br><b>The root of benchmarking is to get rid of any bias</b><br>In this case the obvious bias is that Pypy is optimized and C isn't (as demonstrated above with inline functions).<br><br>You can't transpose only what you want in real life and not the other: your argument that in real life the C could use external library hence be slower is valid, but then you have to compare with real life Python scripts which can't be as much optimized by Pypy as this crafted example. So in real life you get a C code that may be slowed down a bit by dynamic linking, and python scripts that are much slower because Pypy isn't ready to match C speed for everything (yet).<br><br>If you want to use a crafted Python example, you have to compare it to a crafted C example, so that you can compare apples with apples.<br><br>All that is methodology, that said JIT is quite powerful and it's impressive in itself to beat CPython by a large margin.<br></p>
        </div>
      </div>
      <div class="comment comment-354498782860915813">
        <div class="comment-header">
          <a name="comment-354498782860915813"></a>
            <span class="author">keegano</span> wrote on <span class="date">2013-02-06 22:53</span>:
        </div>
        <div class="comment-content">
          <p>Eric: Your comments about "real life" are irrelevant - the post is about a specific, contrived example. I don't think anyone would argue that a high-level, garbage-collected language like python could ever beat out C in general - it's simply a demonstration that, in a very specific instance, equivalent code in python and C can run faster in python because of the JIT making optimizations that can't occur at compile time.</p>
        </div>
      </div>
      <div class="comment comment-4905285822985156121">
        <div class="comment-header">
          <a name="comment-4905285822985156121"></a>
            <span class="author">Eric</span> wrote on <span class="date">2013-02-06 23:02</span>:
        </div>
        <div class="comment-content">
          <p>You're assuming that python is faster even on this crafted example, but keep in mind that this comparison is biased because the C version isn't optimal.</p>
        </div>
      </div>
      <div class="comment comment-2637708137141797331">
        <div class="comment-header">
          <a name="comment-2637708137141797331"></a>
            <span class="author">Eric</span> wrote on <span class="date">2013-02-06 23:02</span>:
        </div>
        <div class="comment-content">
          <p>you're assuming that python is faster even on this crafted example, but keep in mind that this comparison is biased because the C version isn't optimal.</p>
        </div>
      </div>
      <div class="comment comment-8696113330242639387">
        <div class="comment-header">
          <a name="comment-8696113330242639387"></a>
            <span class="author">Staff</span> wrote on <span class="date">2013-02-07 01:42</span>:
        </div>
        <div class="comment-content">
          <p>stop feeding this troll</p>
        </div>
      </div>
      <div class="comment comment-1752276717722972607">
        <div class="comment-header">
          <a name="comment-1752276717722972607"></a>
            <span class="author">Eric</span> wrote on <span class="date">2013-02-07 10:18</span>:
        </div>
        <div class="comment-content">
          <p>point taken, but do update the article to take into account my remark: both the title and the conclusion of the "demonstration" are false, even on a contrived example as you barely can't find any C code that would be slower than the code generated by your JIT for the simple reason that C is really too close to assembly and that JIT adds an overhead.</p>
        </div>
      </div>
      <div class="comment comment-261341680642203204">
        <div class="comment-header">
          <a name="comment-261341680642203204"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2013-02-07 10:30</span>:
        </div>
        <div class="comment-content">
          <p>Hey Eric.<br><br>Your argument is incredibly flawed. You can compile faster version of assembler (or is C the fastest assembler ever?) if you try hard enough. Why not?</p>
        </div>
      </div>
      <div class="comment comment-7915919417549668442">
        <div class="comment-header">
          <a name="comment-7915919417549668442"></a>
            <span class="author">Eric</span> wrote on <span class="date">2013-02-07 10:48</span>:
        </div>
        <div class="comment-content">
          <p>Please don't digress, what I say is simple:<br>The article states that Pypy generates code faster than C on a crafted example.<br>I demonstrate there is a more optimized C code that the author's one, hence that the whole article is wrong... end of the story.<br></p>
        </div>
      </div>
      <div class="comment comment-6883373547469571610">
        <div class="comment-header">
          <a name="comment-6883373547469571610"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2013-02-07 10:52</span>:
        </div>
        <div class="comment-content">
          <p>No, it's a reasonable piece of C. You don't inline your printf code, do you? dynamic linking is a thing that people use.</p>
        </div>
      </div>
      <div class="comment comment-8387866530411076430">
        <div class="comment-header">
          <a name="comment-8387866530411076430"></a>
            <span class="author">Eric</span> wrote on <span class="date">2013-02-09 11:38</span>:
        </div>
        <div class="comment-content">
          <p>You're right, people very often use dynamic linking. However the following is not a reasonable piece of Python code:<br><br>def add(a, b): return a + b<br><br>People rarely use that and more importantly they don't write a loop that calls it 1 billion times.<br><br>The point is that the reasoning spans two levels (hence is flawed/biased):<br>- in Python the author took a crafted piece of Python that is not meaningful in real life because it has the property to do what he wants at the Pypy level<br>- in C the author uses a very common mechanism that isn't fully optimized (not as much as Python/Ppy is optimized).<br><br>I know you will not agree since you're all proud that "Pypy is faster than C" (lol it's nonsense even on a "crafted example") but you have to compare apples with apples.</p>
        </div>
      </div>
      <div class="comment comment-4479384152902342489">
        <div class="comment-header">
          <a name="comment-4479384152902342489"></a>
            <span class="author">Dvd Fo</span> wrote on <span class="date">2013-09-20 18:29</span>:
        </div>
        <div class="comment-content">
          <p>@Eric what you don't understand is the point of the article. The actual point is to demonstrate a nice property of PyPy JIT, which is able to generate fast code when it can. Comparing to C in this manner proves that PyPy's generated machine code is relevant with regard to speed.<br>Of course this example is fragile because it relies on suboptimal C code, but this serves only to prove the point about PyPy.</p>
        </div>
      </div>
      <div class="comment comment-2174510732199016419">
        <div class="comment-header">
          <a name="comment-2174510732199016419"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2013-12-07 06:14</span>:
        </div>
        <div class="comment-content">
          <p>@Eric... Non sense.. Are you a ambassador for C ?</p>
        </div>
      </div>
      <div class="comment comment-4668352774687149243">
        <div class="comment-header">
          <a name="comment-4668352774687149243"></a>
            <span class="author">Eric</span> wrote on <span class="date">2013-12-07 08:44</span>:
        </div>
        <div class="comment-content">
          <p>Do argue if you disagree, don't troll.<br><br>I think everything have been said already anyway.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/01/jit-backend-for-arm-processors-5994810755839586463.html" class="u-url">A JIT Backend for ARM Processors</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/david-schneider.html">David Schneider</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/01/jit-backend-for-arm-processors-5994810755839586463.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-01-29T14:19:00Z" itemprop="datePublished" title="2011-01-29 14:19">2011-01-29 14:19</time></a>
            </p>
                <p class="commentline">10 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <div class="document" id="a-jit-backend-for-arm-processors">
In the past few months, I have been developing as a part of my master thesis
the ARM backend for the the PyPy JIT, in the <a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/tree/branch/arm-backend-2">arm-backend</a> branch. Currently, it is still work in progress: all integer and object operations are working and
the support for <a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/tree/branch/arm-backed-float">floating point</a> is also under development.<br>
ARM processors are very widely used, being deployed in servers, some netbooks
and mainly mobile devices such as phones and tablets. One of our goals is to be
able to run PyPy on phones, specially on Android. Currently is not yet possible
to translate and compile PyPy for Android automatically, but there has been
some <a class="reference external" href="https://pyppet.blogspot.com/2011/01/android-and-rpython.html">work</a>  on using Android's NDK to compile PyPy's generated C code.<br>
The JIT Backend targets the application profile of the ARMv7 instruction set
architecture which is found for example in the Cortex-A8 processors used in many Android powered devices and in Apple's <a class="reference external" href="https://en.wikipedia.org/wiki/Apple_A4">A4 processors</a> built into the latest iOS devices. To develop and
test the backend we are using a <a class="reference external" href="https://beagleboard.org/hardware-xM">BeagleBoard-xM</a> which has a 1 GHz ARM
Cortex-A8 and 512 MB of RAM running the <a class="reference external" href="https://wiki.ubuntu.com/ARM">ARM port</a> of Ubuntu 10.10.<br>
Currently on Linux it is possible to translate and cross-compile PyPy's Python
interpreter as well as other interpreters with the ARM JIT backend enabled
using Scratchbox 2 to provide a build environment and the GNU ARM cross
compilation toolchain. So far the backend only supports the <a class="reference external" href="https://www.hpl.hp.com/personal/Hans_Boehm/gc/">Boehm</a> garbage
collector which does not produce the best results combined with the JIT, but we
plan to add support for the other GCs in the future, doing so should increase
the performance of PyPy on ARM.<br>
While still debugging the last issues with the backend we already can run some
simple benchmarks on <a class="reference external" href="https://bitbucket.org/cfbolz/pyrolog">Pyrolog</a>, a prolog interpreter written in RPython.
Even using Boehm as the GC the results look very promising. In the benchmarks
we compare Pyrolog to <a class="reference external" href="https://www.swi-prolog.org/">SWI-Prolog</a>, a prolog interpreter written in C, which
is available from the package repositories for Ubuntu's ARM port.<br>
The benchmarks can be found in the <a class="reference external" href="https://bitbucket.org/cfbolz/pyrolog-benchmark">pyrolog-bench</a> repository.<br><table border="1" class="docutils">
<colgroup></colgroup>
<colgroup><col width="32%"></colgroup>
<colgroup><col width="30%"></colgroup>
<colgroup><col width="25%"></colgroup>
<colgroup><col width="13%"></colgroup>
<thead valign="bottom"><tr>
<th class="head">Benchmark</th>
<th class="head">SWI-Prolog in ms.</th>
<th class="head">Pyrolog in ms.</th>
<th class="head">Speedup</th>
</tr></thead>
<tbody valign="top">
<tr>
<td>iterate</td>
<td>60.0</td>
<td>6.0</td>
<td>10.0</td>
</tr>
<tr>
<td>iterate_assert</td>
<td>130.0</td>
<td>6.0</td>
<td>21.67</td>
</tr>
<tr>
<td>iterate_call</td>
<td>3310.0</td>
<td>5.0</td>
<td>662.0</td>
</tr>
<tr>
<td>iterate_cut</td>
<td>60.0</td>
<td>359.0</td>
<td>0.16713</td>
</tr>
<tr>
<td>iterate_exception</td>
<td>4950.0</td>
<td>346.0</td>
<td>14.306</td>
</tr>
<tr>
<td>iterate_failure</td>
<td>400.0</td>
<td>127.0</td>
<td>3.1496</td>
</tr>
<tr>
<td>iterate_findall</td>
<td>740.0</td>
<td>No res.</td>
<td></td>
</tr>
<tr>
<td>iterate_if</td>
<td>140.0</td>
<td>6.0</td>
<td>23.333</td>
</tr>
</tbody>
</table>
The iterate_call benchmark, which constructs a predicate and calls it at
runtime, with a speedup of 662 times over SWI-Prolog is an example where the
JIT can show its strength. The Pyrolog interpreter and the JIT treat
dynamically defined predicates as static ones and can generate optimezed code
in both cases. Whereas SWI only compiles statically defined rules and has to
fall back to interpretation on dynamic ones.<br>
For simple benchmarks running on PyPy's Python intepreter we see some speedups
over CPython, but we still need to debug the backend bit more before we can
show numbers on more complex benchmarks. So, stay tuned.</div>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-3247073772687763599">
        <div class="comment-header">
          <a name="comment-3247073772687763599"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-01-30 10:01</span>:
        </div>
        <div class="comment-content">
          <p>Awesome stuff.  I have a panda board and another xm that's usually not doing much if you want to borrow some cycles :-)<br><br>When you support floats will you be aiming for hard float?  It's the way of the future, I hear...</p>
        </div>
      </div>
      <div class="comment comment-8869000827477806234">
        <div class="comment-header">
          <a name="comment-8869000827477806234"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-01-30 11:47</span>:
        </div>
        <div class="comment-content">
          <p>I am curious if you had any use for ThumbEE (or Jazelle RCT) to speed up?</p>
        </div>
      </div>
      <div class="comment comment-5715738330822619623">
        <div class="comment-header">
          <a name="comment-5715738330822619623"></a>
            <span class="author">David Schneider</span> wrote on <span class="date">2011-01-30 19:05</span>:
        </div>
        <div class="comment-content">
          <p>@mwhudson: thanks it would be great to be able to test on more hardware.<br><br>For the float support we still need to investigate a bit, but if possible I would like to target hard floats.<br><br>@dbrodie: currently we are targeting the arm state, so not at the moment.</p>
        </div>
      </div>
      <div class="comment comment-6382604539450333842">
        <div class="comment-header">
          <a name="comment-6382604539450333842"></a>
            <span class="author">Martijn Faassen</span> wrote on <span class="date">2011-01-31 14:11</span>:
        </div>
        <div class="comment-content">
          <p>One would imagine conserving memory would be an important factor on mobile devices. Even though mobile devices have a growing amount of memory available, it will still be less than desktops for the forseeable future. Memory pressure can create real slowdowns.<br><br>A JIT normally takes more memory, but on the other hand PyPy offers features to reduce usage of memory. Could you share some of your thinking on this?</p>
        </div>
      </div>
      <div class="comment comment-795390280737731275">
        <div class="comment-header">
          <a name="comment-795390280737731275"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2011-02-05 19:51</span>:
        </div>
        <div class="comment-content">
          <p>Martijn: you are describing the situation as well as we (at least I) know it so far: while PyPy has in many cases a lower non-JIT memory usage, the JIT adds some overhead.  But it seems to be within ~200MB on "pypy translate.py", which is kind of the extreme example in hugeness.  So already on today's high-end boards with 1GB of RAM, it should easily fit.  Moreover it can be tweaked, e.g. it's probably better on these systems to increase the threshold at which JITting starts (which also reduces the number of JITted code paths).  So I think that the possibility is real.</p>
        </div>
      </div>
      <div class="comment comment-1792554686051912332">
        <div class="comment-header">
          <a name="comment-1792554686051912332"></a>
            <span class="author">Dan</span> wrote on <span class="date">2011-04-30 16:40</span>:
        </div>
        <div class="comment-content">
          <p>Showing speedups over repetitive instructions (which caching &amp; JIT are really good at) is irrelevant.<br><br>What happens when people use real benchmarks, like constraint-based solvers and non-iterative stuff (maybe take a look at the other benchmarks) ...<br><br>Prolog is a declative language, not a sysadmin scripting language.<br><br>Also, the SWI implementation adds so many functionalities, it's like making a «Extract chars from an RDBMS vs Text files» benchmark.</p>
        </div>
      </div>
      <div class="comment comment-3984841426980649696">
        <div class="comment-header">
          <a name="comment-3984841426980649696"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-05-02 19:02</span>:
        </div>
        <div class="comment-content">
          <p>@Dan<br><br>Why are you so defensive? This benchmark is clearly not about how fast Pyrolog is, but how the ARM JIT backend performs, using trivial Prolog microbenchmarks, with SWI to give a number to compare against.<br><br>Pyrolog is a minimal Prolog implementation that is (at least so far) mostly an experiment to see how well PyPy's JIT technology can do on an non-imperative language. This paper contains more interesting benchmarks:<br><br>https://portal.acm.org/citation.cfm?id=1836102</p>
        </div>
      </div>
      <div class="comment comment-9145169645150685772">
        <div class="comment-header">
          <a name="comment-9145169645150685772"></a>
            <span class="author">jamu</span> wrote on <span class="date">2011-05-16 13:11</span>:
        </div>
        <div class="comment-content">
          <p>Hi,<br>Is there a way to cross compile on a host machine (but not with scratch box) where I have tool chain and file system for the target?<br><br>Any instructions for building with arm back-end?<br><br>Cheers</p>
        </div>
      </div>
      <div class="comment comment-5052740497856444342">
        <div class="comment-header">
          <a name="comment-5052740497856444342"></a>
            <span class="author">David Schneider</span> wrote on <span class="date">2011-06-08 20:41</span>:
        </div>
        <div class="comment-content">
          <p>@jamu: scratchbox 2 is currently the only option to cross-translate pypy for ARM. You can find some documentation about the cross translation at https://foss.heptapod.net/pypy/pypy/-/tree/branch/arm-backend-2/pypy/doc/arm.rst</p>
        </div>
      </div>
      <div class="comment comment-1731218078112566368">
        <div class="comment-header">
          <a name="comment-1731218078112566368"></a>
            <span class="author">vak</span> wrote on <span class="date">2011-09-30 10:12</span>:
        </div>
        <div class="comment-content">
          <p>Sounds very cool, are there any updates?</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/01/pypy-wants-you-4543209863582915733.html" class="u-url">PyPy wants you!</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/antonio-cuni.html">Antonio Cuni</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/01/pypy-wants-you-4543209863582915733.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-01-21T10:22:00Z" itemprop="datePublished" title="2011-01-21 10:22">2011-01-21 10:22</time></a>
            </p>
                <p class="commentline">8 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <a href="https://1.bp.blogspot.com/_4gR6Ggu8oHQ/TTlfADvFl0I/AAAAAAAAALw/E-4fOAyUuSQ/s1600/Uncle_Sam.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5564583269200402242" src="https://1.bp.blogspot.com/_4gR6Ggu8oHQ/TTlfADvFl0I/AAAAAAAAALw/E-4fOAyUuSQ/s200/Uncle_Sam.png" style="float: right; margin: 0 0 10px 10px; cursor: pointer; cursor: hand; width: 149px; height: 200px;"></a>

<p>If you ever considered contributing to PyPy, but never did so far, this is a
good moment to start! :-)</p>
<p>Recently, we merged the <a class="reference external" href="https://bitbucket.org/pypy/pypy/changeset/9317ec76d9eb">fast-forward</a> branch which brings Python 2.7
compatibility, with the plan of releasing a new version of PyPy as soon as all
tests pass.</p>
<p>However, at the moment there are still quite a few of <a class="reference external" href="https://buildbot.pypy.org/summary?branch=%3Ctrunk%3E">failing tests</a> because
of new 2.7 features that have not been implemented yet: many of them are easy
to fix, and doing it represents a good way to get confidence with the code
base, for those who are interested in it. Michael Foord wrote a little <a class="reference external" href="https://bitbucket.org/pypy/pypy/wiki/How%20to%20run%20lib-python%20tests">howto</a>
explaining the workflow for running lib-python tests.</p>
<p>Thus, if you are willing to join us in the effort of having a PyPy compatible
with Python 2.7, probably the most sensible option is to come on the #PyPy IRC
channel on Freenode, so we can coordinate each other not to fix the same test
twice.</p>
<p>Moreover, if you are a student and are considering participating in the next
<a class="reference external" href="https://code.google.com/soc/">Google Summer of Code</a> this is a good time to get into pypy. You have the
opportunity to get a good understanding of pypy for when you decide what you
would like to work on over the summer.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-1911842402187793608">
        <div class="comment-header">
          <a name="comment-1911842402187793608"></a>
            <span class="author">Oliver Sherouse</span> wrote on <span class="date">2011-01-21 19:15</span>:
        </div>
        <div class="comment-content">
          <p>Would you mind giving us a hint of what skills programmers would need to be actually useful?  I know you don't want to scare anybody off, but PyPy is kind of the ultimate evolution of what you can do with the language, and I get the sense (perhaps wrongly!) that it goes places where desktop-and-web-app guys like me are a bit out of our depth and actually might waste time more than anything else.<br><br>I'm asking this here because I'm pretty sure that others are going to be thinking the same thing.</p>
        </div>
      </div>
      <div class="comment comment-2903055646896012595">
        <div class="comment-header">
          <a name="comment-2903055646896012595"></a>
            <span class="author">nekto0n</span> wrote on <span class="date">2011-01-21 20:37</span>:
        </div>
        <div class="comment-content">
          <p>Seems a lot of volantiers applied - buildbot.pypy.org renders 502 Proxy Error</p>
        </div>
      </div>
      <div class="comment comment-4464733037532301296">
        <div class="comment-header">
          <a name="comment-4464733037532301296"></a>
            <span class="author">holger krekel</span> wrote on <span class="date">2011-01-22 11:35</span>:
        </div>
        <div class="comment-content">
          <p>Nofrak: you ask good questions.  I'd say you need to know your way around Python programming in general which you most certainly do if you have done desktop or Web apps in Python.<br><br>Secondly, it's important to know a bit about the basic structure of an Python interpreter.  Reading some docs, among them Chapter 1 of https://codespeak.net/pypy/trunk/pypy/doc/coding-guide.html#overview-and-motivation should help.  <br><br>Thirdly, methodology: PyPy is written in a test-driven way, and for the Python interpreter there are several places for tests: one is the (sometimes slightly modified) standard CPython tests in the lib-python/(modified-)2.7.0 directory, another is pypy/objspace/std/test.  The implementation of the interpreter mainly is written down in pypy/objspace/std/*.py.<br><br>Hope that helps a bit.  IRC is a good place to ask for further directions, of course.</p>
        </div>
      </div>
      <div class="comment comment-4409512875656599789">
        <div class="comment-header">
          <a name="comment-4409512875656599789"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-01-22 20:31</span>:
        </div>
        <div class="comment-content">
          <p>And then what do we do after fixing a failing test case? For each patch, create a new bug in the bug tracker and attach it?</p>
        </div>
      </div>
      <div class="comment comment-3244601802488376280">
        <div class="comment-header">
          <a name="comment-3244601802488376280"></a>
            <span class="author">Antonio Cuni</span> wrote on <span class="date">2011-01-22 22:59</span>:
        </div>
        <div class="comment-content">
          <p>@Anonymous: creating a new issue in the bug tracker is not necessary: you can just come on IRC or write to pypy-dev attaching your patch, or you can e.g. fork the project on bitbucket and send a pull request, or you can send us the mercurial bundle, etc. etc.<br><br>There is no really any bureaucracy for this :)</p>
        </div>
      </div>
      <div class="comment comment-5267570295967779389">
        <div class="comment-header">
          <a name="comment-5267570295967779389"></a>
            <span class="author">Simon JOnes</span> wrote on <span class="date">2011-01-26 23:12</span>:
        </div>
        <div class="comment-content">
          <p>What is the best IRC channel to go on?</p>
        </div>
      </div>
      <div class="comment comment-3879801080909595458">
        <div class="comment-header">
          <a name="comment-3879801080909595458"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2011-01-27 05:33</span>:
        </div>
        <div class="comment-content">
          <p>#pypy on freenode</p>
        </div>
      </div>
      <div class="comment comment-1995017995934533343">
        <div class="comment-header">
          <a name="comment-1995017995934533343"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-02-16 19:01</span>:
        </div>
        <div class="comment-content">
          <p>What's the story on PyPy for the Python 3 language?  Python 3 is over 2 years old, and Python 2.x is looking older every day.  I might consider getting involved, but I don't want to feel like I'm spending time contributing to a dead-end branch of the language.</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2011/01/loop-invariant-code-motion-1998392217676829154.html" class="u-url">Loop invariant code motion</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/hakan-ardo.html">Hakan Ardo</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2011/01/loop-invariant-code-motion-1998392217676829154.html" rel="bookmark">
            <time class="published dt-published" datetime="2011-01-11T19:22:00Z" itemprop="datePublished" title="2011-01-11 19:22">2011-01-11 19:22</time></a>
            </p>
                <p class="commentline">3 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Recently, the jit-unroll-loops branch was merged. It implements the
idea described in 
<a href="../posts/2010/09/using-escape-analysis-across-loop-2887031293132023676.html">Using Escape Analysis Across Loop Boundaries for Specialization</a>.
That post does only talk about virtuals, but the idea turned out
to be more far reaching. After the metainterpreter produces a trace,
several optimizations are applied to the trace before it is turned
into binary code. Removing allocations is only one of them. There are also
for instance
</p>
<ul>
<li> Heap optimizations that removes memory accesses by reusing results
  previously read from or written to the same location.
</li>
<li> Reusing of the results of pure operations if the same pure
  operation is executed twice.
</li>
<li> Removal of redundant guards.
</li>
<li> ...
</li>
</ul>
A lot of these optimizations are in one way or another removing
operations form the trace and/or reusing previous results. All of these
optimizations could benefit from being able to operate across loop
boundaries. Not only in the sense that operations operating on loop
invariants could be moved out of the loop entirely. But also that
results produced at the end of an iteration could be reused at the
beginning of the next even if there are no loop invariants involved.

<p>

This is achieved by unrolling the trace into two iterations, and
letting the optimizer work on this two-iteration-trace.
The optimizer will now be able to optimize the second iteration more than the
first since it can reuse results from the first iteration. The
optimized version of the first iteration we call the <em>preamble</em> and the
optimized version of the second iteration we call the <em>loop</em>. The
preamble will end with a jump to the loop, while the loop will end
with a jump to itself. This means that the preamble will be executed
once for the first iteration, the loop will be executed for all following
iterations.
 
</p>
<p>
</p>
<h2>Sqrt example</h2>
Here is an example of a Python implementation of sqrt using a fairly
simple algorithm

<p>
<!-- pygmentize -f html -O full -o t.html t.py -->
  

</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">x</span>
</pre></div>
<p>

If it is called with <tt>sqrt(1234.0)</tt>,  
<a href="https://bitbucket.org/hakanardo/hakanardo/src/edbd398575ad/sqrt/noopt.txt">a fairly long trace</a> is produced. From this trace
the optimizer creates
the
following preamble (Loop 1) and loop (Loop 0) 


</p>
<p>
<!--
<img src="trace1.png">
<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="https://2.bp.blogspot.com/_Ti798w4YGGI/TSyurBi3pLI/AAAAAAAAADA/IJQ0Ki4Pu0E/s1600/trace1.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 225px; height: 320px;" src="https://2.bp.blogspot.com/_Ti798w4YGGI/TSyurBi3pLI/AAAAAAAAADA/IJQ0Ki4Pu0E/s320/trace1.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5561011694068016306" /></a>
-->
<img src="https://2.bp.blogspot.com/_Ti798w4YGGI/TSyurBi3pLI/AAAAAAAAADA/IJQ0Ki4Pu0E/s1600/trace1.png"></p>
<p>

Looking at the preamble, it starts by making sure that it is not 
currently being profiled, the guard
on <tt>i5</tt>, and that the function object have not been changed
since the trace was made, the guard on <tt>p3</tt>. Somewhat
intermixed with that, the
integer variable <tt>n</tt> is unboxed, by making sure <tt>p11</tt>
points to an integer object and reading out the integer value from
that object. 
These operations are not needed in the
loop (and have been removed from it) as emitting the same guards again
would be redundant and <tt>n</tt> becomes a virtual before the
end of the preamble.
</p>
<pre>
        guard_value(i5, 0, descr=&lt;Guard6&gt;) 
        guard_nonnull_class(p11, ConstClass(W_IntObject), descr=&lt;Guard7&gt;) 
        guard_value(p3, ConstPtr(ptr15), descr=&lt;Guard8&gt;) 
        i16 = getfield_gc_pure(p11, descr=&lt;W_IntObject.inst_intval&gt;)
</pre>

Next comes a test and a guard implementing the while statement
followed by the decrementing of <tt>n</tt>. These operation appear
both in the preamble and in the loop
<pre>
        i18 = int_gt(i16, 0)
        guard_true(i18, descr=&lt;Guard9&gt;) 
        i20 = int_sub(i16, 1)
</pre>

After that the two floating point variables <tt>x</tt> and <tt>y</tt>
are unboxed. Again this is only needed in the preamble. Note how the
unboxed value of <tt>y</tt>, called <tt>f23</tt>, is passed unchanged
from the preamble to the loop in arguments of the jump 
to allow it to be reused. It will not become a virtual
since it is never changed within the loop.
<pre>
        guard_nonnull_class(p12, 17652552, descr=&lt;Guard10&gt;) 
        guard_nonnull_class(p10, 17652552, descr=&lt;Guard11&gt;) 
        f23 = getfield_gc_pure(p10, descr=&lt;W_FloatObject.inst_floatval&gt;)
        f24 = getfield_gc_pure(p12, descr=&lt;W_FloatObject.inst_floatval&gt;)
</pre>

Following that is the actual calculations performed in the loop in
form of floating point operations (since the function was called with
a float argument). These appear in both the loop
and the preamble.
<pre>
        i26 = float_eq(f24, 0.000000)
        guard_false(i26, descr=&lt;Guard12&gt;) 
        f27 = float_truediv(f23, f24)
        f28 = float_add(f24, f27)
        f30 = float_truediv(f28, 2.000000)
</pre>

Finally there are some tests checking if a signal was received
(such as when the user presses ctrl-C) and thus should execute some
signal handler or if we need to hand over to another thread. This is
implemented with a counter that is decreased once every iteration. It
will go below zero after some specific number of iterations, tunable by
<tt>sys.setcheckinterval</tt>. The counter is read from and written to
some global location where it also can be made negative by a C-level
signal handler. 
<pre>
        i32 = getfield_raw(32479328, descr=&lt;pypysig_long_struct.c_value&gt;)
        i34 = int_sub(i32, 2)
        setfield_raw(32479328, i34, descr=&lt;pypysig_long_struct.c_value&gt;)
        i36 = int_lt(i34, 0)
        guard_false(i36, descr=&lt;Guard13&gt;) 
        jump(p0, p1, p2, p4, p10, i20, f30, f23, descr=&lt;Loop0&gt;)
</pre>

<p>
</p>
<h2>Bridges</h2>

When a guard fails often enough, the meta-interpreter is started again
to produce a new trace starting at the failing guard. The tracing is
continued until a previously compiled loop is entered. This could
either be the the same loop that contains the failing guard
or some completely different loop. If it is the same loop, executing
the preamble again maybe be unnecessary.
It is preferable to end the bridge with a jump directly to 
the loop. To achieve this the optimizer tries to produce <i>short
  preambles</i> that are inlined at the end of bridges allowing
them to jump directly to the loop. Inlining is better than jumping to
a common preamble because most of the inlined short preamble can
typically be removed again by the optimizer.
Creating such a short
preamble is however not always possible. Bridges jumping to loops for which
no short preamble can be generated have to end with a jump to the
full preamble instead.

<p>

The short preamble is created by comparing the operations in the
preamble with the operations in the loop. The
operations that are in the preamble but not in the loop 
are moved to the short preamble whenever it is safe to move them to
the front of the operations remaining. In other words, the full preamble
is equivalent to the short preamble followed by one iteration of the
loop. 

</p>
<p>

This much has currently been implemented. To give the full picture
here, there are two more features that 
hopefully will be implemented in the near future.
The first is to replace the full preamble, used by the interpreter
when it reaches a compiled loop, with the short preamble.
This is currently not done and is probably not as straight forward as
it might first seem. The problem is where to resume interpreting on a
guard failure. However, implementing that should save some
memory. Not only 
because the preamble will become smaller, but mainly because the
guards will appear either in the loop or in the preamble, but not
in both (as they do now). That means there will only be a single bridge and 
not potentially two copies once the guards are traced.

</p>
<p>

The sqrt example above would with a short preamble result in a trace
like this

</p>
<p>
<!--
<img src="trace2.png"><p>
<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="https://4.bp.blogspot.com/_Ti798w4YGGI/TS4S_CifokI/AAAAAAAAADI/uPpoIngmD-I/s1600/trace2.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 306px; height: 320px;" src="https://4.bp.blogspot.com/_Ti798w4YGGI/TS4S_CifokI/AAAAAAAAADI/uPpoIngmD-I/s320/trace2.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5561403464071750210" /></a>
-->
<img src="https://4.bp.blogspot.com/_Ti798w4YGGI/TS4S_CifokI/AAAAAAAAADI/uPpoIngmD-I/s1600/trace2.png"></p>
If it is executed long enough, the last guard will be traced to form a
bridge. The trace will inherit the virtuals from its parent. This can
be used to optimize away the part of the inlined short preamble
that deals with virtuals. The resulting bridge should look
something like

<pre>
    [p0, p1, p2, p3, p4, f5, i6]
    i7 = force_token()
    setfield_gc(p1, i7, descr=&lt;PyFrame.vable_token&gt;)
    call_may_force(ConstClass(action_dispatcher), p0, p1, descr=&lt;VoidCallDescr&gt;)
    guard_not_forced(, descr=&lt;Guard19&gt;) 
    guard_no_exception(, descr=&lt;Guard20&gt;) 

    guard_nonnull_class(p4, 17674024, descr=&lt;Guard21&gt;) 
    f52 = getfield_gc_pure(p4, descr=&lt;W_FloatObject.inst_floatval&gt;)
    jump(p1, p0, p2, p3, p4, i38, f53, f52, descr=&lt;Loop0&gt;)
</pre>

Here the first paragraph comes from the traced bridge and the second
is what remains of the short preamble after optimization. The
box <tt>p4</tt> is 
not a virtual (it contains a pointer to <tt>y</tt> which is never
changed), and it is only virtuals 
that the bridge inherit from it's parents. This is why the last two
operations currently cannot be removed.


<p>

Each time the short preamble is inlined, a new copy of each of the
guards in it is generated. Typically the short preamble is inlined in
several places and thus there will be several copies of each of those
guards. 
If they fail often enough bridges
from them will be traced (as with all guards). But since there
typically are several copies of each guard the same bridge
will be generated in 
several places. To prevent this, mini-bridges from the inlined guards
are produced already during the inlining. These mini-bridges contain
nothing but a jump to the preamble.

</p>
<p>
The mini-bridges needs the arguments of the preamble to be able
to jump to it. These arguments contain among other things, boxed
versions of the 
variables <tt>x</tt> and <tt>y</tt>. Those variables are virtuals in
the loop, and have to be allocated. Currently those allocations
are placed in front of the inlined guard. Moving those allocations into
the mini-bridges is the  second feature that 
hopefully will be implemented in the near future. 
<!--
The current approach actually kills the entire benefit of the inlining in most
real world cases as typically all the virtuals are forced.
-->
After this feature is
implemented, the result should look something like
</p>
<p>
<!--
<img src="trace3.png"><p>
<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="https://4.bp.blogspot.com/_Ti798w4YGGI/TS4TlHWn2GI/AAAAAAAAADg/xqc4-B4HH3M/s1600/trace3.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 243px;" src="https://4.bp.blogspot.com/_Ti798w4YGGI/TS4TlHWn2GI/AAAAAAAAADg/xqc4-B4HH3M/s320/trace3.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5561404118199162978" /></a>
-->
<a href="https://4.bp.blogspot.com/_Ti798w4YGGI/TS4TlHWn2GI/AAAAAAAAADg/xqc4-B4HH3M/s1600/trace3.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5561404118199162978" src="https://4.bp.blogspot.com/_Ti798w4YGGI/TS4TlHWn2GI/AAAAAAAAADg/xqc4-B4HH3M/s1600/trace3.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 597px; height: 454px;"></a>

</p>
<p>
</p>
<h2>Multiple specialized versions</h2>

Floating point operations were generated in the trace above
because <tt>sqrt</tt> was called with a float argument. If it is
instead called with an int argument, integer operations will be generated. The
somewhat more complex situations is when both int's and float's are
used as arguments. Then the jit need to generate multiple versions of
the same loop, specialized in different ways. The details, given
below, on how this is achieved is somewhat involved. For the casual
reader it would make perfect sense to skip to the next section here.

<p>

Consider the case when <tt>sqrt</tt> is first called with a float
argument (but with <tt>n</tt> small enough not to generate the
bridge). Then the trace shown above will be
generated. If <tt>sqrt</tt> is now called with an int argument, the
guard in the preamble testing that the type of the input object is float
will fail:
</p>
<pre>
        guard_nonnull_class(p12, 17652552, descr=&lt;Guard10&gt;) 
</pre>
It will fail every iteration, so soon enough a bridge will be
generated from this guard in the preamble. This guard will end with a
jump to the same loop, and the optimizer will try to inline
the short preamble at the end of it. This will however fail
since now there are two guards on <tt>p12</tt>. One that makes sure it
is an int and and one that makes sure it is a float. The optimizer
will detect that the second guard will always fail and mark the bridge
as invalid. Invalid loops are not passed on to the backend for
compilation. 

<p>

If a loop is detected to be invalid while inlining the short preamble,
the metainterpreter will continue to trace for yet another 
iteration of the loop. This new trace can be compiled as above and
will produce a new loop with a new preamble that are now specialized
for int arguments instead of float arguments. The bridge that
previously became invalid will now be tried again. This time inlining
the short preamble of the new loop instead. This will produce a set of
traces connected like this

</p>
<p>

<a href="https://2.bp.blogspot.com/_Ti798w4YGGI/TS4TdW6kYmI/AAAAAAAAADY/Py2Eh0sNaOk/s1600/trace4mag.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5561403875692575442" src="https://2.bp.blogspot.com/_Ti798w4YGGI/TS4TW_8i-tI/AAAAAAAAADQ/Ssq63lSRDIU/s1600/trace4.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 630px; height: 603px;"></a>
(click for some hairy details)
</p>
<p>

The height of the boxes is this figure represents how many instructions
they contain (presuming the missing features from the previous section
are implemented). Loop 0 is specialized for floats and it's preamble have
been split into two boxes at the failing guard. Loop 2 is specialized
for ints and is larger than Loop 0. This is mainly because the integer
division in python does not map to the integer division of the
machine, but have to be implemented with several instructions (integer
division in python truncates its result towards minus
infinity, while the the machine integer division truncates towards
0). Also the height of the bridge is about the same as the height of
Loop 2. This is because it contains a full iteration of the loop.

</p>
<p>

</p>
<h2>A More Advanced Example</h2>

Let's conclude with an example that is a bit more advanced, where this unrolling
approach actually outperforms the previous approach. Consider
making a
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed-point</a>
implementation of the square root using 16 bit's of decimals. This can be
done using the same implementation
of <tt>sqrt</tt> but calling it with an object of a class representing
such fixed-point real numbers:

<p>
</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Fix16</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Fix16</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span>  <span class="n">Fix16</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">Fix16</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span>  <span class="n">Fix16</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">-</span> <span class="n">Fix16</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span>  <span class="n">Fix16</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Fix16</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">),</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span>  <span class="n">Fix16</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="n">Fix16</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</pre></div>

<p>

Below is a table comparing the runtime of the sqrt function above with
different argument types on different python interpreters. Pypy 1.4.1
was released before the optimizations described in this post were in place
while they are in place in the 
<a href="https://buildbot.pypy.org/nightly/trunk/pypy-c-jit-40390-e1ab35394b0f-linux64.tar.bz2">nightly
  build from January 5</a>, 
denoted pypy in the table. There are also the running time for the same
algorithms implemented in C and compiled with "gcc -O3
-march=native". Tests were executed on a 2.53GHz Intel Core2
processor with <tt>n=100000000</tt> iterations.
Comparing the integer versions with C may be considered a
bit unfair because of the more advanced integer division operator in
python. The left part of this table shows runtimes of <tt>sqrt</tt> in
a program containing a single call to sqrt (i.e. only a single
specialized version of the loop is needed). The right part shows the
runtime of <tt>sqrt</tt> when it has been called with a different
type of argument before.

</p>
<p>

</p>
<table>
<tr>
<th></th>
<th colspan="3">First call</th>
<th></th>
<th colspan="3">Second call</th>
</tr>
<tr>
<th></th>
<th>float</th>
<th>int</th>
<th>Fix16</th>
<th>  </th>
               <th>float</th>
<th>int</th>
<th>Fix16</th>
</tr>
<tr align="right">
<th align="left">cpython</th>
    <td> 28.18 s</td>
    <td> 22.13 s</td>
    <td> 779.04 s</td>
    <td></td>
    <td> 28.07 s</td>
    <td> 22.21 s</td>
    <td> 767.03 s</td>    
  </tr>
<tr align="right">
<th align="left">pypy 1.4.1</th>
    <td> 1.20 s</td>
    <td> 6.49 s</td>
    <td> 11.31 s</td>
    <td></td>
    <td> 1.20 s</td>
    <td> 6.54 s</td>
    <td> 11.23 s</td>
  </tr>
<tr align="right">
<th align="left">pypy</th>
    <td> 1.20 s</td>
    <td> 6.44 s</td>
    <td> 6.78 s</td>
    <td></td>
    <td> 1.19 s</td>
    <td> 6.26 s</td>
    <td> 6.79 s</td>
  </tr>
<tr align="right">
<th align="left">gcc</th>
    <td> 1.15 s</td>
    <td> 1.82 s</td>
    <td> 1.89 s</td>
    <td></td>
    <td> 1.15 s</td>
    <td> 1.82 s</td>
    <td> 1.89 s</td>
  </tr>
</table>
<p>

For this to work in the last case, when Fix16 is the argument type in
the second type, 
the trace_limit had to be increased from its default value to prevent
the metainterpreter from aborting while tracing the second version of
the loop. Also sys.setcheckinterval(1000000) were used to prevent the
bridge from being generated. With the bridge the performance of the
last case is significantly worse. Maybe because the optimizer currently
fails to generate a short preamble for it. But the slowdown
seems too big for that to be the only explanation. Below are the runtimes
numbers with checkinterval set to its default value of 100:

</p>
<table>
<tr>
<th></th>
<th colspan="3">First call</th>
<th></th>
<th colspan="3">Second call</th>
</tr>
<tr>
<th></th>
<th>float</th>
<th>int</th>
<th>Fix16</th>
<th>  </th>
               <th>float</th>
<th>int</th>
<th>Fix16</th>
</tr>
<tr align="right">
<th align="left">cpython</th>
    <td> 28.71 s</td>
    <td> 22.09 s</td>
    <td> 781.86 s</td>
    <td></td>
    <td> 28.28 s</td>
    <td> 21.92 s</td>
    <td> 761.59 s</td>
  </tr>
<tr align="right">
<th align="left">pypy 1.4.1</th>
    <td> 1.21 s</td>
    <td> 6.48 s</td>
    <td> 11.22 s</td>
    <td></td>
    <td> 1.72 s</td>
    <td> 7.58 s</td>
    <td> 12.18 s</td>
  </tr>
<tr align="right">
<th align="left">pypy</th>
    <td> 1.21 s</td>
    <td> 6.27 s</td>
    <td> 7.22 s</td>
    <td></td>
    <td> 1.20 s</td>
    <td> 6.29 s</td>
    <td> 90.47 s</td>
  </tr>
</table>
<p>
</p>
<h2>Conclusions</h2>
Even though we are seeing speedups in a variety of different small
benchmarks, more complicated examples are not affected much by these
optimizations. It might partly be because larger examples have longer
and more complicated loops, and thus allowing optimizations to operate
across loop boundary will have a smaller relative effect. Another problem is
that with more complicated examples there will be more bridges, and bridges
are currently not handled very well (most of the time all virtuals are
forced at the end of the bridge as explained above). But moving those
forcings into the mini bridges should fix that.
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-806398237946698244">
        <div class="comment-header">
          <a name="comment-806398237946698244"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2011-01-13 07:22</span>:
        </div>
        <div class="comment-content">
          <p>Great post.</p>
        </div>
      </div>
      <div class="comment comment-4957902397764601381">
        <div class="comment-header">
          <a name="comment-4957902397764601381"></a>
            <span class="author">Eric</span> wrote on <span class="date">2012-11-20 16:17</span>:
        </div>
        <div class="comment-content">
          <p>Do you think you could fix the pictures?<br>I only see black images with a exclamation marks.<br><br>thanks</p>
        </div>
      </div>
      <div class="comment comment-8276340427499824114">
        <div class="comment-header">
          <a name="comment-8276340427499824114"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2013-03-05 01:33</span>:
        </div>
        <div class="comment-content">
          <p>Something has eaten the images. Please fix, if you can.<br></p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/12/pypy-141-7283625923182122073.html" class="u-url">PyPy 1.4.1</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/armin-rigo.html">Armin Rigo</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/12/pypy-141-7283625923182122073.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-12-22T09:21:00Z" itemprop="datePublished" title="2010-12-22 09:21">2010-12-22 09:21</time></a>
            </p>
                <p class="commentline">8 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>Here is PyPy 1.4.1 :-)</p>

<p><i><strong>Update:</strong> <a href="https://pypy.org/download.html#default-with-a-jit-compiler">Win32 binaries</a> available.</i></p>

<p>Enjoy!</p>

<h2>Release announcement</h2>

<p>We're pleased to announce
<a href="https://pypy.org/download.html">the 1.4.1 release of PyPy.</a>
This release consolidates all the bug fixes that occurred since the
previous release.  To everyone that took the trouble to report
them, we want to say thank you.</p>

<h2>What is PyPy</h2>

<p>PyPy is a very compliant Python interpreter, almost a drop-in
replacement for CPython.  Note that it still only emulates Python
2.5 by default; the <code>fast-forward</code> branch with Python 2.7
support is slowly getting ready but will only be integrated in
the next release.</p>

<p>In two words, the advantage of trying out PyPy instead of CPython
(the default implementation of Python) is, for now, the
performance.  Not all programs are faster in PyPy, but we are
confident that any CPU-intensive task will be much faster, at
least if it runs for long enough (the JIT has a slow warm-up
phase, which can take several seconds or even one minute on the
largest programs).</p>

<p>Note again that we do support compiling and using C extension
modules from CPython (<code>pypy setup.py install</code>).  However, this
is still an alpha feature, and the most complex modules typically
fail for various reasons; others work (e.g. <code>PIL</code>) but take a
serious performance hit.  Also, for Mac OS X see below.</p>

<p>Please note also that PyPy's performance was optimized almost
exclusively on Linux.  It seems from some reports that on Windows
as well as Mac OS X (probably for different reasons) the
performance might be lower.  We did not investigate much so far.</p>

<h2>More highlights</h2>

<ul>
<li>We migrated to Mercurial (thanks to Ronny Pfannschmidt and
  Antonio Cuni) for the effort) and moved to bitbucket.  The new
  command to check out a copy of PyPy is:
  <br><code>hg clone https://bitbucket.org/pypy/pypy</code>

<p></p>
</li>
<li>In long-running processes, the assembler generated by old
  JIT-compilations is now freed.  There should be no more leak,
  however long the process runs.

<p></p>
</li>
<li>Improve a lot the performance of the <code>binascii</code> module, and
  of <code>hashlib.md5</code> and <code>hashlib.sha</code>.

<p></p>
</li>
<li>Made <code>sys.setrecursionlimit()</code> a no-op.  Instead, we rely purely
  on the built-in stack overflow detection mechanism, which also
  gives you a RuntimeError -- just not at some exact recursion
  level.

<p></p>
</li>
<li>Fix argument processing (now e.g. <code>pypy -OScpass</code> works like
  it does on CPython --- if you have a clue what it does there
  <code>:-)</code> )

<p></p>
</li>
<li>cpyext on Mac OS X: it still does not seem to work.  I get
  systematically a segfault in dlopen().  Contributions welcome.

<p></p>
</li>
<li>Fix two corner cases in the GC (one in minimark, one in
  asmgcc+JIT).  This notably prevented <code>pypy translate.py -Ojit</code>
  from working on Windows, leading to crashes.

<p></p>
</li>
<li>Fixed a corner case in the JIT's optimizer, leading to <code>Fatal
  RPython error: AssertionError</code>.

<p></p>
</li>
<li>Added some missing built-in functions into the 'os' module.

<p></p>
</li>
<li>Fix ctypes (it was not propagating keepalive information from
  c_void_p).

</li>
</ul>
</div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-2880852156055558428">
        <div class="comment-header">
          <a name="comment-2880852156055558428"></a>
            <span class="author">Symbol</span> wrote on <span class="date">2010-12-22 12:00</span>:
        </div>
        <div class="comment-content">
          <p>Wow, and I thought 1.4.1 would come out after the january sprint!<br><br>A christmas present :-&gt;<br><br>What would be the focus of the january sprint then?</p>
        </div>
      </div>
      <div class="comment comment-5883098760174928811">
        <div class="comment-header">
          <a name="comment-5883098760174928811"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2010-12-22 12:09</span>:
        </div>
        <div class="comment-content">
          <p>There are still a number of branches that have not been merged into trunk yet: at least fast-forward (Python 2.7), jit-unroll-loops (better JITting of arithmetic and short loops), arm-backend (JIT support on ARM) and jitypes2 (turn ctypes calls into real assembler-level calls with the JIT).  There is also the stackless+JIT integration pending.  Finally the sprint will also be a place to try out and run some applications.  So it's not like we are out of work :-)</p>
        </div>
      </div>
      <div class="comment comment-3610426926403976377">
        <div class="comment-header">
          <a name="comment-3610426926403976377"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2010-12-22 13:10</span>:
        </div>
        <div class="comment-content">
          <p>I'm interested in the performance improvement in hashlib.sha. I haven't seen that one before on https://speed.pypy.org . Could you give me more details?<br><br>Regards,<br><br>Zooko</p>
        </div>
      </div>
      <div class="comment comment-4797366353383177413">
        <div class="comment-header">
          <a name="comment-4797366353383177413"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2010-12-22 13:59</span>:
        </div>
        <div class="comment-content">
          <p>Actually, hashlib.sha was not the same as sha.sha: the former used to be a ctypes call to the OpenSSL lib, whereas the latter uses our built-in sha implementation.  So hashlib.sha was faster in theory, but killed by the overhead of using ctypes.  Now, at least in a default version of pypy, the hashlib.md5 and .sha are redirected to the built-in md5.md5 and sha.sha.<br><br>Another issue was that with the built-in md5.md5 and sha.sha, on 64-bit, there was a 1.5x speed impact due to the C compiler not recognizing an expression that was meant to be a 32-bit integer rotation.<br><br>I guess that https://speed.pypy.org don't show this because they use directly md5.md5 or sha.sha, and are on 32-bit.</p>
        </div>
      </div>
      <div class="comment comment-5475020352054044245">
        <div class="comment-header">
          <a name="comment-5475020352054044245"></a>
            <span class="author">Martijn Faassen</span> wrote on <span class="date">2010-12-22 14:14</span>:
        </div>
        <div class="comment-content">
          <p>Thanks for PyPy 1.4.1. I reported two issues concerning buildout with PyPy 1.4, and they all got fixed! <br><br>So PyPy 1.4.1 is now compatible with buildout, which is really convenient as it makes it easy for me to test other projects.</p>
        </div>
      </div>
      <div class="comment comment-4083035285522330280">
        <div class="comment-header">
          <a name="comment-4083035285522330280"></a>
            <span class="author">shadinger</span> wrote on <span class="date">2010-12-28 16:00</span>:
        </div>
        <div class="comment-content">
          <p>I compiled 1.4.1 on Win32 using Visual C++ 2010.<br><br>Do you want to add it to the download page?<br><br>To whom shall I send it?<br><br>Happy new year.</p>
        </div>
      </div>
      <div class="comment comment-1642792927045800257">
        <div class="comment-header">
          <a name="comment-1642792927045800257"></a>
            <span class="author">Andrei</span> wrote on <span class="date">2011-01-28 20:08</span>:
        </div>
        <div class="comment-content">
          <p>Hello,<br><br>sorry, I'm a bit new here - is it possible that PyPy makes Python run in a browser? Somehow "translating" all the Python into Javascript?<br><br>I'm wondering because I saw you run, for example, CLI, so perhaps PyPy may somehow enable Python in a browser?</p>
        </div>
      </div>
      <div class="comment comment-463478429396879292">
        <div class="comment-header">
          <a name="comment-463478429396879292"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2011-01-29 10:23</span>:
        </div>
        <div class="comment-content">
          <p>Andrei: not directly.  We played at some point with translating RPython code to Javascript, but it didn't give enough benefits (because it's not full Python that we can translate, just "RPython").  The alternative would be to translate the whole PyPy interpreter to Javascript, but that would give a result that is both huge (in term of download size) and horribly slow (100x slower than Javascript maybe).</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/12/pypy-migrates-to-mercurial-3308736161543832134.html" class="u-url">PyPy migrates to Mercurial</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/antonio-cuni.html">Antonio Cuni</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/12/pypy-migrates-to-mercurial-3308736161543832134.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-12-14T16:45:00Z" itemprop="datePublished" title="2010-12-14 16:45">2010-12-14 16:45</time></a>
            </p>
                <p class="commentline">6 comments</p>

        </div>
    </header><div class="p-summary entry-summary">
    <p>The assiduous readers of this blog surely remember that during the last
<a class="reference external" href="../posts/2010/10/dusseldorf-sprint-report-2010-371223200425847723.html">Düsseldorf sprint</a> in October, we started the process for migrating our main
development repository from Subversion to Mercurial.  Today, after more than
two months, the process has finally been completed :-).</p>
<p>The new official PyPy repository is hosted on <a class="reference external" href="https://bitbucket.org/pypy/pypy">BitBucket</a>.</p>
<p>The migration has been painful because the SVN history of PyPy was a mess and
none of the existing conversion tools could handle it correctly.  This was
partly because PyPy started when subversion was still at version 0.9 when some
best-practices were still to be established, and partly because we probably
managed to invent all the possible ways to do branches (and even some of the
impossible ones: there is at least one commit which you cannot do with the
plain SVN client but you have to speak to the server by yourself :-)).</p>
<p>The actual conversion was possible thanks to the enormous work done by Ronny
Pfannschmidt and his <a class="reference external" href="https://bitbucket.org/RonnyPfannschmidt/hackbeil">hackbeil</a> tool. I would like to personally thank Ronny
for his patience to handle all the various requests we asked for.</p>
<p>We hope that PyPy development becomes even more approachable now, at least from
a version control point of view.</p>
    </div>
    </article><div class="comment-level comment-level-1">
      <div class="comment comment-8405733806817463578">
        <div class="comment-header">
          <a name="comment-8405733806817463578"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-12-14 20:19</span>:
        </div>
        <div class="comment-content">
          <p>Awesome! Besides simplifying life for potential new contributors, it's very nice to be able to follow progress using the shortlog on bitbucket.org.</p>
        </div>
      </div>
      <div class="comment comment-6441132259028110354">
        <div class="comment-header">
          <a name="comment-6441132259028110354"></a>
            <span class="author">Vladimir</span> wrote on <span class="date">2010-12-14 21:08</span>:
        </div>
        <div class="comment-content">
          <p>Over 9000 branches :/</p>
        </div>
      </div>
      <div class="comment comment-8802203330780342979">
        <div class="comment-header">
          <a name="comment-8802203330780342979"></a>
            <span class="author">Antonio Cuni</span> wrote on <span class="date">2010-12-14 22:34</span>:
        </div>
        <div class="comment-content">
          <p>@Владимир: 9000? I count 459 on my local repo, which is still a lot, but not so much :-)<br>Anyway, most of them are closed, it's just that bitbucket displays also those. And I think that the huge number of branches is another evidence of the "we are not heroes" thing :-)<br>https://morepypy.blogspot.com/2010/12/we-are-not-heroes-just-very-patient.html</p>
        </div>
      </div>
      <div class="comment comment-6614010711275289654">
        <div class="comment-header">
          <a name="comment-6614010711275289654"></a>
            <span class="author">Michael Foord</span> wrote on <span class="date">2010-12-15 01:38</span>:
        </div>
        <div class="comment-content">
          <p>Hey, you guys are *my* heroes. :-)</p>
        </div>
      </div>
      <div class="comment comment-5110373621431415198">
        <div class="comment-header">
          <a name="comment-5110373621431415198"></a>
            <span class="author">Leonardo Santagada</span> wrote on <span class="date">2010-12-15 13:03</span>:
        </div>
        <div class="comment-content">
          <p>"PyPy is faster than CPython, again" should be the title. Faster at migrating to mercurial <br><br>:)<br><br>Great work, now pypy could be even more self hosting if it would run hg on it, when it becomes faster than cpython and stable to do so.</p>
        </div>
      </div>
      <div class="comment comment-430888139854833186">
        <div class="comment-header">
          <a name="comment-430888139854833186"></a>
            <span class="author">Bernhard Leiner</span> wrote on <span class="date">2010-12-15 20:28</span>:
        </div>
        <div class="comment-content">
          <p>PyPy running Mercurial is actually not to far away...<br><br>https://markmail.org/message/wjik2ecanvmt463y#query:+page:1+mid:qbdxn3566j2y7piu+state:results</p>
        </div>
      </div>
         </div>

    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/2010/12/oh-and-btw-pypy-gets-funding-through-3568486750776147382.html" class="u-url">Oh, and btw: PyPy gets funding through "Eurostars"</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="../authors/armin-rigo.html">Armin Rigo</a>
            </span></p>
            <p class="dateline">
            <a href="../posts/2010/12/oh-and-btw-pypy-gets-funding-through-3568486750776147382.html" rel="bookmark">
            <time class="published dt-published" datetime="2010-12-10T16:28:00Z" itemprop="datePublished" title="2010-12-10 16:28">2010-12-10 16:28</time></a>
            </p>
            
        </div>
    </header><div class="p-summary entry-summary">
    <p>There is a supporting reason why we made so many advances in the last year:
funding through <a class="reference" href="https://www.eurostars-eureka.eu/">Eurostars</a>, a European research funding program.
The title of our proposal (accepted in 2009) is: "PYJIT - a fast
and flexible toolkit for dynamic programming languages based on PyPy".
And the participants are <a class="reference" href="https://www.openend.se/">Open End AB</a>, the <a class="reference" href="https://www.uni-duesseldorf.de/">Heinrich-Heine-Universität
Düsseldorf</a> (HHU), and <a class="reference" href="https://www.merlinux.de/">merlinux GmbH</a>.</p>
<p>It's not hard to guess what PYJIT is actually about, is it?
Quoting: "The PYJIT project will deliver a fast and flexible
Just-In-Time Compiler toolkit based on PyPy to the market of dynamic
languages.  Our main aim is to showcase our project's results for the
Open Source language Python, providing unprecedented levels of
flexibility and with speed hitherto only available using statically
typed languages." (Details <a href="https://www.stups.uni-duesseldorf.de/projects.php">in German</a> or <a href="https://www.vinnova.se/PageFiles/38789/ppt/Beatrice_During.pdf">in Swedish</a> :-)</p>
<p>A subgoal is to improve our development and testing infrastructure,
mainly showcased by Holger's recent <a class="reference" href="https://pytest.org/">py.test</a> releases, the testing tool
used by PyPy for its <a class="reference" href="https://buildbot.pypy.org/summary">16K tests</a> and the <a class="reference" href="https://speed.pypy.org/">speed.pypy.org</a> infrastructure
(web app programmed by Miquel Torres on his own time).</p>
<p>The overall scope of this project is smaller than that of the previous EU project
from 2004 to 2007.  The persons that are (or were) getting money to work
on PyPy are Samuele Pedroni (at Open End), Maciej Fijalkowski (as a
subcontractor), Carl Friedrich Bolz, Armin Rigo, Antonio Cuni (all at
HHU), and Holger Krekel (at merlinux) as well as Ronny Pfannschmidt (as
a subcontractor).</p>
<p>The Eurostars funding lasts until August 2011.  What comes afterwards?
Well, for one, many of the currently funded people have done work without
getting funding in previous years.  This will probably continue.
We also have non-funded people in the core group right now and we'll
hope to enlarge it further.  But of course there are still large tasks
ahead which may greatly benefit from funding.  We have setup a
<a class="reference" href="https://pypy.org/">donation</a> infrastructure and maybe we can win one or more larger
organisations to provide higher or regular sums of money to fund future
development work.   Another possibility for companies is to pay
PyPy developers to help and improve PyPy for their particular use cases.</p>
<p>And finally, your help, donations and suggestions are always
welcome and overall we hope to convince more and more people it's
worthwhile to invest into PyPy's future.</p>
    </div>
    </article>
</div>
</div>
<div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/12/toy-load-store.html" class="listtitle">Load and store forwarding in the Toy Optimizer</a>
      </li>
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (9)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (6)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div></div>
</main>
</div>
<div style="clear: both; width: 75%; margin: 1em auto;">
        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-18.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-16.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
         
                 <footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    © 2026 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
     
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
     
    Last built 2026-01-17T00:22
  </div>
  <div style="margin-left: auto">
  <a href="../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../assets/js/styles.js"></script></footer>
</body>
</html>