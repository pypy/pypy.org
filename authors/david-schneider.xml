<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts by David Schneider)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/authors/david-schneider.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Mon, 07 Jul 2025 11:01:29 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>PyPy 2.1 - Considered ARMful</title><link>https://www.pypy.org/posts/2013/08/pypy-21-considered-armful-7177475722033479233.html</link><dc:creator>David Schneider</dc:creator><description>&lt;p&gt;We're pleased to announce PyPy 2.1, which targets version 2.7.3 of the Python&lt;br&gt;
language. This is the first release with official support for ARM processors in the JIT.&lt;br&gt;
This release also contains several bugfixes and performance improvements.&lt;/p&gt;&lt;p&gt;You can download the PyPy 2.1 release here:&lt;/p&gt;&lt;blockquote&gt;&lt;a class="reference external" href="https://pypy.org/download.html"&gt;https://pypy.org/download.html&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;We would like to thank the &lt;a class="reference external" href="https://www.raspberrypi.org"&gt;Raspberry Pi Foundation&lt;/a&gt; for supporting the work&lt;br&gt;
to finish PyPy's ARM support.&lt;/p&gt;&lt;p&gt;The first beta of PyPy3 2.1, targeting version 3 of the Python language, was&lt;br&gt;
just released, more details can be found &lt;a class="reference external" href="https://www.pypy.org/posts/2013/07/pypy3-21-beta-1-8647445024868663902.html"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;div class="section" id="what-is-pypy"&gt;&lt;br&gt;
&lt;h3&gt;What is PyPy?&lt;/h3&gt;&lt;p&gt;PyPy is a very compliant Python interpreter, almost a drop-in replacement for
CPython 2.7. It's fast (&lt;a class="reference external" href="https://speed.pypy.org"&gt;pypy 2.1 and cpython 2.7.2&lt;/a&gt; performance comparison)
due to its integrated tracing JIT compiler.&lt;/p&gt;&lt;p&gt;This release supports x86 machines running Linux 32/64, Mac OS X 64 or Windows
32. This release also supports ARM machines running Linux 32bit - anything with
&lt;tt class="docutils literal"&gt;ARMv6&lt;/tt&gt; (like the Raspberry Pi) or &lt;tt class="docutils literal"&gt;ARMv7&lt;/tt&gt; (like the Beagleboard,
Chromebook, Cubieboard, etc.) that supports &lt;tt class="docutils literal"&gt;VFPv3&lt;/tt&gt; should work. Both
hard-float &lt;tt class="docutils literal"&gt;armhf/gnueabihf&lt;/tt&gt; and soft-float &lt;tt class="docutils literal"&gt;armel/gnueabi&lt;/tt&gt; builds are
provided. The &lt;tt class="docutils literal"&gt;armhf&lt;/tt&gt; builds for Raspbian are created using the Raspberry Pi
&lt;a class="reference external" href="https://github.com/raspberrypi"&gt;custom cross-compilation toolchain&lt;/a&gt;
based on &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;gcc-arm-linux-gnueabihf&lt;/span&gt;&lt;/tt&gt; and should work on &lt;tt class="docutils literal"&gt;ARMv6&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;ARMv7&lt;/tt&gt; devices running Debian or Raspbian. The &lt;tt class="docutils literal"&gt;armel&lt;/tt&gt; builds are built
using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;gcc-arm-linux-gnuebi&lt;/span&gt;&lt;/tt&gt; toolchain provided by Ubuntu and
currently target &lt;tt class="docutils literal"&gt;ARMv7&lt;/tt&gt;.&lt;/p&gt;&lt;p&gt;Windows 64 work is still stalling, we would welcome a volunteer
to handle that.&lt;/p&gt;&lt;/div&gt;&lt;div class="section" id="highlights"&gt;&lt;h3&gt;Highlights&lt;/h3&gt;&lt;ul class="simple"&gt;&lt;li&gt;JIT support for ARM, architecture versions 6 and 7, hard- and soft-float ABI&lt;/li&gt;
&lt;li&gt;Stacklet support for ARM&lt;/li&gt;
&lt;li&gt;Support for os.statvfs and os.fstatvfs on unix systems&lt;/li&gt;
&lt;li&gt;Improved logging performance&lt;/li&gt;
&lt;li&gt;Faster sets for objects&lt;/li&gt;
&lt;li&gt;Interpreter improvements&lt;/li&gt;
&lt;li&gt;During packaging, compile the CFFI based TK extension&lt;/li&gt;
&lt;li&gt;Pickling of numpy arrays and dtypes&lt;/li&gt;
&lt;li&gt;Subarrays for numpy&lt;/li&gt;
&lt;li&gt;Bugfixes to numpy&lt;/li&gt;
&lt;li&gt;Bugfixes to cffi and ctypes&lt;/li&gt;
&lt;li&gt;Bugfixes to the x86 stacklet support&lt;/li&gt;
&lt;li&gt;Fixed issue &lt;a class="reference external" href="https://bugs.pypy.org/issue1533"&gt;1533&lt;/a&gt;: fix an RPython-level OverflowError for space.float_w(w_big_long_number).&lt;/li&gt;
&lt;li&gt;Fixed issue &lt;a class="reference external" href="https://bugs.pypy.org/issue1552"&gt;1552&lt;/a&gt;: GreenletExit should inherit from BaseException.&lt;/li&gt;
&lt;li&gt;Fixed issue &lt;a class="reference external" href="https://bugs.pypy.org/issue1537"&gt;1537&lt;/a&gt;: numpypy __array_interface__&lt;/li&gt;
&lt;li&gt;Fixed issue &lt;a class="reference external" href="https://bugs.pypy.org/issue1238"&gt;1238&lt;/a&gt;: Writing to an SSL socket in PyPy sometimes failed with a "bad write retry" message.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Cheers,&lt;/p&gt;&lt;p&gt;David Schneider for the PyPy team.&lt;/p&gt;&lt;/div&gt;</description><guid>https://www.pypy.org/posts/2013/08/pypy-21-considered-armful-7177475722033479233.html</guid><pubDate>Thu, 01 Aug 2013 14:38:00 GMT</pubDate></item><item><title>PyPy 2.1 beta 2</title><link>https://www.pypy.org/posts/2013/07/pypy-21-beta-2-264349571160808803.html</link><dc:creator>David Schneider</dc:creator><description>&lt;p&gt;We're pleased to announce the second beta of the upcoming 2.1 release of PyPy.&lt;br&gt;
This beta adds one new feature to the 2.1 release and contains several bugfixes listed below.&lt;/p&gt;&lt;p&gt;You can download the PyPy 2.1 beta 2 release here:&lt;/p&gt;&lt;blockquote&gt;&lt;a class="reference external" href="https://pypy.org/download.html"&gt;https://pypy.org/download.html&lt;/a&gt;&lt;/blockquote&gt;&lt;div class="section" id="highlights"&gt;&lt;h3&gt;Highlights&lt;/h3&gt;&lt;ul class="simple"&gt;&lt;li&gt;Support for os.statvfs and os.fstatvfs on unix systems.&lt;/li&gt;
&lt;li&gt;Fixed issue &lt;a class="reference external" href="https://bugs.pypy.org/issue1533"&gt;1533&lt;/a&gt;: fix an RPython-level OverflowError for space.float_w(w_big_long_number).&lt;/li&gt;
&lt;li&gt;Fixed issue &lt;a class="reference external" href="https://bugs.pypy.org/issue1552"&gt;1552&lt;/a&gt;: GreenletExit should inherit from BaseException.&lt;/li&gt;
&lt;li&gt;Fixed issue &lt;a class="reference external" href="https://bugs.pypy.org/issue1537"&gt;1537&lt;/a&gt;: numpypy __array_interface__&lt;/li&gt;
&lt;li&gt;Fixed issue &lt;a class="reference external" href="https://bugs.pypy.org/issue1238"&gt;1238&lt;/a&gt;: Writing to an SSL socket in pypy sometimes failed with a "bad write retry" message.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bitbucket.org/pypy/pypy/src/0c6eeae0316c11146f47fcf83e21e24f11378be1/?at=distutils-cppldflags"&gt;distutils&lt;/a&gt;: copy CPython's implementation of customize_compiler, dont call&lt;br&gt;
split on environment variables, honour CFLAGS, CPPFLAGS, LDSHARED and&lt;br&gt;
LDFLAGS.&lt;/li&gt;
&lt;li&gt;During packaging, compile the CFFI tk extension.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;div class="section" id="what-is-pypy"&gt;&lt;h3&gt;What is PyPy?&lt;/h3&gt;&lt;p&gt;PyPy is a very compliant Python interpreter, almost a drop-in replacement for&lt;br&gt;
CPython 2.7.3. It's fast due to its integrated tracing JIT compiler.&lt;/p&gt;&lt;p&gt;This release supports x86 machines running Linux 32/64, Mac OS X 64 or Windows&lt;br&gt;
32. Also this release supports ARM machines running Linux 32bit - anything with&lt;br&gt;
&lt;tt class="docutils literal"&gt;ARMv6&lt;/tt&gt; (like the Raspberry Pi) or &lt;tt class="docutils literal"&gt;ARMv7&lt;/tt&gt; (like Beagleboard,&lt;br&gt;
Chromebook, Cubieboard, etc.) that supports &lt;tt class="docutils literal"&gt;VFPv3&lt;/tt&gt; should work.&lt;/p&gt;&lt;p&gt;Windows 64 work is still stalling, we would welcome a volunteer&lt;br&gt;
to handle that.&lt;/p&gt;&lt;/div&gt;&lt;div class="section" id="how-to-use-pypy"&gt;&lt;h3&gt;How to use PyPy?&lt;/h3&gt;&lt;p&gt;We suggest using PyPy from a &lt;a class="reference external" href="https://www.virtualenv.org/en/latest/"&gt;virtualenv&lt;/a&gt;. Once you have a virtualenv&lt;br&gt;
installed, you can follow instructions from &lt;a class="reference external" href="https://doc.pypy.org/en/latest/getting-started.html#installing-using-virtualenv"&gt;pypy documentation&lt;/a&gt; on how&lt;br&gt;
to proceed. This document also covers other &lt;a class="reference external" href="https://doc.pypy.org/en/latest/getting-started.html#installing-pypy"&gt;installation schemes&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Cheers,&lt;br&gt;
The PyPy Team.&lt;/p&gt;&lt;/div&gt;</description><guid>https://www.pypy.org/posts/2013/07/pypy-21-beta-2-264349571160808803.html</guid><pubDate>Fri, 26 Jul 2013 10:33:00 GMT</pubDate></item><item><title>PyPy 2.1 beta</title><link>https://www.pypy.org/posts/2013/07/pypy-21-beta-1351105697755187196.html</link><dc:creator>David Schneider</dc:creator><description>&lt;p&gt;We're pleased to announce the first beta of the upcoming 2.1 release of PyPy. This beta contains many bugfixes and improvements, numerous improvements to the numpy in pypy effort. The main feature being that the ARM processor support is not longer considered alpha level.&lt;br&gt;
&lt;br&gt;
We would like to thank the &lt;a class="reference external" href="https://www.raspberrypi.org/"&gt;Raspberry Pi Foundation&lt;/a&gt; for supporting the work to finish PyPy's ARM support.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
You can download the PyPy 2.1 beta release here:&lt;br&gt;
&lt;/p&gt;&lt;blockquote&gt;
&lt;a class="reference external" href="https://pypy.org/download.html"&gt;https://pypy.org/download.html&lt;/a&gt;&lt;/blockquote&gt;
&lt;div class="section" id="highlights"&gt;
&lt;h3&gt;
&lt;br&gt;&lt;/h3&gt;
&lt;h3&gt;
Highlights&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Bugfixes to the ARM JIT backend, so that ARM is now an officially&lt;br&gt;
supported processor architecture&lt;/li&gt;
&lt;li&gt;Stacklet support on ARM&lt;/li&gt;
&lt;li&gt;Interpreter improvements&lt;/li&gt;
&lt;li&gt;Various numpy improvements&lt;/li&gt;
&lt;li&gt;Bugfixes to cffi and ctypes&lt;/li&gt;
&lt;li&gt;Bugfixes to the stacklet support&lt;/li&gt;
&lt;li&gt;Improved logging performance&lt;/li&gt;
&lt;li&gt;Faster sets for objects&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="what-is-pypy"&gt;
&lt;h3&gt;
&lt;br&gt;&lt;/h3&gt;
&lt;h3&gt;
What is PyPy?&lt;/h3&gt;
PyPy is a very compliant Python interpreter, almost a drop-in replacement for CPython 2.7.3. It's fast due to its integrated tracing JIT compiler. This release supports x86 machines running Linux 32/64, Mac OS X 64 or Windows 32. Also this release supports ARM machines running Linux 32bit - anything with &lt;tt class="docutils literal"&gt;ARMv6&lt;/tt&gt; (like the Raspberry Pi) or &lt;tt class="docutils literal"&gt;ARMv7&lt;/tt&gt; (like Beagleboard, Chromebook, Cubieboard, etc.) that supports &lt;tt class="docutils literal"&gt;VFPv3&lt;/tt&gt; should work. Both hard-float &lt;tt class="docutils literal"&gt;armhf/gnueabihf&lt;/tt&gt; and soft-float &lt;tt class="docutils literal"&gt;armel/gnueabi&lt;/tt&gt; builds are provided. &lt;tt class="docutils literal"&gt;armhf&lt;/tt&gt; builds for Raspbian are created using the Raspberry Pi&lt;br&gt;
&lt;a class="reference external" href="https://github.com/raspberrypi"&gt;custom cross-compilation toolchain&lt;/a&gt; based on &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;gcc-arm-linux-gnueabihf&lt;/span&gt;&lt;/tt&gt; and should work on &lt;tt class="docutils literal"&gt;ARMv6 &lt;/tt&gt;and &lt;tt class="docutils literal"&gt;ARMv7&lt;/tt&gt; devices running Debian or Raspbian. &lt;tt class="docutils literal"&gt;armel&lt;/tt&gt; builds are built using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;gcc-arm-linux-gnuebi&lt;/span&gt;&lt;/tt&gt; toolchain provided by Ubuntu and currently target &lt;tt class="docutils literal"&gt;ARMv7&lt;/tt&gt;.&lt;br&gt;
&lt;br&gt;
Windows 64 work is still stalling, we would welcome a volunteer to handle that.&lt;/div&gt;
&lt;div class="section" id="how-to-use-pypy"&gt;
&lt;h3&gt;
&lt;br&gt;&lt;/h3&gt;
&lt;h3&gt;
How to use PyPy?&lt;/h3&gt;
We suggest using PyPy from a &lt;a class="reference external" href="https://www.virtualenv.org/en/latest/"&gt;virtualenv&lt;/a&gt;. Once you have a virtualenv installed, you can follow instructions from &lt;a class="reference external" href="https://doc.pypy.org/en/latest/getting-started.html#installing-using-virtualenv"&gt;pypy documentation&lt;/a&gt; on how to proceed. This document also covers other &lt;a class="reference external" href="https://doc.pypy.org/en/latest/getting-started.html#installing-pypy"&gt;installation schemes&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;
Cheers,&lt;br&gt;
&lt;br&gt;
the PyPy team.&lt;/div&gt;</description><guid>https://www.pypy.org/posts/2013/07/pypy-21-beta-1351105697755187196.html</guid><pubDate>Thu, 11 Jul 2013 10:36:00 GMT</pubDate></item><item><title>Almost There - PyPy's ARM Backend</title><link>https://www.pypy.org/posts/2012/02/almost-there-pypys-arm-backend_01-3216759488618774525.html</link><dc:creator>David Schneider</dc:creator><description>&lt;div style="text-align: left;"&gt;
In this post I want to give an update on the status of the ARM backend for PyPy's JIT and describe some of the issues and details of the backend.&lt;/div&gt;
&lt;div class="section" id="current-status"&gt;
&lt;br&gt;
&lt;h2&gt;




Current Status&lt;/h2&gt;
It has been a more than a year that I have been working on the ARM backend. Now it is in a shape, that we can measure meaningful numbers and also ask for some feedback. Since the &lt;a class="reference external" href="https://www.pypy.org/posts/2011/01/jit-backend-for-arm-processors-5994810755839586463.html"&gt;last post about the backend&lt;/a&gt; we have added support floating point operations as well as for PyPy's framework GC's. Another area of work was to keep up with the constant improvements done in the main development branch, such as out-of-line guards, labels, etc. It has been possible for about a year to cross-translate the PyPy Python interpreter and other interpreters such as &lt;a class="reference external" href="https://bitbucket.org/cfbolz/pyrolog/"&gt;Pyrolog&lt;/a&gt;, with a JIT, to run benchmarks on ARM. Up until now there remained some hard to track bugs that would cause the interpreter to crash with a segmentation fault in certain cases when running with the JIT on ARM. Lately it was possible to run all benchmarks without problems, but when running the translation toolchain itself it would crash. During the last PyPy sprint in &lt;a class="reference external" href="https://www.pypy.org/posts/2011/12/leysin-winter-sprint-6862532189897876336.html"&gt;Leysin&lt;/a&gt; Armin and I managed to fix several of these hard to track bugs in the ARM backend with the result that, it is now possible to run the PyPy translator on ARM itself (at least unless until it runs out of memory), which is a kind of litmus test for the backend itself and used to crash before. Just to point it out, we are not able to complete a PyPy translation on ARM, because on the hardware we have currently available there is not enough memory. But up to the point we run out of memory the JIT does not hit any issues.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="implementation-details"&gt;
&lt;h2&gt;




Implementation Details&lt;/h2&gt;
The hardware requirements to run the JIT on ARM follow those for Ubuntu on ARM which targets ARMv7 with a VFP unit running in little endian mode. The JIT can be translated without floating point support, but there might be a few places that need to be fixed to fully work in this setting. We are targeting the ARM instruction set, because at least at the time we decided to use it seemed to be the best choice in terms of speed while having some size overhead compared to the Thumb2 instruction set. It appears that the Thumb2 instruction set should give comparable speed with better code density but has a few restriction on the number of registers available and the use of conditional execution. Also the implementation is a bit easier using a fixed width instruction set and we can use the full set of registers in the generated code when using the ARM instruction set.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="the-calling-convention-on-arm"&gt;
&lt;h2&gt;




The calling convention on ARM&lt;/h2&gt;
The calling convention on ARM uses 4 of the general purpose registers to pass arguments to functions, further arguments are passed on the stack. The presence of a floating point unit is not required for ARM cores, for this reason there are different ways of handling floats with relation to the calling convention. There is a so called soft-float calling convention that is independent of the presence of a floating point unit. For this calling convention floating point arguments to functions are stored in the general purpose registers and on the stack. Passing floats around this way works with software and hardware floating point implementations. But in presence of a floating point unit it produces some overhead, because floating point numbers need to be moved from the floating point unit to the core registers to do a call and moved back to the floating point registers by the callee. The alternative calling convention is the so-called hard-float calling convention which requires the presence of a floating point unit but has the advantage of getting rid of the overhead of moving floating point values around when performing a call. Although it would be better in the long term to support the hard-float calling convention, we need to be able to interoperate with external code compiled for the operating system we are running on. For this reason at the moment we only support the soft-float to interoperate with external code. We implemented and tested the backend on a &lt;a class="reference external" href="https://beagleboard.org/hardware-xM/"&gt;BeagleBoard-xM&lt;/a&gt; with a &lt;a class="reference external" href="https://www.arm.com/products/processors/cortex-a/cortex-a8.php"&gt;Cortex-A8&lt;/a&gt; processor running &lt;a class="reference external" href="https://wiki.ubuntu.com/ARM"&gt;Ubuntu 11.04 for ARM&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="translating-for-arm"&gt;
&lt;h2&gt;




Translating for ARM&lt;/h2&gt;
The toolchain used to translate PyPy currently is based on a &lt;a class="reference external" href="https://maemo.gitorious.org/scratchbox2/pages/Home"&gt;Scratchbox2&lt;/a&gt;. Scratchbox2 is a cross-compiling environment. Development had stopped for a while, but it seems to have revived again. We run a 32-bit Python interpreter on the host system and perform all calls to the compiler using a Scratchbox2 based environment. A description on how to setup the cross translation toolchain can be found &lt;a class="reference external" href="https://bitbucket.org/pypy/pypy/src/1f07ea8076c9/pypy/doc/arm.rst"&gt;here&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="results"&gt;
&lt;h2&gt;




Results&lt;/h2&gt;
The current results on ARM, as shown in the graph below, show that the JIT currently gives a speedup of about 3.5 times compared to CPython on ARM. The benchmarks were run on the before mentioned BeagleBoard-xM with a 1GHz ARM Cortex-A8 processor and 512MB of memory. The operating system on the board is Ubuntu 11.04 for ARM. We measured the PyPy interpreter with the JIT enabled and disabled comparing each to CPython Python 2.7.1+ (r271:86832) for ARM. The graph shows the speedup or slowdown of both PyPy versions for the different benchmarks from our benchmark suite normalized to the runtime of CPython. The data used for the graph can be seen below.&lt;br&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="https://2.bp.blogspot.com/-uckc9tOWgnM/TykHMuuGT9I/AAAAAAAAAKg/J8_fC6RS-QA/s1600/graph.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="258" src="https://2.bp.blogspot.com/-uckc9tOWgnM/TykHMuuGT9I/AAAAAAAAAKg/J8_fC6RS-QA/s400/graph.png" width="400"&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br&gt;
The speedup is less than the speedup of 5.2 times we currently  get on x86 on our own benchmark suite (see &lt;a class="reference external" href="https://speed.pypy.org/"&gt;https://speed.pypy.org&lt;/a&gt; for details). There are several possible reasons for this. Comparing the results for the interpreter without the JIT on ARM and x86 suggests that the interpreter generated by PyPy, without the JIT, has a worse performance when compared to CPython that it does on x86. Also it is quite possible that the code we are generating with the JIT is not yet optimal. Also there are some architectural constraints produce some overhead. One of these differences is the handling of constants, most ARM instructions only support 8 bit (that can be shifted) immediate values, larger constants need to be loaded into a register, something that is not necessary on x86.&lt;br&gt;
&lt;br&gt;
&lt;table border="1" class="docutils"&gt;&lt;colgroup&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="40%"&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="32%"&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="28%"&gt;&lt;/colgroup&gt;&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Benchmark&lt;/td&gt;&lt;td&gt;PyPy JIT&lt;/td&gt;&lt;td&gt;PyPy no JIT&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ai&lt;/td&gt;&lt;td&gt;0.484439780047&lt;/td&gt;&lt;td&gt;3.72756749625&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;chaos&lt;/td&gt;&lt;td&gt;0.0807291691934&lt;/td&gt;&lt;td&gt;2.2908692212&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;crypto_pyaes&lt;/td&gt;&lt;td&gt;0.0711114832245&lt;/td&gt;&lt;td&gt;3.30112318509&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;django&lt;/td&gt;&lt;td&gt;0.0977743245519&lt;/td&gt;&lt;td&gt;2.56779947601&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;fannkuch&lt;/td&gt;&lt;td&gt;0.210423735698&lt;/td&gt;&lt;td&gt;2.49163632938&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;float&lt;/td&gt;&lt;td&gt;0.154275334675&lt;/td&gt;&lt;td&gt;2.12053281495&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;go&lt;/td&gt;&lt;td&gt;0.330483034202&lt;/td&gt;&lt;td&gt;5.84628320479&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;html5lib&lt;/td&gt;&lt;td&gt;0.629264389862&lt;/td&gt;&lt;td&gt;3.60333138526&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;meteor-contest&lt;/td&gt;&lt;td&gt;0.984747426912&lt;/td&gt;&lt;td&gt;2.93838610037&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;nbody_modified&lt;/td&gt;&lt;td&gt;0.236969593082&lt;/td&gt;&lt;td&gt;1.40027234936&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;pyflate-fast&lt;/td&gt;&lt;td&gt;0.367447191807&lt;/td&gt;&lt;td&gt;2.72472422146&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;raytrace-simple&lt;/td&gt;&lt;td&gt;0.0290527461437&lt;/td&gt;&lt;td&gt;1.97270054339&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;richards&lt;/td&gt;&lt;td&gt;0.034575573553&lt;/td&gt;&lt;td&gt;3.29767342015&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;slowspitfire&lt;/td&gt;&lt;td&gt;0.786642551908&lt;/td&gt;&lt;td&gt;3.7397367403&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spambayes&lt;/td&gt;&lt;td&gt;0.660324379456&lt;/td&gt;&lt;td&gt;3.29059863111&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spectral-norm&lt;/td&gt;&lt;td&gt;0.063610783731&lt;/td&gt;&lt;td&gt;4.01788986233&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spitfire&lt;/td&gt;&lt;td&gt;0.43617131165&lt;/td&gt;&lt;td&gt;2.72050579076&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spitfire_cstringio&lt;/td&gt;&lt;td&gt;0.255538702134&lt;/td&gt;&lt;td&gt;1.7418593111&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;telco&lt;/td&gt;&lt;td&gt;0.102918930413&lt;/td&gt;&lt;td&gt;3.86388866047&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_iteration&lt;/td&gt;&lt;td&gt;0.122723986805&lt;/td&gt;&lt;td&gt;4.33632475491&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_names&lt;/td&gt;&lt;td&gt;2.42367797135&lt;/td&gt;&lt;td&gt;2.99878698076&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_pb&lt;/td&gt;&lt;td&gt;1.30991837431&lt;/td&gt;&lt;td&gt;4.48877805486&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_tcp&lt;/td&gt;&lt;td&gt;0.927033354055&lt;/td&gt;&lt;td&gt;2.8161624665&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;waf&lt;/td&gt;&lt;td&gt;1.02059811932&lt;/td&gt;&lt;td&gt;1.03793427321&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;div class="section" id="the-next-steps-and-call-for-help"&gt;
&lt;h2&gt;




The next steps and call for help&lt;/h2&gt;
Although there probably still are some remaining issues which have not surfaced yet, the JIT backend for ARM is working. Before we can merge the backend into the main development line there are some things that we would like to do first, in particular it we are looking for a way to run the all PyPy tests to verify that things work on ARM before we can merge. Additionally there are some other longterm ideas. To do this we are looking for people willing to help, either by contributing to implement the open features or that can help us with hardware to test.&lt;br&gt;
&lt;br&gt;
The incomplete list of open topics:&lt;br&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;We are looking for a better way to translate PyPy for ARM, than the one describe above. I am not sure if there currently is hardware with enough memory to directly translate PyPy on an ARM based system, this would require between 1.5 or 2 Gig of memory. A fully &lt;a class="reference external" href="https://wiki.qemu.org/Main_Page"&gt;QEMU&lt;/a&gt; based approach could also work, instead of Scratchbox2 that uses QEMU under the hood.&lt;/li&gt;
&lt;li&gt;Test the JIT on different hardware.&lt;/li&gt;
&lt;li&gt;Experiment with the JIT settings to find the optimal thresholds for ARM.&lt;/li&gt;
&lt;li&gt;Continuous integration: We are looking for a way to run the PyPy test suite to make sure everything works as expected on ARM, here QEMU also might provide an alternative.&lt;/li&gt;
&lt;li&gt;A long term plan would be to port the backend to ARMv5 ISA and improve the support for systems without a floating point unit. This would require to implement the ISA and create different code paths and improve the instruction selection depending on the target architecture.&lt;/li&gt;
&lt;li&gt;Review of the generated machine code the JIT generates on ARM to see if the instruction selection makes sense for ARM.&lt;/li&gt;
&lt;li&gt;Build a version that runs on Android.&lt;/li&gt;
&lt;li&gt;Improve the tools, i.e. integrate with &lt;a class="reference external" href="https://bitbucket.org/pypy/jitviewer"&gt;jitviewer&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
So if you are interested or willing to help in any way contact us.&lt;/div&gt;</description><category>arm</category><category>jit</category><category>pypy</category><guid>https://www.pypy.org/posts/2012/02/almost-there-pypys-arm-backend_01-3216759488618774525.html</guid><pubDate>Wed, 01 Feb 2012 09:43:00 GMT</pubDate></item><item><title>A JIT Backend for ARM Processors</title><link>https://www.pypy.org/posts/2011/01/jit-backend-for-arm-processors-5994810755839586463.html</link><dc:creator>David Schneider</dc:creator><description>&lt;div class="document" id="a-jit-backend-for-arm-processors"&gt;
In the past few months, I have been developing as a part of my master thesis
the ARM backend for the the PyPy JIT, in the &lt;a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/tree/branch/arm-backend-2"&gt;arm-backend&lt;/a&gt; branch. Currently, it is still work in progress: all integer and object operations are working and
the support for &lt;a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/tree/branch/arm-backed-float"&gt;floating point&lt;/a&gt; is also under development.&lt;br&gt;
ARM processors are very widely used, being deployed in servers, some netbooks
and mainly mobile devices such as phones and tablets. One of our goals is to be
able to run PyPy on phones, specially on Android. Currently is not yet possible
to translate and compile PyPy for Android automatically, but there has been
some &lt;a class="reference external" href="https://pyppet.blogspot.com/2011/01/android-and-rpython.html"&gt;work&lt;/a&gt;  on using Android's NDK to compile PyPy's generated C code.&lt;br&gt;
The JIT Backend targets the application profile of the ARMv7 instruction set
architecture which is found for example in the Cortex-A8 processors used in many Android powered devices and in Apple's &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Apple_A4"&gt;A4 processors&lt;/a&gt; built into the latest iOS devices. To develop and
test the backend we are using a &lt;a class="reference external" href="https://beagleboard.org/hardware-xM"&gt;BeagleBoard-xM&lt;/a&gt; which has a 1 GHz ARM
Cortex-A8 and 512 MB of RAM running the &lt;a class="reference external" href="https://wiki.ubuntu.com/ARM"&gt;ARM port&lt;/a&gt; of Ubuntu 10.10.&lt;br&gt;
Currently on Linux it is possible to translate and cross-compile PyPy's Python
interpreter as well as other interpreters with the ARM JIT backend enabled
using Scratchbox 2 to provide a build environment and the GNU ARM cross
compilation toolchain. So far the backend only supports the &lt;a class="reference external" href="https://www.hpl.hp.com/personal/Hans_Boehm/gc/"&gt;Boehm&lt;/a&gt; garbage
collector which does not produce the best results combined with the JIT, but we
plan to add support for the other GCs in the future, doing so should increase
the performance of PyPy on ARM.&lt;br&gt;
While still debugging the last issues with the backend we already can run some
simple benchmarks on &lt;a class="reference external" href="https://bitbucket.org/cfbolz/pyrolog"&gt;Pyrolog&lt;/a&gt;, a prolog interpreter written in RPython.
Even using Boehm as the GC the results look very promising. In the benchmarks
we compare Pyrolog to &lt;a class="reference external" href="https://www.swi-prolog.org/"&gt;SWI-Prolog&lt;/a&gt;, a prolog interpreter written in C, which
is available from the package repositories for Ubuntu's ARM port.&lt;br&gt;
The benchmarks can be found in the &lt;a class="reference external" href="https://bitbucket.org/cfbolz/pyrolog-benchmark"&gt;pyrolog-bench&lt;/a&gt; repository.&lt;br&gt;
&lt;table border="1" class="docutils"&gt;&lt;colgroup&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="32%"&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="30%"&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="25%"&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="13%"&gt;&lt;/colgroup&gt;&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Benchmark&lt;/th&gt;&lt;th class="head"&gt;SWI-Prolog in ms.&lt;/th&gt;&lt;th class="head"&gt;Pyrolog in ms.&lt;/th&gt;&lt;th class="head"&gt;Speedup&lt;/th&gt;&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;iterate&lt;/td&gt;&lt;td&gt;60.0&lt;/td&gt;&lt;td&gt;6.0&lt;/td&gt;&lt;td&gt;10.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iterate_assert&lt;/td&gt;&lt;td&gt;130.0&lt;/td&gt;&lt;td&gt;6.0&lt;/td&gt;&lt;td&gt;21.67&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iterate_call&lt;/td&gt;&lt;td&gt;3310.0&lt;/td&gt;&lt;td&gt;5.0&lt;/td&gt;&lt;td&gt;662.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iterate_cut&lt;/td&gt;&lt;td&gt;60.0&lt;/td&gt;&lt;td&gt;359.0&lt;/td&gt;&lt;td&gt;0.16713&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iterate_exception&lt;/td&gt;&lt;td&gt;4950.0&lt;/td&gt;&lt;td&gt;346.0&lt;/td&gt;&lt;td&gt;14.306&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iterate_failure&lt;/td&gt;&lt;td&gt;400.0&lt;/td&gt;&lt;td&gt;127.0&lt;/td&gt;&lt;td&gt;3.1496&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iterate_findall&lt;/td&gt;&lt;td&gt;740.0&lt;/td&gt;&lt;td&gt;No res.&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iterate_if&lt;/td&gt;&lt;td&gt;140.0&lt;/td&gt;&lt;td&gt;6.0&lt;/td&gt;&lt;td&gt;23.333&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
The iterate_call benchmark, which constructs a predicate and calls it at
runtime, with a speedup of 662 times over SWI-Prolog is an example where the
JIT can show its strength. The Pyrolog interpreter and the JIT treat
dynamically defined predicates as static ones and can generate optimezed code
in both cases. Whereas SWI only compiles statically defined rules and has to
fall back to interpretation on dynamic ones.&lt;br&gt;
For simple benchmarks running on PyPy's Python intepreter we see some speedups
over CPython, but we still need to debug the backend bit more before we can
show numbers on more complex benchmarks. So, stay tuned.&lt;/div&gt;</description><guid>https://www.pypy.org/posts/2011/01/jit-backend-for-arm-processors-5994810755839586463.html</guid><pubDate>Sat, 29 Jan 2011 14:19:00 GMT</pubDate></item></channel></rss>