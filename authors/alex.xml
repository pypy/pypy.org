<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts by Alex)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/authors/alex.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Mon, 07 Jul 2025 11:01:29 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Python Software Foundation Matching Donations this Month</title><link>https://www.pypy.org/posts/2014/09/python-software-foundation-matching-2230529993193139046.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;We're extremely excited to announce that for the month of September, any amount&lt;br&gt;
you donate to PyPy will be match (up to $10,000) by the &lt;a class="reference external" href="https://pyfound.blogspot.com/2014/09/matching-donations-to-pypy-in-september.html"&gt;Python Software&lt;br&gt;
Foundation&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This includes any of our ongoing fundraisers: NumPyPy, STM, Python3, or our&lt;br&gt;
general fundraising.&lt;/p&gt;&lt;p&gt;Here are some of the things your previous donations have helped accomplish:&lt;/p&gt;&lt;ul class="simple"&gt;&lt;li&gt;Getting PyPy3 completed (currently 3.2, with 3.3 work underway)&lt;/li&gt;
&lt;li&gt;New research and production engineering on STM for PyPy&lt;/li&gt;
&lt;li&gt;Lots of progress on NumPy for PyPy&lt;/li&gt;
&lt;li&gt;Significant performance improvements&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;You can see a preview of what's coming in our next 2.4 release in the &lt;a class="reference external" href="https://doc.pypy.org/en/latest/release-2.4.0.html#highlights"&gt;draft&lt;br&gt;
release notes&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Thank you to all the individuals and companies which have donated so far.&lt;/p&gt;&lt;p&gt;So please, donate today: &lt;a class="reference external" href="https://pypy.org/"&gt;https://pypy.org/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;(Please be aware that the donation progress bars are not live updating, so&lt;br&gt;
don't be afraid if your donation doesn't show up immediately).&lt;/p&gt;</description><guid>https://www.pypy.org/posts/2014/09/python-software-foundation-matching-2230529993193139046.html</guid><pubDate>Mon, 01 Sep 2014 17:49:00 GMT</pubDate></item><item><title>Making coverage.py faster under PyPy</title><link>https://www.pypy.org/posts/2013/10/making-coveragepy-faster-under-pypy-935409618297062344.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;If you've ever tried to run your programs with &lt;tt class="docutils literal"&gt;coverage.py&lt;/tt&gt; under PyPy,&lt;br&gt;
you've probably experienced some incredible slowness. Take this simple&lt;br&gt;
program:&lt;/p&gt;&lt;pre class="code python literal-block"&gt;&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="name function"&gt;f&lt;/span&gt;&lt;span class="punctuation"&gt;():&lt;/span&gt;
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="literal number integer"&gt;1&lt;/span&gt;


&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="name function"&gt;main&lt;/span&gt;&lt;span class="punctuation"&gt;():&lt;/span&gt;
    &lt;span class="name"&gt;i&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="literal number integer"&gt;10000000&lt;/span&gt;
    &lt;span class="keyword"&gt;while&lt;/span&gt; &lt;span class="name"&gt;i&lt;/span&gt;&lt;span class="punctuation"&gt;:&lt;/span&gt;
        &lt;span class="name"&gt;i&lt;/span&gt; &lt;span class="operator"&gt;-=&lt;/span&gt; &lt;span class="name"&gt;f&lt;/span&gt;&lt;span class="punctuation"&gt;()&lt;/span&gt;

&lt;span class="name"&gt;main&lt;/span&gt;&lt;span class="punctuation"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Running &lt;tt class="docutils literal"&gt;time coverage.py run test.py&lt;/tt&gt; five times, and looking at the best&lt;br&gt;
run, here's how PyPy 2.1 stacks up against CPython 2.7.5:&lt;/p&gt;&lt;table border="1" class="docutils"&gt;&lt;colgroup&gt;
&lt;col width="32%"&gt;
&lt;col width="19%"&gt;
&lt;col width="49%"&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Python&lt;/th&gt;
&lt;th class="head"&gt;Time&lt;/th&gt;
&lt;th class="head"&gt;Normalized to CPython&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;CPython 2.7.5&lt;/td&gt;
&lt;td&gt;3.879s&lt;/td&gt;
&lt;td&gt;1.0x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;PyPy 2.1&lt;/td&gt;
&lt;td&gt;53.330s&lt;/td&gt;
&lt;td&gt;13.7x slower&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;p&gt;Totally ridiculous. I got turned onto this problem because on one of my&lt;br&gt;
projects CPython takes about 1.5 minutes to run our test suite on the build&lt;br&gt;
bot, but PyPy takes 8-10 minutes.&lt;/p&gt;&lt;p&gt;So I sat down to address it. And the results:&lt;/p&gt;&lt;table border="1" class="docutils"&gt;&lt;colgroup&gt;
&lt;col width="32%"&gt;
&lt;col width="19%"&gt;
&lt;col width="49%"&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Python&lt;/th&gt;
&lt;th class="head"&gt;Time&lt;/th&gt;
&lt;th class="head"&gt;Normalized to CPython&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;CPython 2.7.5&lt;/td&gt;
&lt;td&gt;3.879s&lt;/td&gt;
&lt;td&gt;1.0x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;PyPy 2.1&lt;/td&gt;
&lt;td&gt;53.330s&lt;/td&gt;
&lt;td&gt;13.7x slower&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;PyPy head&lt;/td&gt;
&lt;td&gt;1.433s&lt;/td&gt;
&lt;td&gt;2.7x faster&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;p&gt;Not bad.&lt;/p&gt;&lt;div class="section" id="technical-details"&gt;&lt;h1&gt;Technical details&lt;/h1&gt;&lt;p&gt;So how'd we do it? Previously, using &lt;tt class="docutils literal"&gt;sys.settrace()&lt;/tt&gt; (which &lt;tt class="docutils literal"&gt;coverage.py&lt;/tt&gt;&lt;br&gt;
uses under the hood) disabled the JIT. Except it didn't just disable the JIT,&lt;br&gt;
it did it in a particularly insidious way — the JIT had no idea it was being&lt;br&gt;
disabled!&lt;/p&gt;&lt;p&gt;Instead, every time PyPy discovered that one of your functions was a hotspot,&lt;br&gt;
it would start tracing to observe what the program was doing, and right when it&lt;br&gt;
was about to finish, &lt;tt class="docutils literal"&gt;coverage&lt;/tt&gt; would run and cause the JIT to abort. Tracing&lt;br&gt;
is a slow process, it makes up for it by generating fast machine code at the&lt;br&gt;
end, but tracing is still incredibly slow. But we never actually got to the&lt;br&gt;
"generate fast machine code" stage. Instead we'd pay all the cost of tracing,&lt;br&gt;
but then we'd abort, and reap none of the benefits.&lt;/p&gt;&lt;p&gt;To fix this, we adjusted some of the heuristics in the JIT, to better show it&lt;br&gt;
how &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;sys.settrace(&amp;lt;tracefunc&amp;gt;)&lt;/span&gt;&lt;/tt&gt; works. Previously the JIT saw it as an opaque&lt;br&gt;
function which gets the frame object, and couldn't tell whether or not it&lt;br&gt;
messed with the frame object. Now we let the JIT look inside the&lt;br&gt;
&lt;tt class="docutils literal"&gt;&amp;lt;tracefunc&amp;gt;&lt;/tt&gt; function, so it's able to see that &lt;tt class="docutils literal"&gt;coverage.py&lt;/tt&gt; isn't&lt;br&gt;
messing with the frame in any weird ways, it's just reading the line number and&lt;br&gt;
file path out of it.&lt;/p&gt;&lt;p&gt;I asked several friends in the VM implementation and research field if they&lt;br&gt;
were aware of any other research into making VMs stay fast when debugging tools&lt;br&gt;
like &lt;tt class="docutils literal"&gt;coverage.py&lt;/tt&gt; are running. No one I spoke to was aware of any (but I&lt;br&gt;
didn't do a particularly exhaustive review of the literature, I just tweeted at&lt;br&gt;
a few people), so I'm pleased to say that PyPy is quite possibly the first VM&lt;br&gt;
to work on optimizing code in debugging mode! This is possible because of our&lt;br&gt;
years spent investing in meta-tracing research.&lt;/p&gt;&lt;/div&gt;&lt;p&gt;Happy testing,&lt;br&gt;
Alex&lt;/p&gt;</description><guid>https://www.pypy.org/posts/2013/10/making-coveragepy-faster-under-pypy-935409618297062344.html</guid><pubDate>Sat, 26 Oct 2013 00:48:00 GMT</pubDate></item><item><title>PyPy San Francisco Sprint July 27th 2013</title><link>https://www.pypy.org/posts/2013/07/pypy-san-francisco-sprint-july-27th-2012-3064530444396960172.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;The next PyPy sprint will be in San Francisco, California. It is a public&lt;br&gt;
sprint, suitable for newcomers. It will run on Saturday July 27th.&lt;/p&gt;&lt;p&gt;Some possible things people will be hacking on the sprint:&lt;/p&gt;&lt;ul class="simple"&gt;&lt;li&gt;running your software on PyPy&lt;/li&gt;
&lt;li&gt;making your software fast on PyPy&lt;/li&gt;
&lt;li&gt;improving PyPy's JIT&lt;/li&gt;
&lt;li&gt;improving Twisted on PyPy&lt;/li&gt;
&lt;li&gt;any exciting stuff you can think of&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;If there are newcomers, we'll run an introduction to hacking on PyPy.&lt;/p&gt;&lt;p&gt;Location&lt;br&gt;
The sprint will be held at the Rackspace Office:&lt;/p&gt;&lt;p&gt;620 Folsom St, Ste 100&lt;/p&gt;&lt;p&gt;The doors will open at 10AM and run until 6PM.&lt;/p&gt;</description><guid>https://www.pypy.org/posts/2013/07/pypy-san-francisco-sprint-july-27th-2012-3064530444396960172.html</guid><pubDate>Fri, 26 Jul 2013 01:17:00 GMT</pubDate></item><item><title>PyPy San Francisco Sprint Dec 1st - Dec 2nd 2012</title><link>https://www.pypy.org/posts/2012/11/pypy-san-francisco-sprint-dec-1st-dec-5133109101989613355.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;The next PyPy sprint will be in San Francisco, California. It is a&lt;br&gt;
public sprint, suitable for newcomers. It will run on Saturday December 1st and&lt;br&gt;
Sunday December 2nd. The goals for the sprint are continued work towards the&lt;br&gt;
2.0 release as well as code cleanup, we of course welcome any topic which&lt;br&gt;
contributors are interested in working on.&lt;/p&gt;&lt;p&gt;Some other possible topics are:&lt;/p&gt;&lt;ul class="simple"&gt;&lt;li&gt;running your software on PyPy&lt;/li&gt;
&lt;li&gt;work on PyPy's numpy (&lt;a class="reference external" href="https://www.pypy.org/posts/2012/09/numpy-on-pypy-status-update-1605312600799448094.html"&gt;status&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;work on STM (&lt;a class="reference external" href="https://mail.python.org/pipermail/pypy-dev/2012-September/010513.html"&gt;status&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;JIT improvements&lt;/li&gt;
&lt;li&gt;any exciting stuff you can think of&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;If there are newcomers, we'll run the usual introduction to hacking on&lt;br&gt;
PyPy.&lt;/p&gt;&lt;br&gt;
&lt;h1&gt;Location&lt;/h1&gt;&lt;p&gt;The sprint will be held at the Rackspace Office:&lt;/p&gt;&lt;p&gt;620 Folsom St, Ste 100&lt;br&gt;
San Francisco&lt;/p&gt;&lt;p&gt;The doors will open at 10AM both days, and run until 6PM both days.&lt;/p&gt;&lt;p&gt;Thanks to David Reid for helping get everything set up!&lt;/p&gt;</description><guid>https://www.pypy.org/posts/2012/11/pypy-san-francisco-sprint-dec-1st-dec-5133109101989613355.html</guid><pubDate>Tue, 27 Nov 2012 19:29:00 GMT</pubDate></item><item><title>Come see us at PyCon 2012</title><link>https://www.pypy.org/posts/2011/12/come-see-us-at-pycon-2012-610420698450130659.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;&lt;a class="reference external" href="https://us.pycon.org/2012/"&gt;PyCon 2012&lt;/a&gt; is coming up in just a few short months, and PyPy will be well&lt;br&gt;
represented there.  We'll be delivering a tutorial, two talks, plus we'll be&lt;br&gt;
around for the sprints.&lt;/p&gt;&lt;p&gt;Here are the abstracts for the tutorials and talks:&lt;/p&gt;&lt;ul class="simple"&gt;&lt;li&gt;&lt;strong&gt;How to get the most out of your PyPy&lt;/strong&gt;, by Maciej Fijalkowski, Alex Gaynor&lt;br&gt;
and Armin Rigo: For many applications PyPy can provide performance benefits&lt;br&gt;
right out of the box. However, little details can push your application to&lt;br&gt;
perform much better. In this tutorial we'll give you insights on how to push&lt;br&gt;
PyPy to its limits. We'll focus on understanding the performance&lt;br&gt;
characteristics of PyPy, and learning the analysis tools in order to maximize&lt;br&gt;
your applications' performance. &lt;em&gt;This is the tutorial.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Why PyPy by example&lt;/strong&gt;, by Maciej Fijalkowski, Alex Gaynor and Armin Rigo:&lt;br&gt;
One of the goals of PyPy is to make existing Python code faster; however an&lt;br&gt;
even broader goal was to make it possible to write things in Python that&lt;br&gt;
previously would needed to be written in C or other low-level language. This&lt;br&gt;
talk will show examples of this, and describe how they represent the&lt;br&gt;
tremendous progress PyPy has made, and what it means for people looking at&lt;br&gt;
using PyPy.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How the PyPy JIT works&lt;/strong&gt;, by Benjamin Peterson: The Python community is&lt;br&gt;
abuzz about the major speed gains PyPy can offer for pure Python code. But how&lt;br&gt;
does the PyPy JIT actually work? This talk will discuss how the PyPy JIT is&lt;br&gt;
implemented. It will include descriptions of the tracing, optimization, and&lt;br&gt;
assembly generation phases. I will demonstrate each step with an example loop.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;If you have any questions let us know!  We look forward to seeing people at&lt;br&gt;
PyCon and chatting about PyPy and the entire Python ecosystem.&lt;/p&gt;&lt;p&gt;See you there,&lt;br&gt;
Maciej Fijalkowski, Alex Gaynor, Benjamin Peterson, Armin Rigo, and the entire PyPy team&lt;/p&gt;</description><guid>https://www.pypy.org/posts/2011/12/come-see-us-at-pycon-2012-610420698450130659.html</guid><pubDate>Thu, 22 Dec 2011 22:27:00 GMT</pubDate></item><item><title>Py3k for PyPy fundraiser</title><link>https://www.pypy.org/posts/2011/09/py3k-for-pypy-fundraiser-8139653689520709617.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;Hi,&lt;/p&gt;&lt;p&gt;We would like to announce a donation campaign for implementing Python 3 in PyPy.&lt;br&gt;
Please read our &lt;a class="reference external" href="https://pypy.org/py3donate.html"&gt;detailed plan&lt;/a&gt; for all the details and donate using the&lt;br&gt;
button on that page!&lt;/p&gt;&lt;p&gt;Thanks,&lt;br&gt;
The PyPy Team&lt;/p&gt;</description><guid>https://www.pypy.org/posts/2011/09/py3k-for-pypy-fundraiser-8139653689520709617.html</guid><pubDate>Wed, 21 Sep 2011 17:44:00 GMT</pubDate></item><item><title>Report back from our survey</title><link>https://www.pypy.org/posts/2011/06/report-back-from-our-survey-2083371215707583264.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;Hi all,&lt;/p&gt;
&lt;p&gt;I'm here to report back the results of our survey. First, we're very pleased to
report that a number of you guys are happilly running PyPy in production! Most
(97%) of the respondants using PyPy are using it because it's faster, but a
further 26% (respondants could choose multiple answers) are using it because of
lower memory usage. Of users who aren't using PyPy, the most common reason was
C extensions, followed by "Other".&lt;/p&gt;
&lt;p&gt;From reading the extra comments section there are a few things we've learned:&lt;/p&gt;
&lt;ol class="loweralpha simple"&gt;
&lt;li&gt;Google docs needs a better UI for this stuff&lt;/li&gt;
&lt;li&gt;A huge number of people want NumPy and SciPy, it was easily the most
requested C extension (25% of respondants said somthing about NumPy). We've
already blogged on the topic of &lt;a class="reference external" href="https://www.pypy.org/posts/2011/05/numpy-in-pypy-status-and-roadmap-8332894230779779992.html"&gt;our plans for NumPy&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Having packages in the various OS's repositories would be a big help in
getting users up and running.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A huge thanks to everyone who responded! Finally, if you're using PyPy in
production we'd love to get a testimonial from you, if you're willing to spare
a few minutes to give us a quote or two please get in contact with us via &lt;a class="reference external" href="https://mail.python.org/mailman/listinfo/pypy-dev"&gt;our
mailing list&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thanks,
Alex&lt;/p&gt;</description><guid>https://www.pypy.org/posts/2011/06/report-back-from-our-survey-2083371215707583264.html</guid><pubDate>Wed, 08 Jun 2011 06:18:00 GMT</pubDate></item><item><title>PyPy Usage Survey</title><link>https://www.pypy.org/posts/2011/05/pypy-usage-survey-1402303968715807009.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;We've been working on PyPy for a long time. But readers of this blog will know
that in the past year something has changed: we think PyPy is production ready.
And it's not just us, this week &lt;a class="reference external" href="https://lwn.net/"&gt;LWN.net&lt;/a&gt; wrote an article about how &lt;a class="reference external" href="https://lwn.net/SubscriberLink/442268/22f66371348bd7c5/"&gt;PyPy
sped up one of their scripts by a factor of three&lt;/a&gt;, noting that, "plans are to
run gitdm under PyPy from here on out". All in all we think PyPy is pretty
great, but not everyone is using it yet, and we want to know why. We want your
feedback on why PyPy isn't ready to be your only Python yet, and how we can
improve it to make that happen.&lt;/p&gt;
&lt;p&gt;Therefore, we've put together a quick survey, whether you're using PyPy or not
if you could take a few minutes to fill it out and let us know how we're doing
we'd really appreciate it. You can find the form &lt;a class="reference external" href="https://spreadsheets.google.com/viewform?hl=en&amp;amp;formkey=dF9NZlFpNldNS05fdFVKMnpKZVFzN0E6MQ#gid=0"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thanks,
The PyPy team&lt;/p&gt;</description><guid>https://www.pypy.org/posts/2011/05/pypy-usage-survey-1402303968715807009.html</guid><pubDate>Mon, 16 May 2011 17:27:00 GMT</pubDate></item><item><title>NumPy Follow up</title><link>https://www.pypy.org/posts/2011/05/numpy-follow-up-6928627691060102514.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;Hi everyone.  Since yesterday's blog post we got a ton of feedback, so we want
to clarify a few things, as well as share some of the progress we've made, in
only the 24 hours since the post.&lt;/p&gt;
&lt;h3&gt;Reusing the original NumPy&lt;/h3&gt;
&lt;p&gt;First, a lot of people have asked why we cannot just reuse the original NumPy
through &lt;tt class="docutils literal"&gt;cpyext&lt;/tt&gt;, our CPython C-API compatibility layer.  We believe this is
not the best approach, for a few reasons:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;cpyext&lt;/tt&gt; is slow, and always will be slow. It has to emulate far too many
details of the CPython object model that don't exist on PyPy (e.g.,
reference counting). Since people are using NumPy primarily for speed this
would mean that even if we could have a working NumPy, no one would want to
use it.  Also, as soon as the execution crosses the &lt;tt class="docutils literal"&gt;cpyext&lt;/tt&gt; boundary, it
becomes invisible to the JIT, which means the JIT has to assume the worst
and deoptimize stuff away.&lt;/li&gt;
&lt;li&gt;NumPy uses many obscure documented and undocumented details of the CPython
C-API. Emulating these is often difficult or impossible (e.g. we can't fix
accessing a struct field, as there's no function call for us to intercept).&lt;/li&gt;
&lt;li&gt;It's not much fun. Frankly, working on &lt;tt class="docutils literal"&gt;cpyext&lt;/tt&gt;, debugging the crashes,
and everything else that goes with it is not terribly fun, especially when
you know that the end result will be slow. We've demonstrated we can build
a much faster NumPy, in a way that's more fun, and given that the people
working on this are volunteers, it's important to keep us motivated.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Finally, we are &lt;strong&gt;not&lt;/strong&gt; proposing to rewrite the entirety of NumPy or, god
forbid, BLAST, or any of the low level stuff that operates on C-level arrays,
only the parts that interface with Python code directly.&lt;/p&gt;
&lt;h3&gt;C bindings vs. CPython C-API&lt;/h3&gt;
&lt;p&gt;There are two issues on C code, one has a very nice story, and the other not so
much. First is the case of arbitrary C-code that isn't Python related, things
like &lt;tt class="docutils literal"&gt;libsqlite&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;libbz2&lt;/tt&gt;, or any random C shared library on your system.
PyPy will quite happily call into these, and bindings can be developed either
at the RPython level (using &lt;tt class="docutils literal"&gt;rffi&lt;/tt&gt;) or in pure Python, using &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt;.
Writing bindings with &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt; has the advantage that they can run on every
alternative Python implementation, such as Jython and IronPython.  Moreover,
once we merge the &lt;tt class="docutils literal"&gt;jittypes2&lt;/tt&gt; branch &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt; calls will even be smoking
fast.&lt;/p&gt;
&lt;p&gt;On the other hand there is the CPython C-extension API. This is a very specific
API which CPython exposes, and PyPy tries to emulate. It will never be fast,
because there is far too much overhead in all the emulation that needs to be
done.&lt;/p&gt;
&lt;p&gt;One of the reasons people write C extensions is for speed.  Often, with PyPy
you can just forget about C, write everything in pure python and let the JIT to
do its magic.&lt;/p&gt;
&lt;p&gt;In case the PyPy JIT alone isn't fast enough, or you just want to
use existing C code then it might make sense to split
your C-extension into 2 parts, one which doesn't touch the CPython C-API and
thus can be loaded with &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt; and called from PyPy, and another which does
the interfacing with Python for CPython (where it will be faster).&lt;/p&gt;
&lt;p&gt;There are also libraries written in C to interface with existing C codebases,
but for whom performance is not the largest goal, for these the right solution
is to try using CPyExt, and if it works that's great, but if it fails the
solution will be to rewrite using &lt;cite&gt;ctypes&lt;/cite&gt;, where it will work on all Python
VMs, not just CPython.&lt;/p&gt;
&lt;p&gt;And finally there are rare cases where rewriting in RPython makes more sense,
NumPy is one of the few examples of these because we need to be able to give
the JIT hints on how to appropriately vectorize all of the operations on an
array.  In general writing in RPython is not necessary for almost any
libraries, NumPy is something of a special case because it is so ubiquitous
that every ounce of speed is valuable, and makes the way people use it leads to
code structure where the JIT benefits enormously from extra hints and the
ability to manipulate memory directly, which is not possible from Python.&lt;/p&gt;
&lt;h3&gt;Progress&lt;/h3&gt;
&lt;p&gt;On a more positive note, after we published the &lt;a class="reference external" href="https://www.pypy.org/posts/2011/05/numpy-in-pypy-status-and-roadmap-8332894230779779992.html"&gt;last post&lt;/a&gt;, several new people
came and contributed improvements to the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;numpy-exp&lt;/span&gt;&lt;/tt&gt; branch. We would like to
thank all of them:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;nightless_night contributed: An implementation of &lt;tt class="docutils literal"&gt;__len__&lt;/tt&gt;, fixed bounds
checks on &lt;tt class="docutils literal"&gt;__getitem__&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;__setitem__&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;brentp contributed: Subtraction and division on NumPy arrays.&lt;/li&gt;
&lt;li&gt;MostAwesomeDude contributed: Multiplication on NumPy arrays.&lt;/li&gt;
&lt;li&gt;hodgestar contributed: Binary operations between floats and NumPy arrays.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Those last two were technically an outstanding branch we finally merged, but
hopefully you get the picture. In addition there was some exciting work done by
regular PyPy contributors. I hope it's clear that there's a place to jump in
for people with any level of PyPy familiarity. If you're interested in
contributing please stop by #pypy on irc.freenode.net, the &lt;a class="reference external" href="https://codespeak.net/mailman/listinfo/pypy-dev"&gt;pypy-dev&lt;/a&gt; mailing
list, or send us pull requests on &lt;a class="reference external" href="https://bitbucket.org/pypy/pypy"&gt;bitbucket&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Alex&lt;/p&gt;</description><category>numpy</category><guid>https://www.pypy.org/posts/2011/05/numpy-follow-up-6928627691060102514.html</guid><pubDate>Thu, 05 May 2011 21:56:00 GMT</pubDate></item><item><title>PyOhio</title><link>https://www.pypy.org/posts/2010/08/pyohio-2568618480482575546.html</link><dc:creator>Alex</dc:creator><description>&lt;p&gt;This weekend I delivered a talk at &lt;a class="reference external" href="https://pyohio.org/"&gt;PyOhio&lt;/a&gt; (an annual conference in Columbus, OH, USA) on PyPy and Unladen Swallow.  The talk covered reasons that Python, the language, is hard to optimize, why CPython is slow, and a few optimizations that PyPy and Unladen Swallow have implemented.  The slides from my talk are &lt;a class="reference external" href="https://www.scribd.com/doc/35240506/Making-Python-Fast-PyPy-and-Unladen-Swallow"&gt;online&lt;/a&gt;, and the talk was recorded so a video will follow.  I gave a similar talk to &lt;a class="reference external" href="https://chipy.org/"&gt;ChiPy&lt;/a&gt; (the Chicago Python user group), which was also recorded and the video is &lt;a class="reference external" href="https://carlfk.blip.tv/file/3866910"&gt;available&lt;/a&gt;.  Both audiences were excited about the futures for PyPy and Unladen Swallow, and for the future of a faster Python.&lt;/p&gt;
&lt;p&gt;Alex&lt;/p&gt;</description><guid>https://www.pypy.org/posts/2010/08/pyohio-2568618480482575546.html</guid><pubDate>Mon, 02 Aug 2010 21:33:00 GMT</pubDate></item></channel></rss>