<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Incremental Garbage Collector in PyPy | PyPy</title>
<link href="../../../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../../rss.xml">
<link rel="canonical" href="https://www.pypy.org/posts/2013/10/incremental-garbage-collector-in-pypy-8956893523842234676.html">
<link rel="icon" href="../../../favicon2.ico" sizes="16x16">
<link rel="icon" href="../../../favicon32x32.ico" sizes="32x32">
<!--[if lt IE 9]><script src="../../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../../assets/css/tipuesearch.css">
<meta name="author" content="Maciej Fijalkowski">
<link rel="prev" href="../09/numpy-status-update-5160363918470470887.html" title="Numpy Status Update" type="text/html">
<link rel="next" href="update-on-stm-7145890443443707910.html" title="Update on STM" type="text/html">
<meta property="og:site_name" content="PyPy">
<meta property="og:title" content="Incremental Garbage Collector in PyPy">
<meta property="og:url" content="https://www.pypy.org/posts/2013/10/incremental-garbage-collector-in-pypy-8956893523842234676.html">
<meta property="og:description" content="Hello everyone.
We're pleased to announce that as of today,
the default PyPy comes with a GC that has much smaller pauses than yesterday.
Let's start with explaining roughly what GC pauses are. In CPy">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2013-10-15T11:20:00Z">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../../../index.html">
                    <image id="toplogo" src="../../../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../../../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../../../compat.html">Compatibility</a> </li>  
                    <li> <a href="../../../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../../../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href="../../../blog/">Index</a> </li>  
                    <li> <a href="../../../categories/">Tags</a> </li>  
                    <li> <a href="../../../archive.html">Archive by year</a> </li>  
                    <li> <a href="../../../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../../../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../../../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../../../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../../../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Search…" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><div class="post">
          <header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Incremental Garbage Collector in PyPy</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../../authors/maciej-fijalkowski.html">Maciej Fijalkowski</a>
            </span></p>
            <p class="dateline">
            <a href="#" rel="bookmark">
            <time class="published dt-published" datetime="2013-10-15T11:20:00Z" itemprop="datePublished" title="2013-10-15 11:20">2013-10-15 11:20</time></a>
            </p>
                <p class="commentline">16 comments</p>

                <p class="commentline">            <a href="incremental-garbage-collector-in-pypy-8956893523842234676.html#utterances-thread">Comments</a>


            
        </p>
</div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
      <div dir="ltr" style="text-align: left;">
<div dir="ltr" style="text-align: left;">

<p>Hello everyone.</p>
<p>We're pleased to announce that as of today,
the default PyPy comes with a GC that has much smaller pauses than yesterday.</p>
<p>Let's start with explaining roughly what GC pauses are. In CPython each
object has a reference count, which is incremented each time we create
references and decremented each time we forget them. This means that objects
are freed each time they become unreachable. That is only half of the story
though. First note that when the last reference to a large tree of
objects goes away, you have a pause: all the objects are freed. Your
program is not progressing at all during this pause, and this pause's
duration can be arbitrarily large. This occurs at deterministic times,
though. But consider code like this:</p>
<pre class="literal-block">
class A(object):
     pass

a = A()
b = A()
a.item = b
b.item = a
del a
del b
</pre>
<p>This creates a reference cycle. It means that while we deleted references to
<tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> from the current scope, they still have a reference count of 1,
because they point to each other, even though the whole group has no references
from the outside. CPython employs a cyclic garbage collector which is used to
find such cycles. It walks over all objects in memory, starting from some known
roots, such as <tt class="docutils literal">type</tt> objects, variables on the stack, etc. This solves the
problem, but can create noticeable, nondeterministic GC pauses as the heap
becomes large and convoluted.</p>
<p>PyPy essentially has only the cycle finder - it does not bother with reference
counting, instead it walks alive objects every now and then (this is a big
simplification, PyPy's GC is much more complex than this). Although this might
sound like a missing feature, it is really one of the reasons why PyPy is so
fast, because at the end of the day the total time spent in managing the
memory is lower in PyPy than CPython. However, as a result, PyPy also has the
problem of GC pauses.</p>
<p>To alleviate this problem, which is essential for
applications like games, we started to work on incremental GC, which spreads
the walking of objects and cleaning them across the execution time in smaller
intervals. The work was sponsored by the Raspberry Pi foundation, started
by Andrew Chambers and finished by Armin Rigo and Maciej Fijałkowski.</p>
</div>
<div class="section" id="benchmarks">
<h3>Benchmarks<a href="#benchmarks" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Everyone loves benchmarks. We did not measure any significant speed difference
on our quite extensive benchmark suite on speed.pypy.org. The main
benchmark that we used for other comparisons was translating the <a class="reference external" href="https://docs.topazruby.com/en/latest/">topaz</a>
ruby interpreter using various versions of PyPy and CPython. The exact
command was <tt class="docutils literal">python <span class="pre">&lt;pypy-checkout&gt;/bin/rpython</span> <span class="pre">-O2</span> <span class="pre">--rtype</span> targettopaz.py</tt>.
Versions:</p>
<ul class="simple">
<li>topaz - dce3eef7b1910fc5600a4cd0afd6220543104823</li>
<li>pypy source - defb5119e3c6</li>
<li>pypy compiled with minimark (non-incremental GC) - d1a0c07b6586</li>
<li>pypy compiled with incminimark (new, incremental GC) - 417a7117f8d7</li>
<li>CPython - 2.7.3</li>
</ul>
<p>The memory usage of CPython, PyPy with minimark and PyPy with incminimark is
shown here. Note that this benchmark is quite bad for PyPy in general, the
memory usage is higher and the amount of time taken is longer. This is due
to the JIT warmup being both memory hungry and inefficient (see below).
But first, the new GC is not worse than the old one.</p>

<div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Ty4LVNMb8OQ/Ul0VmNvlCiI/AAAAAAAABo0/7HzP9D0tOFI/s1600/memusage.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://1.bp.blogspot.com/-Ty4LVNMb8OQ/Ul0VmNvlCiI/AAAAAAAABo0/7HzP9D0tOFI/s400/memusage.png"></a></div>
<p><b>EDIT:</b>Red line is CPython, blue is incminimark (new), green is minimark (old)</p>

<p>The image was obtained by graphing the output of <a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/tree/branch/default/pypy/tool/memusage/memusage.py?at=default">memusage.py</a>.</p>
<p>However, the GC pauses are significantly smaller. For PyPy the way to
get GC pauses is to measure time between start and stop while running stuff
with <tt class="docutils literal"><span class="pre">PYPYLOG=gc-collect:log</span> pypy program.py</tt>, for CPython, the magic
incantation is <tt class="docutils literal">gc.set_debug(gc.DEBUG_STATS)</tt> and parsing the output.
For what is worth, the average and total for CPython, as well as the total
number of events are not directly comparable since it only shows the cyclic
collector, not the reference counts. The only comparable thing is the
amount of long pauses and their duration. In the table below, pause duration
is sorted into 8 buckets, each meaning "below that or equal to the threshold".
The output is generated using the <a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/tree/branch/default/rpython/tool/gcanalyze.py?at=default">gcanalyze</a> tool.</p>
<p>CPython:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%">
<col width="12%">
<col width="12%">
<col width="12%">
<col width="12%">
<col width="12%">
<col width="14%">
<col width="14%">
</colgroup>
<tbody valign="top">
<tr>
<td>150.1ms</td>
<td>300.2ms</td>
<td>450.3ms</td>
<td>600.5ms</td>
<td>750.6ms</td>
<td>900.7ms</td>
<td>1050.8ms</td>
<td>1200.9ms</td>
</tr>
<tr>
<td>5417</td>
<td>5</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>PyPy minimark (non-incremental GC):</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%">
<col width="12%">
<col width="12%">
<col width="12%">
<col width="13%">
<col width="13%">
<col width="13%">
<col width="13%">
</colgroup>
<tbody valign="top">
<tr>
<td>216.4ms</td>
<td>432.8ms</td>
<td>649.2ms</td>
<td>865.6ms</td>
<td>1082.0ms</td>
<td>1298.4ms</td>
<td>1514.8ms</td>
<td>1731.2ms</td>
</tr>
<tr>
<td>27</td>
<td>14</td>
<td>6</td>
<td>4</td>
<td>6</td>
<td>5</td>
<td>3</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>PyPy incminimark (new incremental GC):</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%">
<col width="12%">
<col width="12%">
<col width="12%">
<col width="12%">
<col width="12%">
<col width="14%">
<col width="14%">
</colgroup>
<tbody valign="top">
<tr>
<td>15.7ms</td>
<td>31.4ms</td>
<td>47.1ms</td>
<td>62.8ms</td>
<td>78.6ms</td>
<td>94.3ms</td>
<td>110.0ms</td>
<td>125.7ms</td>
</tr>
<tr>
<td>25512</td>
<td>122</td>
<td>4</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>As we can see, while there is still work to be done (the 100ms ones could
be split among several steps), we did improve the situation quite drastically
without any actual performance difference.</p>
<p>Note about the benchmark - we know it's a pretty extreme case of JIT
warmup, we know we suck on it, we're working on it and we're not afraid of
showing PyPy is not always the best <tt class="docutils literal"><span class="pre">;-)</span></tt></p>
</div>
<div class="section" id="nitty-gritty-details">
<h3>Nitty gritty details<a href="#nitty-gritty-details" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Here are some nitty gritty details for people really interested in
Garbage Collection.  This was done as a patch to "minimark", our current
GC, and called "incminimark" for now.  The former is a generational
stop-the-world GC.  New objects are allocated "young", which means that
they initially live in the "nursery", a special zone of a few MB of
memory.  When the nursery is full, a "minor collection" step moves the
surviving objects out of the nursery.  This can be done quickly (a few
millisecond) because we only need to walk through the young objects that
survive --- usually a small fraction of all young objects; and also by
far not <em>all</em> objects that are alive at this point, but only the young
ones.  However, from time to time this minor collection is followed by a
"major collection": in that step, we really need to walk all objects to
classify which ones are still alive and which ones are now dead
("marking") and free the memory occupied by the dead ones ("sweeping").
You can read more details <a class="reference external" href="https://doc.pypy.org/en/latest/garbage_collection.html#minimark-gc">here</a>.</p>
<p>This "major collection" is what gives the long GC pauses.  To fix this
problem we made the GC incremental: instead of running one complete
major collection, we split its work into a variable number of pieces and
run each piece after every minor collection for a while, until there are
no more pieces.  The pieces are each doing a fraction of marking, or a
fraction of sweeping.  It adds some few milliseconds after each of these
minor collections, rather than requiring hundreds of milliseconds in one
go.</p>
<p>The main issue is that splitting the major collections means that the
main program is actually running between the pieces, and so it can
change the pointers in the objects to point to other objects.  This is
not a problem for sweeping: dead objects will remain dead whatever the
main program does.  However, it is a problem for marking.  Let us see
why.</p>
<p>In terms of the incremental GC literature, objects are either "white",
"gray" or "black".  This is called <em>tri-color marking.</em>  See for example
this <a class="reference external" href="https://rubini.us/2013/06/22/concurrent-garbage-collection/">blog post about Rubinius</a>, or this <a class="reference external" href="https://wiki.luajit.org/New-Garbage-Collector/01fd5e5ca4f95d45e0c4b8a98b49f2b656cc23dd">page about LuaJIT</a> or the <a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Tri-color_marking">wikipedia description</a>.  The
objects start as "white" at the beginning of marking; become "gray" when
they are found to be alive; and become "black" when they have been fully
traversed.  Marking proceeds by scanning grey objects for pointers to
white objects.  The white objects found are turned grey, and the grey
objects scanned are turned black.  When there are no more grey objects,
the marking phase is complete: all remaining white objects are truly
unreachable and can be freed (by the following sweeping phase).</p>
<p>In this model, the important part is that a black object can never point
to a white object: if the latter remains white until the end, it will be
freed, which is incorrect because the black object itself can still be
reached.  How do we ensure that the main program, running in the middle
of marking, will not try to write a pointer to white object into a black
object?  This requires a "write barrier", i.e. a piece of code that runs
every time we set a pointer into an object or array.  This piece of code
checks if some (hopefully rare) condition is met, and calls a function
if that is the case.</p>
<p>The trick we used in PyPy is to consider minor collections as part of
the whole, rather than focus only on major collections.  The existing
minimark GC had always used a write barrier of its own to do its job,
like any generational GC.  This existing write barrier is used to detect
when an old object (outside the nursery) is modified to point to a young
object (inside the nursery), which is essential information for minor
collections.  Actually, although this was the goal, the actual write
barrier code is simpler: it just records all old objects into which we
write <em>any</em> pointer --- to a young or old object.  As we found out over
time, doing so is not actually slower, and might actually be a
performance improvement: for example, if the main program does a lot of
writes into the same old object, we don't need to check over and over
again if the written pointer points to a young object or not.  We just
record the old object in some list the first time, and that's it.</p>
<p>The trick is that this <em>unmodified</em> write barrier works for incminimark
too.  Imagine that we are in the middle of the marking phase, running
the main program.  The write barrier will record all old objects that
are being modified.  Then at the next minor collection, all surviving
young objects will be moved out of the nursery.  At this point, as we're
about to continue running the major collection's marking phase, we
simply add to the list of pending gray objects all the objects that we
just considered --- both the objects listed as "old objects that are
being modified", and the objects that we just moved out of the nursery.
A fraction from the former list were black object; so this mean that
they are turned back from the black to the gray color.  This technique
implements nicely, if indirectly, what is called a "backward write
barrier" in the literature.  The backwardness is about the color that
needs to be changed in the opposite of the usual direction "white -&gt;
gray -&gt; black", thus making more work for the GC.  (This is as opposed
to "forward write barrier", where we would also detect "black -&gt; white"
writes but turn the white object gray.)</p>
<p>In summary, I realize that this description is less about how we turned
minimark into incminimark, and more about how we differ from the
standard way of making a GC incremental.  What we really had to do to
make incminimark was to write logic that says "if the major collection
is in the middle of the marking phase, then add this object to the list
of gray objects", and put it at a few places throughout minor
collection.  Then we simply split a major collection into increments,
doing marking or sweeping of some (relatively arbitrary) number of
objects before returning.  That's why, after we found that the existing
write barrier would do, it was not much actual work, and could be done
without major changes.  For example, not a single line from the JIT
needed adaptation.  All in all it was relatively painless work. ;-)
</p>
<p>Cheers,<br>armin and fijal</p>
</div>
<br>
</div>
      </div>
      <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../09/numpy-status-update-5160363918470470887.html" rel="prev" title="Numpy Status Update">Previous post</a>
            </li>
            <li class="next">
                <a href="update-on-stm-7145890443443707910.html" rel="next" title="Update on STM">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
                <div class="comment-level comment-level-1">
      <div class="comment comment-2640666352609164748">
        <div class="comment-header">
          <a name="comment-2640666352609164748"></a>
            <span class="author">H*</span> wrote on <span class="date">2013-10-15 14:24</span>:
        </div>
        <div class="comment-content">
          <p>Nice work! :)</p>
        </div>
      </div>
      <div class="comment comment-4108635523366025462">
        <div class="comment-header">
          <a name="comment-4108635523366025462"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2013-10-15 19:10</span>:
        </div>
        <div class="comment-content">
          <p>Thank you for this nice explanation. <br><br>Which mechanism do you use for not adding twice an old object in the list of modified old objects?</p>
        </div>
      </div>
      <div class="comment comment-8135947294171177813">
        <div class="comment-header">
          <a name="comment-8135947294171177813"></a>
            <span class="author">René Dudfield</span> wrote on <span class="date">2013-10-15 21:56</span>:
        </div>
        <div class="comment-content">
          <p>Thank you! thank you! thank you!  Game dev on pypy just leveled up!</p>
        </div>
      </div>
      <div class="comment comment-8324069479613356368">
        <div class="comment-header">
          <a name="comment-8324069479613356368"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2013-10-15 22:08</span>:
        </div>
        <div class="comment-content">
          <p>Very clever! But eh, your graphs show that your program is using 2-3x the memory of CPython. How much faster is your program overall in exchange for this hugely larger memory usage?</p>
        </div>
      </div>
      <div class="comment comment-6274954072377772487">
        <div class="comment-header">
          <a name="comment-6274954072377772487"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2013-10-16 07:00</span>:
        </div>
        <div class="comment-content">
          <p>@François: a flag on the object.  All old objects have this flag initially, and we use it to detect if the write barrier must trigger.  We remove it when the write barrier has triggered once.  We re-add it during the following minor collection.<br><br>@Anonymous: this program is slower on PyPy too.  The point of the benchmark is to show that incminimark gives the same results as minimark, and to show that the JIT has bad cases.  Running the same program for a much longer time (5-10x) lets PyPy slowly catch up and eventually beat CPython by a factor 2.  The memory usage is evening out at around around 4 or 4.5GB (and I'd expect even larger examples to show lower consumption on PyPy, but that's mostly a guess).</p>
        </div>
      </div>
      <div class="comment comment-8884258461163233219">
        <div class="comment-header">
          <a name="comment-8884258461163233219"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2013-10-16 10:03</span>:
        </div>
        <div class="comment-content">
          <p>Thanks for moving Python forward!<br><br>How does the incminimarc compares to Azul C4 JVM GC and Hotspots G1 GC?<br>In other words are there strong guarantees that for big heap sizes e.g. 12 GB the GC pauses will not exceed some value e.g. 100ms?</p>
        </div>
      </div>
      <div class="comment comment-277139980756026923">
        <div class="comment-header">
          <a name="comment-277139980756026923"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2013-10-16 10:21</span>:
        </div>
        <div class="comment-content">
          <p>Sounds like great progress, but I hope you understand that even 15-30ms is <b>way</b> too much for games. That's 1-2 frames. It needs to be an order of magnitude less to ensure smooth FPS.<br><br>Do you have plans to give the program any say in whether the GC should strive for low latency vs. high throughput?</p>
        </div>
      </div>
      <div class="comment comment-2572947594762788530">
        <div class="comment-header">
          <a name="comment-2572947594762788530"></a>
            <span class="author">vdp</span> wrote on <span class="date">2013-10-16 11:13</span>:
        </div>
        <div class="comment-content">
          <p>Great writeup, explaining that kind of concept in a clear way is not easy. And well done on the unequivocal improvements :)<br><br>@annonymous Yes you'll still miss some frames, but compared to a 1 second pause, pypy suddenly became usable for games. 55fps (over what duration did those 25K collections happen ?) is not perfect, but most users won't notice. That said, it *would* be nice to be able to tune latency vs throughput.<br></p>
        </div>
      </div>
      <div class="comment comment-4490422238173482691">
        <div class="comment-header">
          <a name="comment-4490422238173482691"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2013-10-16 12:36</span>:
        </div>
        <div class="comment-content">
          <p>@Anonymous: our incminimark comes with no serious strong guarantee.  I still think it's enough for most games, say, if "almost all" the pauses are around 10ms.  It's also tweakable (see the PYPY_GC_* environment variables documented in rpython/memory/gc/incminimark.py, and try to call something like gc.collect(1) at the end of each frame).<br><br>Anyway, at around the same time scale is the time spent JITting, which also causes apparent pauses in the program.  I think that fixing it all with really strong guarantees is a much, much harder problem.  CPython doesn't gives any guarantee either, as explained at the start of the blog post.</p>
        </div>
      </div>
      <div class="comment comment-6075820676392197742">
        <div class="comment-header">
          <a name="comment-6075820676392197742"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2013-10-16 15:02</span>:
        </div>
        <div class="comment-content">
          <p>@Armin Rigo: Yeah, it's no use pushing GC pauses much lower than other pauses, but that just means other things need improving as well. ;) If I had to draw an arbitrary line, I'd say half a frame (i.e. 8ms for 60fps, 4ms for 120fps 3D) is probably a good target for the maximum.<br><br>The thing with CPython is that you can turn the GC off and still have everything non-cyclic collected. So with enough attention to detail you can avoid GC pauses completely.<br><br>BTW, is any work ongoing with regard to fully concurrent GC?</p>
        </div>
      </div>
      <div class="comment comment-1532535437129838539">
        <div class="comment-header">
          <a name="comment-1532535437129838539"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2013-10-16 15:14</span>:
        </div>
        <div class="comment-content">
          <p>You *cannot* avoid GC pauses in CPython: see the first paragraph of the blog post.  You can only make the GC pauses deterministic, by disabling the cyclic collector.  Then you can hack the program as needed to reduce GC pauses if there are some.</p>
        </div>
      </div>
      <div class="comment comment-5683772165414593188">
        <div class="comment-header">
          <a name="comment-5683772165414593188"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2013-10-16 22:14</span>:
        </div>
        <div class="comment-content">
          <p>Thanks for this really educational and accessible explanation - it's rare to find such a concise and clear piece of writing that a non expert can understand on the subject of GC.</p>
        </div>
      </div>
      <div class="comment comment-5629636211265567577">
        <div class="comment-header">
          <a name="comment-5629636211265567577"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2013-10-21 06:17</span>:
        </div>
        <div class="comment-content">
          <p>This needs visualization of processes to win Wikipedia article of the month.</p>
        </div>
      </div>
      <div class="comment comment-6870856759657872418">
        <div class="comment-header">
          <a name="comment-6870856759657872418"></a>
            <span class="author">Michael Hudson-Doyle</span> wrote on <span class="date">2013-10-22 02:29</span>:
        </div>
        <div class="comment-content">
          <p>You can also get arbitrarily long "gc" pauses in CPython by removing the last reference to some deeply nested data structure...</p>
        </div>
      </div>
      <div class="comment comment-71976144077756629">
        <div class="comment-header">
          <a name="comment-71976144077756629"></a>
            <span class="author">Dima Q</span> wrote on <span class="date">2013-11-10 13:07</span>:
        </div>
        <div class="comment-content">
          <p>Wow PyPy keeps paying off!<br>I am so glad you guys have time (and hopefully funding) push dynamic language world forward!</p>
        </div>
      </div>
      <div class="comment comment-1693418319997410540">
        <div class="comment-header">
          <a name="comment-1693418319997410540"></a>
            <span class="author">Franck</span> wrote on <span class="date">2013-11-21 12:19</span>:
        </div>
        <div class="comment-content">
          <p>If you fork() the whole process and do the marking on the frozen forked copy (on write) then you can be fully incremental without pauses, as long as you've got enough spare system memory compared to process size (as the main process keeps growing while you're marking and the pathological case of copy on write is 2x, however unlikely).</p>
        </div>
      </div>
         </div>

          </section>
</div>
    <div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/12/toy-load-store.html" class="listtitle">Load and store forwarding in the Toy Optimizer</a>
      </li>
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (9)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (6)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div>    </div>
</article></main><footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    © 2026 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
     
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
     
    Last built 2026-01-17T00:22
  </div>
  <div style="margin-left: auto">
  <a href="../../../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../../../assets/js/styles.js"></script></footer>
</div>
</body>
</html>