<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Load and store forwarding in the Toy Optimizer | PyPy</title>
<link href="../../../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../../rss.xml">
<link rel="canonical" href="https://bernsteinbear.com/blog/toy-load-store/">
<link rel="icon" href="../../../favicon2.ico" sizes="16x16">
<link rel="icon" href="../../../favicon32x32.ico" sizes="32x32">
<!--[if lt IE 9]><script src="../../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../../assets/css/tipuesearch.css">
<meta name="author" content="Max Bernstein">
<link rel="prev" href="../07/pypy-v7320-release.html" title="PyPy v7.3.20 release" type="text/html">
<meta property="og:site_name" content="PyPy">
<meta property="og:title" content="Load and store forwarding in the Toy Optimizer">
<meta property="og:url" content="https://www.pypy.org/posts/2025/12/toy-load-store.html">
<meta property="og:description" content="This is a cross-post from Max Bernstein from his blog where he writes
about programming languages, compilers, optimizations, virtual machines.

A long, long time ago (two years!) CF Bolz-Tereick and I">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-12-24T23:00:00Z">
<meta property="article:tag" content="toy-optimizer">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../../../index.html">
                    <image id="toplogo" src="../../../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../../../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../../../compat.html">Compatibility</a> </li>  
                    <li> <a href="../../../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../../../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href="../../../blog/">Index</a> </li>  
                    <li> <a href="../../../categories/">Tags</a> </li>  
                    <li> <a href="../../../archive.html">Archive by year</a> </li>  
                    <li> <a href="../../../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../../../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../../../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../../../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../../../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Search…" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><div class="post">
          <header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Load and store forwarding in the Toy Optimizer</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../../authors/max-bernstein.html">Max Bernstein</a>
            </span></p>
            <p class="dateline">
            <a href="#" rel="bookmark">
            <time class="published dt-published" datetime="2025-12-24T23:00:00Z" itemprop="datePublished" title="2025-12-24 23:00">2025-12-24 23:00</time></a>
            </p>
            
                <p class="commentline">            <a href="toy-load-store.html#utterances-thread">Comments</a>


            
        </p>
</div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
      <p>This is a <a href="https://bernsteinbear.com/blog/toy-load-store/" rel="canonical">cross-post</a> from Max Bernstein from his blog where he writes
about programming languages, compilers, optimizations, virtual machines.</p>
<hr>
<p>A long, long time ago (two years!) <a href="https://cfbolz.de/">CF Bolz-Tereick</a> and I made a <a href="https://www.youtube.com/watch?v=w-UHg0yOPSE">video
about load/store forwarding</a> and an accompanying <a href="https://gist.github.com/tekknolagi/4e3fa26d350f6d3b39ede40d372b97fe">GitHub Gist</a>
about load/store forwarding (also called load elimination) in the Toy Optimizer. I
said I would write a blog post about it, but never found the time—it got lost
amid a sea of large life changes.</p>
<p>It's a neat idea: do an abstract interpretation over the trace, modeling the
heap at compile-time, eliminating redundant loads and stores. That means it's
possible to optimize traces like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
<span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">load</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">)</span>
<span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">load</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">load</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="n">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_something</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="p">)</span>
</pre></div>

<p>into traces like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
<span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">load</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">)</span>
<span class="n">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_something</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span>
</pre></div>

<p>(where <code>load(v0, 5)</code> is equivalent to <code>*(v0+5)</code> in C syntax and <code>store(v0, 6,
123)</code> is equvialent to <code>*(v0+6)=123</code> in C syntax)</p>
<p>This indicates that we were able to eliminate two redundant loads by keeping
around information about previous loads and stores. Let's get to work making
this possible.</p>
<h3 id="the-usual-infrastructure">The usual infrastructure<a href="#the-usual-infrastructure" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>We'll start off with the usual infrastructure from the <a href="https://pypy.org/categories/toy-optimizer.html">Toy
Optimizer series</a>: a very stringly-typed representation of a
<a href="https://gist.github.com/tekknolagi/4e3fa26d350f6d3b39ede40d372b97fe#file-port-py-L4-L112">trace-based SSA IR</a> and a union-find rewrite mechanism.</p>
<p>This means we can start writing some new optimization pass and our first test:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="c1"># TODO: copy an optimized version of bb into opt_bb</span>
    <span class="k">return</span> <span class="n">opt_bb</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_two_loads</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = load(var0, 0)</span>
<span class="s2">var2 = escape(var1)</span>
<span class="s2">var3 = escape(var1)"""</span>
</pre></div>

<p>This test is asserting that we can remove duplicate loads. Why load twice if we
can cache the result? Let's make that happen.</p>
<h3 id="caching-loads">Caching loads<a href="#caching-loads" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>To do this, we'll model the the heap at compile-time. When I say "model", I
mean that we will have an imprecise but correct abstract representation of the
heap: we don't (and can't) have knowledge of every value, but we can know for
sure that some addresses have certain values.</p>
<p>For example, if we have observed a load from object <em>O</em> at offset <em>8</em> <code>v0 =
load(O, 8)</code>, we know that the SSA value <code>v0</code> is at <code>heap[(O, 8)]</code>. That sounds
tautological, but it's not. Future loads can make use of this information.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="n">Operation</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">Constant</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

<span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="c1"># Stores things we know about the heap at... compile-time.</span>
    <span class="c1"># Key: an object and an offset pair acting as a heap address</span>
    <span class="c1"># Value: a previous SSA value we know exists at that address</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">load_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">compile_time_heap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">load_info</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">previous</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">op</span><span class="o">.</span><span class="n">make_equal_to</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">compile_time_heap</span><span class="p">[</span><span class="n">load_info</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>This pass records information about loads and uses the result of a previous
cached load operation if available. We treat the pair of (SSA value, offset) as
an address into our abstract heap.</p>
<p>That's great! If you run our simple test, it should now pass. But what happens
if we store into that address before the second load? Oops...</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_store_to_same_object_offset_invalidates_load</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">var3</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var3</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = load(var0, 0)</span>
<span class="s2">var2 = store(var0, 0, 5)</span>
<span class="s2">var3 = load(var0, 0)</span>
<span class="s2">var4 = escape(var1)</span>
<span class="s2">var5 = escape(var3)"""</span>
</pre></div>

<p>This test fails because we are incorrectly keeping around <code>var1</code> in our
abstract heap. We need to get rid of it and not replace <code>var3</code> with <code>var1</code>.</p>
<h3 id="invalidating-cached-loads">Invalidating cached loads<a href="#invalidating-cached-loads" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>So it turns out we have to also model stores in order to cache loads correctly.
One valid, albeit aggressive, way to do that is to throw away all the
information we know at each store operation:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">compile_time_heap</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="c1"># ...</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>That makes our test pass—yay!—but at great cost. It means any store
operation mucks up redundant loads. In our world where we frequently read from
and write to objects, this is what we call a huge bummer.</p>
<p>For example, a store to offset 4 on some object should never interfere with a
load from a different offset on the same object<sup id="fnref:size"><a class="footnote-ref" href="toy-load-store.html#fn:size">1</a></sup>. We should be able to
keep our load from offset 0 cached here:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_store_to_same_object_different_offset_does_not_invalidate_load</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">var3</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var3</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = load(var0, 0)</span>
<span class="s2">var2 = store(var0, 4, 5)</span>
<span class="s2">var3 = escape(var1)</span>
<span class="s2">var4 = escape(var1)"""</span>
</pre></div>

<p>We could try instead checking if our specific (object, offset) pair is in the
heap and only removing cached information about that offset and that object.
That would definitely help!</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">load_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">load_info</span> <span class="ow">in</span> <span class="n">compile_time_heap</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">compile_time_heap</span><span class="p">[</span><span class="n">load_info</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="c1"># ...</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>It makes our test pass, too, which is great news.</p>
<p>Unfortunately, this runs into problems due to aliasing: it's entirely possible
that our compile-time heap could contain a pair <code>(v0, 0)</code> and a pair <code>(v1, 0)</code> where <code>v0</code>
and <code>v1</code> are the same object (but not known to the optimizer). Then we might
run into a situation where we incorrectly cache loads because the optimizer
doesn't know our abstract addresses <code>(v0, 0)</code> and <code>(v1, 0)</code> are actually the
same pointer at run-time.</p>
<p>This means that we are breaking abstract interpretation rules: our abstract
interpreter has to correctly model <em>all</em> possible outcomes at run-time. This
means to me that we should instead pick some tactic in-between clearing all
information (correct but over-eager) and clearing only exact matches of
object+offset (incorrect).</p>
<p>The term that will help us here is called an <em>alias class</em>. It is a name for a
way to efficiently partition objects in your abstract heap into completely
disjoint sets. Writes to any object in one class never affect objects in
another class.</p>
<p>Our very scrappy alias classes will be just based on the offset: each offset is
a different alias class. If we write to any object at offset K, we have to
invalidate all of our compile-time offset K knowledge—even if it's for
another object. This is a nice middle ground, and it's possible because our
(made up) object system guarantees that distinct objects do not overlap, and
also that we are not writing out-of-bounds.<sup id="fnref:tbaa"><a class="footnote-ref" href="toy-load-store.html#fn:tbaa">2</a></sup></p>
<p>So let's remove all of the entries from <code>compile_time_heap</code> where the offset
matches the offset in the current <code>store</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">compile_time_heap</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">load_info</span><span class="p">:</span> <span class="n">value</span>
                <span class="k">for</span> <span class="n">load_info</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">compile_time_heap</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">load_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">offset</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="c1"># ...</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>Great! Now our test passes.</p>
<p>This concludes the load optimization section of the post. We have modeled
enough of loads and stores that we can eliminate redundant loads. Very cool.
But we can go further.</p>
<h3 id="caching-stores">Caching stores<a href="#caching-stores" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Stores don't just invalidate information. They also give us new information!
Any time we see an operation of the form <code>v1 = store(v0, 8, 5)</code> we also learn
that <code>load(v0, 8) == 5</code>! Until it gets invalidated, anyway.</p>
<p>For example, in this test, we can eliminate the load from <code>var0</code> at offset 0:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_load_after_store_removed</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = store(var0, 0, 5)</span>
<span class="s2">var2 = load(var0, 1)</span>
<span class="s2">var3 = escape(5)</span>
<span class="s2">var4 = escape(var2)"""</span>
</pre></div>

<p>Making that work is thankfully not very hard; we need only add that new
information to the compile-time heap after removing all the
potentially-aliased info:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">compile_time_heap</span> <span class="o">=</span> <span class="c1"># ... as before ...</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">compile_time_heap</span><span class="p">[(</span><span class="n">obj</span><span class="p">,</span> <span class="n">offset</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_value</span>  <span class="c1"># NEW!</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="c1"># ...</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>This makes the test pass. It makes another test fail, but only
because—oops—we now know more. You can delete the old test because the new
test supersedes it.</p>
<p>Now, note that we are not removing the store. This is because we have nothing
in our optimizer that keeps track of what might have observed the side-effects
of the store. What if the object got <code>escape</code>d? Or someone did a load later on?
We would only be able to remove the store (<code>continue</code>) if we could guarantee it
was not observable.</p>
<p>In our current framework, this only happens in one case: someone is doing a
store of the exact same value that already exists in our compile-time heap.
That is, either the same constant, or the same SSA value. If we see this, then
we can completely skip the second store instruction.</p>
<p>Here's a test case for that, where we have gained information from the load
instruction that we can then use to get rid of the store instruction:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_load_then_store</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">arg1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var1</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = load(var0, 0)</span>
<span class="s2">var2 = escape(var1)"""</span>
</pre></div>

<p>Let's make it pass. To do that, first we'll make an equality function that
works for both constants and operations. Constants are equal if their values
are equal, and operations are equal if they are the identical (by
address/pointer) operation.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">eq_value</span><span class="p">(</span><span class="n">left</span><span class="p">:</span> <span class="n">Value</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span>
    <span class="k">return</span> <span class="n">left</span> <span class="ow">is</span> <span class="n">right</span>
</pre></div>

<p>This is a partial equality: if two operations are not equal under <code>eq_value</code>,
it doesn't mean that they are different, only that we don't know that they are
the same.</p>
<p>Then, after that, we need only check if the current value in the compile-time
heap is the same as the value being stored in. If it is, wonderful. No need to
store. <code>continue</code> and don't append the operation to <code>opt_bb</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">compile_time_heap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"store"</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">store_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">current_value</span> <span class="o">=</span> <span class="n">compile_time_heap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">store_info</span><span class="p">)</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">eq_value</span><span class="p">(</span><span class="n">current_value</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>  <span class="c1"># NEW!</span>
                <span class="k">continue</span>
            <span class="n">compile_time_heap</span> <span class="o">=</span> <span class="c1"># ... as before ...</span>
            <span class="c1"># ...</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"load"</span><span class="p">:</span>
            <span class="n">load_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">get_num</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">load_info</span> <span class="ow">in</span> <span class="n">compile_time_heap</span><span class="p">:</span>
                <span class="n">op</span><span class="o">.</span><span class="n">make_equal_to</span><span class="p">(</span><span class="n">compile_time_heap</span><span class="p">[</span><span class="n">load_info</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="n">compile_time_heap</span><span class="p">[</span><span class="n">load_info</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>This makes our load-then-store pass and it also makes other tests pass too,
like eliminating a store after another store!</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_store_after_store</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">arg1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = store(var0, 0, 5)"""</span>
</pre></div>

<p>Unfortunately, this only works if the values—constants or SSA values—are
known to be the same. If we store <em>different</em> values, we can't optimize. In the
live stream, we left this an exercise for the viewer:</p>
<div class="code"><pre class="code literal-block"><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">xfail</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_exercise_for_the_reader</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">arg0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">bb</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">optimize_load_store</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">var0 = getarg(0)</span>
<span class="s2">var1 = store(var0, 0, 7)</span>
<span class="s2">var2 = escape(7)"""</span>
</pre></div>

<p>We would only be able to optimize this away if we had some notion of a store
being <em>dead</em>. In this case, that is a store in which the value is never read
before being overwritten.</p>
<h3 id="removing-dead-stores">Removing dead stores<a href="#removing-dead-stores" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>TODO, I suppose. I have not gotten this far yet. If I get around to it, I will
come back and update the post.</p>
<h3 id="in-the-real-world">In the real world<a href="#in-the-real-world" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>This small optimization pass may seem silly or fiddly—when would we ever see
something like this in a real IR?—but it's pretty useful. Here's the Ruby
code that got me thinking about it again some years later for ZJIT:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">C</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">initialize</span>
<span class="w">    </span><span class="vi">@a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="vi">@b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="vi">@c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>CRuby has a shape system and ZJIT makes use of it, so we end up optimizing this
code (if it's monomorphic) into a series of shape checks and stores. The HIR
might end up looking something like the mess below, where I've annotated the
shape guards (can be thought of as loads) and stores with asterisks:</p>
<div class="code"><pre class="code literal-block"><span class="n">fn</span><span class="w"> </span><span class="n">initialize</span><span class="p">@</span><span class="n">tmp</span><span class="o">/</span><span class="n">init</span><span class="p">.</span><span class="n">rb</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span>
<span class="cp"># ...</span>
<span class="n">bb2</span><span class="p">(</span><span class="n">v6</span><span class="o">:</span><span class="n">BasicObject</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="nl">v10</span><span class="p">:</span><span class="n">Fixnum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">Value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="nl">v31</span><span class="p">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardType</span><span class="w"> </span><span class="n">v6</span><span class="p">,</span><span class="w"> </span><span class="n">HeapBasicObject</span>
<span class="o">*</span><span class="w"> </span><span class="n">v32</span><span class="o">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardShape</span><span class="w"> </span><span class="n">v31</span><span class="p">,</span><span class="w"> </span><span class="mh">0x400000</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v32</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">@</span><span class="n">a</span><span class="mh">@0x10</span><span class="p">,</span><span class="w"> </span><span class="n">v10</span>
<span class="w">  </span><span class="n">WriteBarrier</span><span class="w"> </span><span class="n">v32</span><span class="p">,</span><span class="w"> </span><span class="n">v10</span>
<span class="w">  </span><span class="nl">v35</span><span class="p">:</span><span class="n">CShape</span><span class="p">[</span><span class="mh">0x40008e</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">CShape</span><span class="p">(</span><span class="mh">0x40008e</span><span class="p">)</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v32</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="n">_shape_id</span><span class="mh">@0x4</span><span class="p">,</span><span class="w"> </span><span class="n">v35</span>
<span class="w">  </span><span class="nl">v16</span><span class="p">:</span><span class="n">Fixnum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">Value</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="w">  </span><span class="nl">v37</span><span class="p">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardType</span><span class="w"> </span><span class="n">v6</span><span class="p">,</span><span class="w"> </span><span class="n">HeapBasicObject</span>
<span class="o">*</span><span class="w"> </span><span class="n">v38</span><span class="o">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardShape</span><span class="w"> </span><span class="n">v37</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40008e</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v38</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">@</span><span class="n">b</span><span class="mh">@0x18</span><span class="p">,</span><span class="w"> </span><span class="n">v16</span>
<span class="w">  </span><span class="n">WriteBarrier</span><span class="w"> </span><span class="n">v38</span><span class="p">,</span><span class="w"> </span><span class="n">v16</span>
<span class="w">  </span><span class="nl">v41</span><span class="p">:</span><span class="n">CShape</span><span class="p">[</span><span class="mh">0x40008f</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">CShape</span><span class="p">(</span><span class="mh">0x40008f</span><span class="p">)</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v38</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="n">_shape_id</span><span class="mh">@0x4</span><span class="p">,</span><span class="w"> </span><span class="n">v41</span>
<span class="w">  </span><span class="nl">v22</span><span class="p">:</span><span class="n">Fixnum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">Value</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">  </span><span class="nl">v43</span><span class="p">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardType</span><span class="w"> </span><span class="n">v6</span><span class="p">,</span><span class="w"> </span><span class="n">HeapBasicObject</span>
<span class="o">*</span><span class="w"> </span><span class="n">v44</span><span class="o">:</span><span class="n">HeapBasicObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GuardShape</span><span class="w"> </span><span class="n">v43</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40008f</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v44</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">@</span><span class="n">c</span><span class="mh">@0x20</span><span class="p">,</span><span class="w"> </span><span class="n">v22</span>
<span class="w">  </span><span class="n">WriteBarrier</span><span class="w"> </span><span class="n">v44</span><span class="p">,</span><span class="w"> </span><span class="n">v22</span>
<span class="w">  </span><span class="nl">v47</span><span class="p">:</span><span class="n">CShape</span><span class="p">[</span><span class="mh">0x400090</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">CShape</span><span class="p">(</span><span class="mh">0x400090</span><span class="p">)</span>
<span class="o">*</span><span class="w"> </span><span class="n">StoreField</span><span class="w"> </span><span class="n">v44</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="n">_shape_id</span><span class="mh">@0x4</span><span class="p">,</span><span class="w"> </span><span class="n">v47</span>
<span class="w">  </span><span class="n">CheckInterrupts</span>
<span class="w">  </span><span class="n">Return</span><span class="w"> </span><span class="n">v22</span>
</pre></div>

<p>If we had store-load forwarding in ZJIT, we could get rid of the intermediate
shape guards; they would know the shape from the previous <code>StoreField</code>
instruction. If we had dead store elimination, we could get rid of the
intermediate shape writes; they are never read. (And the repeated type guards
to check if it's a heap object still are just silly and need to get removed
eventually.)</p>
<p>This is on the roadmap and will make object initialization even faster than it
is right now.</p>
<h3 id="wrapping-up">Wrapping up<a href="#wrapping-up" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Thanks for reading the text version of the video that CF and I made a while
back. Now you know how to do load/store elimination on traces.</p>
<p>I think this does not need too much extra work to get it going on full CFGs; a
block is pretty much the same as a trace, so you can do a block-local version
without much fuss. If you want to go global, you need dominator information and
gen-kill sets.</p>
<p>Maybe I will touch on this in a future post...</p>
<h3 id="thank-you">Thank you<a href="#thank-you" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Thank you to CF, who walked me through this live on a stream two years ago!
This blog post wouldn't be possible without you.</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:size">
<p>In this toy optimizer example, we are assuming that all reads and writes
are the same size and different offsets don't overlap at all. This is often
the case for managed runtimes, where object fields are pointer-sized and
all reads/writes are pointed aligned. <a class="footnote-backref" href="toy-load-store.html#fnref:size" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:tbaa">
<p>We could do better. If we had type information, we could also use that
to make alias classes. Writes to a List will never overlap with writes to a
Map, for example. This requires your compiler to have strict aliasing—if
you can freely cast between types, as in C, then this tactic goes out the
window.</p>
<p>This is called <a href="../../../assets/img/tbaa.pdf">Type-based alias analysis</a> (PDF). <a class="footnote-backref" href="toy-load-store.html#fnref:tbaa" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
</ol>
</div>
      </div>
      <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/toy-optimizer.html" rel="tag">toy-optimizer</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../07/pypy-v7320-release.html" rel="prev" title="PyPy v7.3.20 release">Previous post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
                      <div data-title="Load and store forwarding in the Toy Optimizer" id="utterances-thread"></div>
        <script src="https://utteranc.es/client.js" repo="pypy/pypy.org" issue-term="title" label="Comments" theme="github-light" crossorigin="anonymous"></script></section>
</div>
    <div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/12/toy-load-store.html" class="listtitle">Load and store forwarding in the Toy Optimizer</a>
      </li>
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (9)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (6)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div>    </div>
</article></main><footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    © 2026 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
     
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
     
    Last built 2026-01-17T00:22
  </div>
  <div style="margin-left: auto">
  <a href="../../../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../../../assets/js/styles.js"></script></footer>
</div>
</body>
</html>