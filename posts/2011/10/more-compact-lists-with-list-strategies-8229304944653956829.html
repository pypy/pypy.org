<html><body><p>Since we come closer to merging the list-strategy branch I want to try to explain this memory optimization today. </p><p>Datatypes in PyPy are stored as <tt>W_&lt;type&gt;Objects</tt> (e.g. <tt>W_StringObject to represent strings, W_IntObject</tt> to represent ints). This is necessary due to the dynamic nature of Python. So the actual value (e.g. string, integer) is stored inside that box, resulting in an indirection. When having a large amount of such boxed objects, for example in a list, the wasted memory can become quite large. </p><a href="https://3.bp.blogspot.com/-0-qMMmAxRro/TpQoKo728xI/AAAAAAAAAYA/Z5nNNEYYquk/s1600/overhead_before.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5662194794763842322" src="https://3.bp.blogspot.com/-0-qMMmAxRro/TpQoKo728xI/AAAAAAAAAYA/Z5nNNEYYquk/s400/overhead_before.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 183px;"></a>  <p>If you have a closer look at such lists, you will see that in many of them only one type of data is stored and only few (and smaller) lists store mixed types. Another thing to observe is that those lists often won't change the types of the objects they contain at runtime very often. For instance a list of a million integers is very unlikely to suddenly get a string appended to it. </p><h2>List Strategies</h2><p>The goal of this work is to write an optimization that exploits this behaviour. Instead of wrapping all items in a list, we implement lists in a way that they are optimized for storing certain (primitive) datatypes. These implementations store the content of the list in unwrapped form, getting rid of the extra indirection and wrapper objects. </p><p>One approach would be to add a level of indirection, making each <tt>W_ListObject</tt> instance point to another object that stores the actual content. For this other object, several implementations would exist, for every datatype we want to store without wrapping it (as well as a general one that deals with arbitrary content). The data layout would look something like this:</p><a href="https://3.bp.blogspot.com/-LWtyy4ORb00/TpQohbOjg2I/AAAAAAAAAYM/kgpVemG8-9o/s1600/with_special_impl.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5662195186221155170" src="https://3.bp.blogspot.com/-LWtyy4ORb00/TpQohbOjg2I/AAAAAAAAAYM/kgpVemG8-9o/s400/with_special_impl.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 193px;"></a>  <p>This approach has the problem that we need two indirections to get to the data and that the implementation instances need memory themselves.</p><p>What we would like to do is to make the <tt>W_ListObject</tt> point to an RPython list directly, that contains either wrapped or unwrapped data. This plan has the problem that storing different unwrapped data is not directly possible in RPython.  </p><p>To solve the problem, we use the <tt>rerased</tt> RPython library module. It allows us to erase the type of an object, in this case lists, and returns something similar to <tt>void-star</tt> in C, or <tt>Object</tt> in Java. This object is then stored on the <tt>W_ListObject</tt> in the field <tt>storage</tt>. If we want to work with the list, for example to append or delete items, we need to unerase the storage again.</p><p>Example for rerase: </p><pre>storage = erase([1 ,2 ,3 ,4])
# storage is an opaque object that you can do nothing with
....
l = unerase(storage)
l.clear()
</pre><p>Now that we know how to make the <tt>W_ListObject</tt> point directly to wrapped or unwrapped data, we need to find out how to actually do any operations on this data. This can be accomplished by adding another field to our <tt>W_ListObject</tt>. This field points to a <tt>ListStrategy</tt> object. The actual implementation of <tt>W_ListObject</tt> is now deferred to those <tt>ListStrategy</tt> classes. For instance, a <tt>W_ListObject</tt> which holds only integers will use the <tt>IntegerListStrategy</tt>.</p><p>When the type of content is being changed, we need to change the used strategy as well as the storage in compatible ways. For example when we add a string to the list of integers we need to switch to the <tt>ObjectListStrategy</tt> and change the storage to be a list of wrapped objects. Thus the currently used strategy always knows what to do with what is currently in the storage.</p><a href="https://4.bp.blogspot.com/-hFXLNQ0Ry0I/TpQohnZHRpI/AAAAAAAAAYY/-AUuRfoFYqA/s1600/with_strategies.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5662195189486667410" src="https://4.bp.blogspot.com/-hFXLNQ0Ry0I/TpQohnZHRpI/AAAAAAAAAYY/-AUuRfoFYqA/s400/with_strategies.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 130px;"></a>  <p>As you can see, we now save one level of indirections by storing some of the data unwrapped. Of course each operation on a list needs to go via the strategy, but since we save one indirection for each element stored in that list and the <tt>Strategy</tt> classes are singletons, the benefits outweigh the costs.</p><p>Currently there are only strategies for integers and strings since many lists seem to have these datatypes. Other strategies i.e for floats and unicode strings are planned. We also implemented two special strategies for empty lists and range-lists. The <tt>EmptyListStrategy</tt>'s storage is <tt>None</tt>. If objects are added to the list we just switch to the appropriate strategy (determined by the item's type). <tt>RangeListsStrategies</tt> do not store any items at all. Instead they only store values describing the range of the list, i.e. start, step and length. On any operations that changes the data of the list we switch to the <tt>IntegerStrategy</tt>.</p><p>A nice side-effect of storing unwrapped datatypes is that we can implement optimized methods for certain cases. For instance, since comparison of unwrapped integers is now much faster than comparison between arbitrary objects, we can rewrite the sorting methods for lists containing integers.</p><h2>Microbenchmarks</h2><p>Finally here is an early overview of the memory consumption of different Python implementations: <tt>CPython, PyPy</tt> and <tt>PyPy-list</tt> which uses list-strategies. To demonstrate how powerful list-strategies can be in the best case, we wrote benchmarks that create a list of integers, a list of strings and a range-list each with one million elements each and then reads out the heap size of the process as reported by the OS. </p><p>The results are as follows: </p><a href="https://2.bp.blogspot.com/-FG6r9y8tXF4/TpQohzPkeNI/AAAAAAAAAYk/h-oZpthkFEQ/s1600/osheapsize.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5662195192667863250" src="https://2.bp.blogspot.com/-FG6r9y8tXF4/TpQohzPkeNI/AAAAAAAAAYk/h-oZpthkFEQ/s400/osheapsize.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 252px;"></a>   <p>The savings on integers and strings in this ideal case are quite big.</p><p>The benchmark for range-lists is a little unfair, since in <tt>CPython</tt> one could accomplish the same memory behaviour using <tt>xrange</tt>. However, in PyPy users won't notice that internally the list does not store all items, making it still possible to use all list methods, such as <tt>append</tt> or <tt>delete</tt>.</p><h2>Conclusion</h2><p>We hope that list strategies bring memory savings for applications that use homogeneous lists of primitive types. Furthermore, operations on such lists tend to be somewhat faster as well. This also integrates well with the JIT. The list strategies optimizations will be merged to the PyPy's default branch at some point in the next months. An equivalent optimization for dictionaries has already been merged (and is part of PyPy 1.6), one for sets is coming in the future.</p><p>Lukas Diekmann and Carl Friedrich Bolz</p></body></html>