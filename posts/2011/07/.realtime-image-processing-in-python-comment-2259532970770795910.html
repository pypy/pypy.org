<html><body><p>hi @jacob: below is code which runs either multi core, vectorised SIMD, and on a GPU if you like.  You'll notice that it is way shorter and more elegant than the 'pure python' code.<br><br>def sobelEdgeDetect(im=DImage, p=Position):<br>....wX = outerproduct([1,2,1],[-1,0,1])<br>....wY = transpose(wX)<br><br>....Gx = convolve(wX,im,p)<br>....Gy = convolve(wY,im,p)<br><br>....return sqrt(Gx**2 + Gy**2)<br><br>If pypy is 5x slower than C, and SIMD is 5x faster than C... and using multiple cores is 8x faster than a single core you can see this python code is (5 * 5 * 8) 200x faster than the pypy code.  This is just comparing CPU based code.  Obviously GPU code for real time image processing is very fast compared to CPU based code.<br><br>Things like numpy, pyopengl etc come packaged with various OSes - but chosing those dependencies compared to depending on pypy is a separate issue I guess (but many cpython packaged libraries are packaged for more platforms than pypy).<br><br>Of course using tested, and debugged existing code written in python will save you development time:  for example using sobel written with the scipy library:<br>https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.filters.sobel.html<br><br>The fact is CPython is fast enough, more elegant, and will save you time for realtime image processing - unless you ignore the reality that people use CPython libraries for these tasks.<br><br>Finally the given code does not prove that the frames are all processed in realtime.  They give an average time over all of the frames.  Realtime video requires that you meet your target speed for every frame.  It would need to be extended to measure each frame to make sure that each frame is within the required time budget.</p></body></html>