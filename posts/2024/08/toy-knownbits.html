<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A Knownbits Abstract Domain for the Toy Optimizer, Correctly | PyPy</title>
<link href="../../../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../../rss.xml">
<link rel="canonical" href="https://www.pypy.org/posts/2024/08/toy-knownbits.html">
<link rel="icon" href="../../../favicon2.ico" sizes="16x16">
<link rel="icon" href="../../../favicon32x32.ico" sizes="32x32">
<!--[if lt IE 9]><script src="../../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../../assets/css/tipuesearch.css">
<meta name="author" content="CF Bolz-Tereick">
<link rel="prev" href="../07/toy-abstract-interpretation.html" title="Abstract interpretation in the Toy Optimizer" type="text/html">
<link rel="next" href="conda-forge-proposes-dropping-support-for-pypy.html" title="Conda-forge proposes sunsetting support for PyPy" type="text/html">
<meta property="og:site_name" content="PyPy">
<meta property="og:title" content="A Knownbits Abstract Domain for the Toy Optimizer, Correctly">
<meta property="og:url" content="https://www.pypy.org/posts/2024/08/toy-knownbits.html">
<meta property="og:description" content="After Max' introduction to abstract interpretation for the toy optimizer in the
last post, I want to present a more complicated abstract domain in this post.
This abstract domain reasons about the ind">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-08-03T14:00:00Z">
<meta property="article:tag" content="toy-optimizer">
<meta property="article:tag" content="z3">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../../../index.html">
                    <image id="toplogo" src="../../../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../../../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../../../compat.html">Compatibility</a> </li>  
                    <li> <a href="../../../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../../../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href="../../../blog/">Index</a> </li>  
                    <li> <a href="../../../categories/">Tags</a> </li>  
                    <li> <a href="../../../archive.html">Archive by year</a> </li>  
                    <li> <a href="../../../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../../../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../../../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../../../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../../../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Search…" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><div class="post">
          <header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">A Knownbits Abstract Domain for the Toy Optimizer, Correctly</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../../authors/cf-bolz-tereick.html">CF Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="#" rel="bookmark">
            <time class="published dt-published" datetime="2024-08-03T14:00:00Z" itemprop="datePublished" title="2024-08-03 14:00">2024-08-03 14:00</time></a>
            </p>
            
                <p class="commentline">            <a href="toy-knownbits.html#utterances-thread">Comments</a>


            
        </p>
</div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
      <p>After <a href="https://bernsteinbear.com/blog/toy-abstract-interpretation/">Max' introduction to abstract interpretation for the toy optimizer</a> in the
last post, I want to present a more complicated abstract domain in this post.
This abstract domain reasons about the individual bits of a variable in a trace.
Every bit can be either "known zero", "known one" or "unknown". The abstract
domain is useful for optimizing integer operations, particularly the bitwise operations.
The abstract domain follows quite closely the <a href="https://github.com/torvalds/linux/blob/master/kernel/bpf/tnum.c">tristate abstract domain of the
eBPF verifier in the Linux
Kernel</a>, as
described by the paper
<a href="https://arxiv.org/abs/2105.05398">Sound, Precise, and Fast Abstract Interpretation with Tristate
Numbers</a> by Harishankar Vishwanathan, Matan
Shachnai, Srinivas Narayana, and Santosh Nagarakatte.</p>
<p>The presentation in this post will still be in the context of the
<a href="../../../categories/toy-optimizer">toy optimizer</a>. We'll spend a significant part of
the post convincing ourselves that the abstract domain transfer functions that
we're writing are really correct, using both property-based testing and
automated proofs (again using Z3).</p>
<p>PyPy has implemented and merged a more complicated version of the same abstract
domain for the "real" PyPy JIT. A more thorough explanation of that real world
implementation will follow.</p>
<p>I'd like to thank Max Bernstein and Armin Rigo for lots of great feedback on
drafts of this post. The PyPy implementation was mainly done by Nico
Rittinghaus and me.</p>
<p><strong>Contents:</strong></p>
<div class="toc">
<ul>
<li><a href="toy-knownbits.html#motivation">Motivation</a></li>
<li><a href="toy-knownbits.html#the-knownbits-abstract-domain">The Knownbits Abstract Domain</a></li>
<li><a href="toy-knownbits.html#transfer-functions">Transfer Functions</a></li>
<li><a href="toy-knownbits.html#property-based-tests-with-hypothesis">Property-based Tests with Hypothesis</a></li>
<li><a href="toy-knownbits.html#when-are-transfer-functions-correct-how-do-we-test-them">When are Transfer Functions Correct? How do we test them?</a></li>
<li><a href="toy-knownbits.html#implementing-binary-transfer-functions">Implementing Binary Transfer Functions</a></li>
<li><a href="toy-knownbits.html#addition-and-subtraction">Addition and Subtraction</a></li>
<li><a href="toy-knownbits.html#proving-correctness-of-the-transfer-functions-with-z3">Proving correctness of the transfer functions with Z3</a></li>
<li><a href="toy-knownbits.html#cases-where-this-style-of-z3-proof-doesnt-work">Cases where this style of Z3 proof doesn't work</a></li>
<li><a href="toy-knownbits.html#making-statements-about-precision">Making Statements about Precision</a></li>
<li><a href="toy-knownbits.html#using-the-abstract-domain-in-the-toy-optimizer-for-generalized-constant-folding">Using the Abstract Domain in the Toy Optimizer for Generalized Constant Folding</a></li>
<li><a href="toy-knownbits.html#using-the-knownbits-domain-for-conditional-peephole-rewrites">Using the KnownBits Domain for Conditional Peephole Rewrites</a></li>
<li><a href="toy-knownbits.html#conclusion">Conclusion</a></li>
</ul>
</div>
<h3 id="motivation">Motivation<a href="#motivation" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>In many programs that do bit-manipulation of integers, some of the bits of the
integer variables of the program can be statically known. Here's a simple
example:</p>
<div class="code"><pre class="code literal-block"><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">1</span>
...
<span class="k">if</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span>:
<span class="w">    </span>...
<span class="k">else</span>:
<span class="w">    </span>...
</pre></div>

<p>After the assignment <code>x = a | 1</code>, we know that the lowest bit of <code>x</code> must be <code>1</code>
(the other bits are unknown) and an optimizer could remove the condition <code>x &amp; 1</code> by
constant-folding it to <code>1</code>.</p>
<p>Another (more complicated) example is:</p>
<div class="code"><pre class="code literal-block">assert i &amp; 0b111 == 0 # check that i is a multiple of 8
j = i + 16
assert j &amp; 0b111 == 0
</pre></div>

<p>This kind of code could e.g. happen in a <a href="https://docs.pydrofoil.org/en/latest/">CPU
emulator</a>, where <code>i</code> and <code>j</code> are
integers that represent emulated pointers, and the <code>assert</code>s are alignment
checks. The first assert implies that the lowest three bits of i must be <code>0</code>.
Adding 16 to such a number produces a result where the lowest three bits are
again all <code>0</code>, therefore the second assert is always true. So we would like a
compiler to remove the second assert.</p>
<p>Both of these will optimizations are doable with the help of the knownbits
abstract domain that we'll discuss in the rest of the post.</p>
<h3 id="the-knownbits-abstract-domain">The Knownbits Abstract Domain<a href="#the-knownbits-abstract-domain" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>An abstract value of the knownbits domain needs to be able to store, for every
bit of an integer variable in a program, whether it is known 0, known 1, or
unknown. To represent
three different states, we need 2 bits, which we will call <code>one</code> and <code>unknown</code>.
Here's the encoding:</p>
<table>
<thead><tr>
<th>one</th>
<th>unknown</th>
<th style="text-align: right;">knownbit</th>
</tr></thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td style="text-align: right;">0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td style="text-align: right;">1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td style="text-align: right;">?</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td style="text-align: right;">illegal</td>
</tr>
</tbody>
</table>
<p>The <code>unknown</code> bit is set if we don't know the value of the bit ("?"), the <code>one</code>
bit is set if the bit is known to be a <code>1</code>. Since two bits are enough to encode
four different states, but we only need three, the combination of a set <code>one</code>
bit and a set <code>unknown</code> is not allowed.</p>
<p>We don't just want to encode a single bit, however. Instead, we want to do this
for all the bits of an integer variable. Therefore the instances of the abstract
domain get two integer fields <code>ones</code> and <code>unknowns</code>, where each pair of
corresponding bits encodes the knowledge about the corresponding bit of the
integer variable in the program.</p>
<p>We can start implementing a Python class that works like this:</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="n">ones</span> <span class="p">:</span> <span class="nb">int</span>
    <span class="n">unknowns</span> <span class="p">:</span> <span class="nb">int</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ones</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_well_formed</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_well_formed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># a bit cannot be both 1 and unknown</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_constant</span><span class="p">(</span><span class="n">const</span> <span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">""" Construct a KnownBits corresponding to a constant, where all bits</span>
<span class="sd">        are known."""</span>
        <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">""" Check if the KnownBits instance represents a constant. """</span>
        <span class="c1"># it's a constant if there are no unknowns</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>

<p>We can also add some convenience properties. Sometimes it is easier to work
with an integer where all the <em>known</em> bits are set, or one where the positions
of all the known zeros have a set bit:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">knowns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">""" return an integer where the known bits are set. """</span>
        <span class="c1"># the knowns are just the unknowns, inverted</span>
        <span class="k">return</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">""" return an integer where the places that are known zeros have a bit</span>
<span class="sd">        set. """</span>
        <span class="c1"># it's a 0 if it is known, but not 1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">knowns</span> <span class="o">&amp;</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">ones</span>
</pre></div>

<p>Also, for debugging and for writing tests we want a way to print the known bits
in a human-readable form, and also to have a way to construct a <code>KnownBits</code>
instance from a string. It's not important to understand the details of
<code>__str__</code> or <code>from_str</code> for the rest of the post, so I'm putting them into a fold:</p>
<details><summary><code>KnownBits</code> from and to string conversions</summary><div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">():</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">"KnownBits.from_constant(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ones</span><span class="si">}</span><span class="s2">)"</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"KnownBits(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ones</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span><span class="si">}</span><span class="s2">)"</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ones</span><span class="p">,</span> <span class="n">unknowns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span>
        <span class="c1"># construct the string representation right to left</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ones</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">unknowns</span><span class="p">:</span>
                <span class="k">break</span> <span class="c1"># we leave off the leading known 0s</span>
            <span class="k">if</span> <span class="n">ones</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">unknowns</span><span class="p">:</span>
                <span class="c1"># -1 has all bits set in two's complement, so the leading</span>
                <span class="c1"># bits are all 1</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'1'</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"..."</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">unknowns</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># -1 has all bits set in two's complement, so the leading bits</span>
                <span class="c1"># are all ?</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">ones</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"?"</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"..."</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">unknowns</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'?'</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ones</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'1'</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'0'</span><span class="p">)</span>
            <span class="n">ones</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
            <span class="n">unknowns</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'0'</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">""" Construct a KnownBits instance that from a string. String can start</span>
<span class="sd">        with ...1 to mean that all higher bits are 1, or ...? to mean that all</span>
<span class="sd">        higher bits are unknown. Otherwise it is assumed that the higher bits</span>
<span class="sd">        are all 0. """</span>
        <span class="n">ones</span><span class="p">,</span> <span class="n">unknowns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">startindex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"...?"</span><span class="p">):</span>
            <span class="n">unknowns</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">startindex</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"...1"</span><span class="p">):</span>
            <span class="n">ones</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">startindex</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startindex</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">ones</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
            <span class="n">unknowns</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">'1'</span><span class="p">:</span>
                <span class="n">ones</span> <span class="o">|=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">'?'</span><span class="p">:</span>
                <span class="n">unknowns</span> <span class="o">|=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">all_unknown</span><span class="p">():</span>
<span class="w">        </span><span class="sd">""" convenience constructor for the "all bits unknown" abstract value</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s2">"...?"</span><span class="p">)</span>
</pre></div>



</details><p>And here's a <a href="https://pytest.org">pytest</a>-style unit test for <code>str</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_str</span><span class="p">():</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="s1">'0'</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="o">==</span> <span class="s1">'101'</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">KnownBits</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mb">0b10</span><span class="p">))</span> <span class="o">==</span> <span class="s1">'1?1'</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">KnownBits</span><span class="p">(</span><span class="o">~</span><span class="mb">0b1111</span><span class="p">,</span> <span class="mb">0b10</span><span class="p">))</span> <span class="o">==</span> <span class="s1">'...100?0'</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">KnownBits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">~</span><span class="mb">0b1</span><span class="p">))</span> <span class="o">==</span> <span class="s1">'...?1'</span>
</pre></div>

<p>An instance of <code>KnownBits</code> represents a set of integers, namely those that match
the known bits stored in the instance. We can write a method <code>contains</code> that
takes a concrete <code>int</code> value and returns <code>True</code> if the value matches the
pattern of the known bits:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">""" Check whether the KnownBits instance contains the concrete integer</span>
<span class="sd">        `value`. """</span>
        <span class="c1"># check whether value matches the bit pattern. in the places where we</span>
        <span class="c1"># know the bits, the value must agree with ones.</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">knowns</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span>
</pre></div>

<p>and a test:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_contains</span><span class="p">():</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'1?1'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">k1</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mb">0b111</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">k1</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mb">0b101</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">k1</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mb">0b110</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">k1</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mb">0b011</span><span class="p">)</span>

    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'...?1'</span><span class="p">)</span> <span class="c1"># all odd numbers</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">101</span><span class="p">,</span> <span class="mi">100</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">k2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<h3 id="transfer-functions">Transfer Functions<a href="#transfer-functions" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Now that we have implemented the basics of the <code>KnownBits</code> class, we need to
start implementing the transfer functions. They are for computing what we know
about the <em>results</em> of an operation, given the knowledge we have about the bits
of the arguments.</p>
<p>We'll start with a simple unary operation, <code>invert(x)</code> (which is <code>~x</code> in Python
and C syntax), which flips all the bits of at integer. If we know some bits of
the arguments, we can compute the corresponding bits of the result. The unknown
bits remain unknown.</p>
<p>Here's the code:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_invert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># self.zeros has bits set where the known 0s are in self</span>
        <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span><span class="p">)</span>
</pre></div>

<p>And a unit-test:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_invert</span><span class="p">():</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'01?01?01?'</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_invert</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span> <span class="o">==</span> <span class="s1">'...10?10?10?'</span>

    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'...?'</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_invert</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span> <span class="o">==</span> <span class="s1">'...?'</span>
</pre></div>

<p>Before we continue with further transfer functions, we'll think about
correctness of the transfer functions and build up some test infrastructure. To
test transfer functions, it's quite important to move being simple example-style
unit tests. The state-space for more complicated binary transfer functions is
extremely large and it's too easy to do something wrong in a corner case.
Therefore we'll look at property-based-test for <code>KnownBits</code> next.</p>
<h3 id="property-based-tests-with-hypothesis">Property-based Tests with Hypothesis<a href="#property-based-tests-with-hypothesis" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>We want to do property-based tests of <code>KnownBits</code>, to try
make it less likely that we'll get a corner-case in the implementation wrong.
We'll use <a href="https://hypothesis.readthedocs.io/en/latest/">Hypothesis</a> for that.</p>
<p>I can't give a decent introduction to Hypothesis here, but want to give a few
hints about the API. Hypothesis is a way to run unit tests with randomly
generated input. It provides <em>strategies</em> to describe the data that the test
functions expects. Hypothesis provides primitive strategies (for things like
integers, strings, floats, etc) and ways to build composite strategies out of
the primitive ones.</p>
<p>To be able to write the tests, we need to generate random <code>KnownBits</code> instances,
and we also want an <code>int</code> instance that is a member of the <code>KnownBits</code> instance.
We generate tuples of <code>(KnownBits, int)</code> together, to ensure this property.
We'll ask Hypothesis to generate us a random concrete <code>int</code> as the concrete
value, and then we'll also generate a second random <code>int</code> to use as the
<code>unknown</code> masks (i.e. which bits of the concrete int we don't know in the
<code>KnownBits</code> instance). Here's a function that takes two such ints and builds the
tuple:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">build_knownbits_and_contained_number</span><span class="p">(</span><span class="n">concrete_value</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">unknowns</span> <span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="c1"># to construct a valid KnownBits instance, we need to mask off the unknown</span>
    <span class="c1"># bits</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">concrete_value</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">unknowns</span>
    <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">),</span> <span class="n">concrete_value</span>
</pre></div>

<p>We can turn this function into a hypothesis strategy to generate input data
using the <code>strategies.builds</code> function:</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span><span class="w"> </span><span class="nn">hypothesis</span><span class="w"> </span><span class="kn">import</span> <span class="n">strategies</span><span class="p">,</span> <span class="n">given</span><span class="p">,</span> <span class="n">settings</span>

<span class="n">ints</span> <span class="o">=</span> <span class="n">strategies</span><span class="o">.</span><span class="n">integers</span><span class="p">()</span>

<span class="n">random_knownbits_and_contained_number</span> <span class="o">=</span> <span class="n">strategies</span><span class="o">.</span><span class="n">builds</span><span class="p">(</span>
    <span class="n">build_knownbits_and_contained_number</span><span class="p">,</span>
    <span class="n">ints</span><span class="p">,</span> <span class="n">ints</span>
<span class="p">)</span>
</pre></div>

<p>One important special case of <code>KnownBits</code> are the constants, which contain only
a single concrete value. We'll also generate some of those specifically, and
then combine the <code>random_knownbits_and_contained_number</code> strategy with it:</p>
<div class="code"><pre class="code literal-block"><span class="n">constant_knownbits</span> <span class="o">=</span> <span class="n">strategies</span><span class="o">.</span><span class="n">builds</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="p">(</span><span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">value</span><span class="p">),</span>
    <span class="n">ints</span>
<span class="p">)</span>

<span class="n">knownbits_and_contained_number</span> <span class="o">=</span> <span class="n">constant_knownbits</span> <span class="o">|</span> <span class="n">random_knownbits_and_contained_number</span>
</pre></div>

<p>Now we can write the first property-based tests, for the <code>KnownBits.contains</code>
method:</p>
<div class="code"><pre class="code literal-block"><span class="nd">@given</span><span class="p">(</span><span class="n">knownbits_and_contained_number</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_contains</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">assert</span> <span class="n">k</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>

<p>The <code>@given</code> decorator is used to tell Hypothesis which strategy to use to
generate random data for the test function. Hypothesis will run the test with a
number of random examples (100 by default). If it finds an error, it will try to
minimize the example needed that demonstrates the problem, to try to make it
easier to understand what is going wrong. It also saves all failing cases into
an example database and tries them again on subsequent runs.</p>
<p>This test is as much a check for whether we got the strategies right as it is
for the logic in <code>KnownBits.contains</code>. Here's an example output of random
concrete and abstract values that we are getting here:</p>
<div class="code"><pre class="code literal-block"><span class="mf">110000011001101</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">0</span><span class="err">???</span><span class="mf">1</span>
<span class="mf">...1011011</span><span class="w"> </span><span class="mf">...1011011</span>
<span class="mf">...1001101110101000010010011111011</span><span class="w"> </span><span class="mf">...1001101110101000010010011111011</span>
<span class="mf">...1001101110101000010010011111011</span><span class="w"> </span><span class="mf">...100110111010100001</span><span class="err">?</span><span class="mf">010</span><span class="err">?</span><span class="mf">1</span><span class="err">??</span><span class="mf">1</span><span class="err">??</span><span class="mf">11</span>
<span class="mf">1000001101111101001011010011111101000011000111011001011111101</span><span class="w"> </span><span class="mf">1000001101111101001011010011111101000011000111011001011111101</span>
<span class="mf">1000001101111101001011010011111101000011000111011001011111101</span><span class="w"> </span><span class="mf">1000001101111101001011010011111101000011000111</span><span class="err">????</span><span class="mf">01</span><span class="err">?</span><span class="mf">11</span><span class="err">?????</span><span class="mf">1</span>
<span class="mf">1111100000010</span><span class="w"> </span><span class="mf">1111100000010</span>
<span class="mf">1111100000010</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">11111</span><span class="err">?</span><span class="mf">00000</span><span class="err">??</span>
<span class="mf">110110</span><span class="w"> </span><span class="mf">110110</span>
<span class="mf">110110</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">00</span><span class="err">?</span><span class="mf">00</span><span class="err">????</span><span class="mf">11</span><span class="err">??</span><span class="mf">10</span>
<span class="mf">110110</span><span class="w"> </span><span class="err">??</span><span class="mf">0</span><span class="err">??</span><span class="mf">0</span>
<span class="mf">...100010111011111</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">100</span><span class="err">?</span><span class="mf">10111</span><span class="err">??</span><span class="mf">111</span><span class="err">?</span>
<span class="mf">...1000100000110001</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">000</span><span class="err">?</span><span class="mf">00000</span><span class="err">??</span><span class="mf">000</span><span class="err">?</span>
<span class="mf">110000001110</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">0</span><span class="err">?</span><span class="mf">0</span><span class="err">??</span><span class="mf">000</span><span class="err">?</span><span class="mf">00</span><span class="err">?</span><span class="mf">0</span><span class="err">?</span><span class="mf">0000000</span><span class="err">?</span><span class="mf">00</span><span class="err">???</span><span class="mf">0000</span><span class="err">?????</span><span class="mf">00</span><span class="err">???</span><span class="mf">000</span><span class="err">?</span><span class="mf">0</span><span class="err">?</span><span class="mf">00</span><span class="err">?</span><span class="mf">01</span><span class="err">?</span><span class="mf">000</span><span class="err">?</span><span class="mf">0</span><span class="err">??</span><span class="mf">1</span><span class="err">??</span>
<span class="mf">110000001110</span><span class="w"> </span><span class="err">??</span><span class="mf">000000</span><span class="err">???</span><span class="mf">0</span>
<span class="mf">1011011010000001110101001111000010001001011101010010010001000000010101010010001101110101111111010101010010101100110000011110000</span><span class="w"> </span><span class="mf">1011011010000001110101001111000010001001011101010010010001000000010101010010001101110101111111010101010010101100110000011110000</span>
<span class="mf">...1011010010010100</span><span class="w"> </span><span class="mf">...1011010010010100</span>
<span class="mf">...1011111110110011</span><span class="w"> </span><span class="mf">...1011111110110011</span>
<span class="mf">101000011110110</span><span class="w"> </span><span class="mf">101000011</span><span class="err">?</span><span class="mf">10</span><span class="err">?</span><span class="mf">1</span><span class="err">?</span>
<span class="mf">100101</span><span class="w"> </span><span class="err">?</span><span class="mf">00</span><span class="err">?</span><span class="mf">0</span><span class="err">?</span>
</pre></div>

<p>That looks suitably random, but we might want to bias our random numbers a
little bit towards common error values like small constants, powers of two, etc.
Like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">INTEGER_WIDTH</span> <span class="o">=</span> <span class="mi">64</span>
<span class="c1"># some small integers</span>
<span class="n">ints_special</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
<span class="c1"># powers of two</span>
<span class="n">ints_special</span> <span class="o">=</span> <span class="n">ints_special</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">INTEGER_WIDTH</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1"># powers of two - 1</span>
<span class="n">ints_special</span> <span class="o">=</span> <span class="n">ints_special</span><span class="o">.</span><span class="n">union</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">INTEGER_WIDTH</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1"># negative versions of what we have so far</span>
<span class="n">ints_special</span> <span class="o">=</span> <span class="n">ints_special</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ints_special</span><span class="p">)</span>
<span class="c1"># bit-flipped versions of what we have so far</span>
<span class="n">ints_special</span> <span class="o">=</span> <span class="n">ints_special</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ints_special</span><span class="p">)</span>
<span class="n">ints_special</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ints_special</span><span class="p">)</span>
<span class="c1"># sort them (because hypothesis simplifies towards earlier elements in the list)</span>
<span class="n">ints_special</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">element</span><span class="p">:</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">element</span><span class="p">),</span> <span class="n">element</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>

<span class="n">ints</span> <span class="o">=</span> <span class="n">strategies</span><span class="o">.</span><span class="n">sampled_from</span><span class="p">(</span><span class="n">ints_special</span><span class="p">)</span> <span class="o">|</span> <span class="n">strategies</span><span class="o">.</span><span class="n">integers</span><span class="p">()</span>
</pre></div>

<p>Now we get data like this:</p>
<div class="code"><pre class="code literal-block"><span class="mf">1110</span><span class="w"> </span><span class="mf">1110</span>
<span class="mf">...10000000000000000001</span><span class="w"> </span><span class="mf">...10000</span><span class="err">??</span><span class="mf">0</span><span class="err">??</span><span class="mf">0000</span><span class="err">??</span><span class="mf">00</span><span class="err">?</span><span class="mf">1</span>
<span class="mf">1</span><span class="w"> </span><span class="err">??</span><span class="mf">0</span><span class="err">??</span><span class="mf">0000</span><span class="err">??</span><span class="mf">00</span><span class="err">?</span><span class="mf">1</span>
<span class="mf">1</span><span class="w"> </span><span class="err">?</span>
<span class="mf">...10101100</span><span class="w"> </span><span class="mf">...10101100</span>
<span class="mf">110000000011001010111011111111111111011110010001001100110001011</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">0</span><span class="err">?</span><span class="mf">101</span><span class="err">?</span>
<span class="mf">110000000011001010111011111111111111011110010001001100110001011</span><span class="w"> </span><span class="err">??</span><span class="mf">00000000</span><span class="err">??</span><span class="mf">00</span><span class="err">?</span><span class="mf">0</span><span class="err">?</span><span class="mf">0</span><span class="err">???</span><span class="mf">0</span><span class="err">??????????????</span><span class="mf">0</span><span class="err">????</span><span class="mf">00</span><span class="err">?</span><span class="mf">000</span><span class="err">?</span><span class="mf">00</span><span class="err">??</span><span class="mf">00</span><span class="err">??</span><span class="mf">000</span><span class="err">?</span><span class="mf">0</span><span class="err">??</span>
<span class="mf">...1011111111111111111111111111</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">11</span><span class="err">?</span><span class="mf">11</span><span class="err">??</span>
<span class="mf">...1011111111111111111111111111</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">0</span><span class="err">??????????????????????????</span>
<span class="mf">0</span><span class="w"> </span><span class="mf">...</span><span class="err">?</span><span class="mf">0</span><span class="err">??????????????????????????</span>
<span class="mf">101101</span><span class="w"> </span><span class="mf">101101</span>
<span class="mf">111111111111111111111111111111111111111111111</span><span class="w"> </span><span class="mf">111111111111111111111111111111111111111111111</span>
<span class="mf">10111</span><span class="w"> </span><span class="mf">10111</span>
<span class="mf">...101100</span><span class="w"> </span><span class="mf">...1</span><span class="err">?</span><span class="mf">111011</span><span class="err">?</span><span class="mf">0</span>
<span class="mf">101000</span><span class="w"> </span><span class="err">?</span><span class="mf">001010</span><span class="err">?</span><span class="mf">0</span>
<span class="mf">101000</span><span class="w"> </span><span class="err">?</span><span class="mf">0</span><span class="err">?</span><span class="mf">000</span>
<span class="mf">110010</span><span class="w"> </span><span class="mf">110010</span>
<span class="mf">...100111</span><span class="w"> </span><span class="mf">...100111</span>
<span class="mf">1111011010010</span><span class="w"> </span><span class="mf">1111011010010</span>
<span class="mf">...1000000000000000000000000000000000000</span><span class="w"> </span><span class="mf">...1000000000000000000000000000000000000</span>
</pre></div>

<p>We can also write a test that checks that the somewhat tricky logic in
<code>__str__</code> and <code>from_str</code> is correct, by making sure that the two functions
round-trip (ie converting a <code>KnownBits</code> to a string and then back to a
<code>KnownBits</code> instance produces the same abstract value).</p>
<div class="code"><pre class="code literal-block"><span class="nd">@given</span><span class="p">(</span><span class="n">knownbits_and_contained_number</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_hypothesis_str_roundtrips</span><span class="p">(</span><span class="n">t1</span><span class="p">):</span>
    <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">k1</span><span class="o">.</span><span class="n">ones</span> <span class="o">==</span> <span class="n">k2</span><span class="o">.</span><span class="n">ones</span>
    <span class="k">assert</span> <span class="n">k1</span><span class="o">.</span><span class="n">unknowns</span> <span class="o">==</span> <span class="n">k2</span><span class="o">.</span><span class="n">unknowns</span>
</pre></div>

<p>Now let's actually apply this infrastructure to test <code>abstract_invert</code>.</p>
<h3 id="when-are-transfer-functions-correct-how-do-we-test-them">When are Transfer Functions Correct? How do we test them?<a href="#when-are-transfer-functions-correct-how-do-we-test-them" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Abstract values, i.e. instances of <code>KnownBits</code> represent <em>sets</em> of concrete
values. We want the transfer functions to compute <em>overapproximations</em> of the
concrete values. So if we have an arbitrary abstract value <code>k</code>, with a concrete
number <code>n</code> that is a member of the abstract values (i.e.
<code>k.contains(n) == True</code>) then the result of the concrete operation <code>op(n)</code>
<strong>must</strong> be a member of the result of the abstract operation <code>k.abstract_op()</code>
(i.e. <code>k.abstract_op().contains(op(n)) == True</code>).</p>
<p>Checking the correctness/overapproximation property is a good match for
hypothesis. Here's what the test for <code>abstract_invert</code> looks like:</p>
<div class="code"><pre class="code literal-block"><span class="nd">@given</span><span class="p">(</span><span class="n">knownbits_and_contained_number</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_hypothesis_invert</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="o">~</span><span class="n">n1</span> <span class="c1"># compute the real result</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_invert</span><span class="p">()</span> <span class="c1"># compute the abstract result</span>
    <span class="k">assert</span> <span class="n">k2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="c1"># the abstract result must contain the real result</span>
</pre></div>

<p>This is the <em>only</em> condition needed for <code>abstract_invert</code> to be correct. If
<code>abstract_invert</code> fulfils this property for every combination of abstract and
concrete value then <code>abstract_invert</code> is correct. Note however, that this test
does not actually check whether <code>abstract_invert</code> gives us precise results. A
correct (but imprecise) implementation of <code>abstract_invert</code> would simply return
a completely unknown result, regardless of what is known about the input
<code>KnownBits</code>.</p>
<p>The "proper" CS term for this notion of correctness is called <em>soundness</em>. The
correctness condition on the transfer functions is called a <em>Galois
connection</em>. I won't go into any mathematical/technical details here, but
wanted to at least mention the terms. I found <a href="https://web.njit.edu/~mjk76/">Martin
Kellogg</a>'s
<a href="https://web.njit.edu/~mjk76/teaching/cs684-sp24/assets/lecture-12.pdf#34">slides</a>
to be quite an approachable introduction to the Galois connection and how to
show soundness.</p>
<h3 id="implementing-binary-transfer-functions">Implementing Binary Transfer Functions<a href="#implementing-binary-transfer-functions" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Now we have infrastructure in place for testing transfer functions with random
inputs. With that we can start thinking about the more complicated case, that of
binary operations. Let's start with the simpler ones, <code>and</code> and <code>or</code>. For <code>and</code>,
we can know a <code>0</code> bit in the result if either of the input bits are known <code>0</code>;
or we can know a <code>1</code> bit in the result if both input bits are known <code>1</code>.
Otherwise the resulting bit is unknown. Let's look at all the combinations:</p>
<div class="code"><pre class="code literal-block">and
input1: 000111???
input2: 01?01?01? 
result: 00001?0??
</pre></div>

<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_and</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">ones</span> <span class="c1"># known ones</span>
        <span class="n">knowns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">zeros</span> <span class="o">|</span> <span class="n">ones</span>
        <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="o">~</span><span class="n">knowns</span><span class="p">)</span>
</pre></div>

<p>Here's an example unit-test and a property-based test for <code>and</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_and</span><span class="p">():</span>
    <span class="c1"># test all combinations of 0, 1, ? in one example</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'01?01?01?'</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'000111???'</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_and</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>     <span class="c1"># should be: 0...00001?0??</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span>   <span class="s2">"1?0??"</span>

<span class="nd">@given</span><span class="p">(</span><span class="n">knownbits_and_contained_number</span><span class="p">,</span> <span class="n">knownbits_and_contained_number</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_hypothesis_and</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
    <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">t2</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_and</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">&amp;</span> <span class="n">n2</span>
    <span class="k">assert</span> <span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n3</span><span class="p">)</span>
</pre></div>

<p>To implement <code>or</code> is pretty similar. The result is known <code>1</code> where either of the
inputs is <code>1</code>. The result is known <code>0</code> where both inputs are known <code>0</code>, and <code>?</code>
otherwise.</p>
<div class="code"><pre class="code literal-block">or
input1: 000111???
input2: 01?01?01? 
result: 01?111?1?
</pre></div>

<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">ones</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">zeros</span>
        <span class="n">knowns</span> <span class="o">=</span> <span class="n">ones</span> <span class="o">|</span> <span class="n">zeros</span>
        <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="o">~</span><span class="n">knowns</span><span class="p">)</span>
</pre></div>

<p>Here's an example unit-test and a property-based test for <code>or</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_or</span><span class="p">():</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'01?01?01?'</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'000111???'</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_or</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>     <span class="c1"># should be:  0...01?111?1?</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span>   <span class="s2">"1?111?1?"</span>

<span class="nd">@given</span><span class="p">(</span><span class="n">knownbits_and_contained_number</span><span class="p">,</span> <span class="n">knownbits_and_contained_number</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_hypothesis_or</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
    <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">t2</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_or</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">|</span> <span class="n">n2</span>
    <span class="k">assert</span> <span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n3</span><span class="p">)</span>
</pre></div>

<p>Implementing support for <code>abstract_xor</code> is relatively simple, and left as an
exercise :-).</p>
<h3 id="addition-and-subtraction">Addition and Subtraction<a href="#addition-and-subtraction" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p><code>invert</code>, <code>and</code>, and <code>or</code> are relatively simple transfer functions to write,
because they compose over the individual bits of the integers. The arithmetic
functions <code>add</code> and <code>sub</code> are significantly harder, because of carries and
borrows. Coming up with the formulas for them and gaining an intuitive
understanding is quite tricky and involves carefully going through a few
examples with pen and paper. When implementing this in PyPy, Nico and I didn't
come up with the implementation ourselves, but instead took them from the
<a href="https://arxiv.org/abs/2105.05398">Tristate Numbers</a> paper. Here's the code,
with example tests and hypothesis tests:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">sum_ones</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">ones</span>
        <span class="n">sum_unknowns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">unknowns</span>
        <span class="n">all_carries</span> <span class="o">=</span> <span class="n">sum_ones</span> <span class="o">+</span> <span class="n">sum_unknowns</span>
        <span class="n">ones_carries</span> <span class="o">=</span> <span class="n">all_carries</span> <span class="o">^</span> <span class="n">sum_ones</span>
        <span class="n">unknowns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">unknowns</span> <span class="o">|</span> <span class="n">ones_carries</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="n">sum_ones</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">unknowns</span>
        <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">diff_ones</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">ones</span>
        <span class="n">val_borrows</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff_ones</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">diff_ones</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">unknowns</span><span class="p">)</span>
        <span class="n">unknowns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknowns</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">unknowns</span> <span class="o">|</span> <span class="n">val_borrows</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="n">diff_ones</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">unknowns</span>
        <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">test_add</span><span class="p">():</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'0?10?10?10'</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'0???111000'</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_add</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span>   <span class="s2">"?????01?10"</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_sub</span><span class="p">():</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'0?10?10?10'</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'0???111000'</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_sub</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span>   <span class="s2">"...?11?10"</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span>    <span class="s1">'...1?10?10?10'</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'...10000???111000'</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_sub</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span>   <span class="s2">"111?????11?10"</span>

<span class="nd">@given</span><span class="p">(</span><span class="n">knownbits_and_contained_number</span><span class="p">,</span> <span class="n">knownbits_and_contained_number</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_hypothesis_add</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
    <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">t2</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_add</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span>
    <span class="k">assert</span> <span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n3</span><span class="p">)</span>

<span class="nd">@given</span><span class="p">(</span><span class="n">knownbits_and_contained_number</span><span class="p">,</span> <span class="n">knownbits_and_contained_number</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_hypothesis_sub</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
    <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">t2</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_sub</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">-</span> <span class="n">n2</span>
    <span class="k">assert</span> <span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n3</span><span class="p">)</span>
</pre></div>

<p>Now we are in a pretty good situation, and have implemented abstract versions
for a bunch of important arithmetic and binary functions. What's also surprising
is that the implementation of all of the transfer functions is quite efficient.
We didn't have to write loops over the individual bits at all, instead we found
closed form expressions using primitive operations on the underlying integers
<code>ones</code> and <code>unknowns</code>. This means that computing the results of abstract
operations is quite efficient, which is important when using the abstract domain
in the context of a JIT compiler.</p>
<h3 id="proving-correctness-of-the-transfer-functions-with-z3">Proving correctness of the transfer functions with Z3<a href="#proving-correctness-of-the-transfer-functions-with-z3" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>As one can probably tell from my recent posts, I've been thinking about
compiler correctness a lot. Getting the transfer functions absolutely
correct is really crucial, because a bug in them would lead to miscompilation of
Python code when the abstract domain is added to the JIT. While the randomized
tests are great, it's still entirely possible for them to miss bugs. The state
space for the arguments of a binary transfer function is <code>3**64 * 3**64</code>, and if
only a small part of that contains wrong behaviour it would be really unlikely
for us to find it with random tests by chance. Therefore I was reluctant to
merge the PyPy branch that contained the new abstract domain for a long time.</p>
<p>To increase our confidence in the correctness of the transfer functions further,
we can use Z3 to <em>prove</em> their correctness, which gives us much stronger
guarantees (not 100%, obviously). In this subsection I will show how to do that.</p>
<p>Here's an attempt to do this manually in the Python repl:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;&gt;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">z3</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># like last blog post, proof by failing to find counterexamples</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="k">def</span><span class="w"> </span><span class="nf">prove</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span> <span class="k">assert</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">cond</span><span class="p">))</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">unsat</span>
<span class="o">&gt;&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># let's set up a z3 bitvector variable for an arbitrary concrete value</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVec</span><span class="p">(</span><span class="s1">'concrete_value'</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">n1</span>
<span class="n">concrete_value</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># due to operator overloading we can manipulate z3 formulas</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">n2</span> <span class="o">=</span> <span class="o">~</span><span class="n">n1</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">n2</span>
<span class="o">~</span><span class="n">concrete_value</span>
<span class="o">&gt;&gt;&gt;&gt;</span> 
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># now z3 bitvector variables for the ones and zeros fields</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">ones</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVec</span><span class="p">(</span><span class="s1">'abstract_ones'</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">unknowns</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVec</span><span class="p">(</span><span class="s1">'abstract_unknowns'</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># we construct a KnownBits instance with the z3 variables</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># due to operator overloading we can call the methods on k1:</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_invert</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">k2</span><span class="o">.</span><span class="n">ones</span>
<span class="o">~</span><span class="n">abstract_unknowns</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">abstract_ones</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">k2</span><span class="o">.</span><span class="n">unknowns</span>
<span class="n">abstract_unknowns</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># here's the correctness condition that we want to prove:</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">k2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="o">~</span><span class="n">concrete_value</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">abstract_unknowns</span> <span class="o">==</span>
<span class="o">~</span><span class="n">abstract_unknowns</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">abstract_ones</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># let's try</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">prove</span><span class="p">(</span><span class="n">k2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n2</span><span class="p">))</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="n">prove</span>
<span class="ne">AssertionError</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># it doesn't work! let's look at the counterexample to see why:</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
<span class="p">[</span><span class="n">abstract_unknowns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
 <span class="n">abstract_ones</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
 <span class="n">concrete_value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># we can build a KnownBits instance with the values in the</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># counterexample:</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="o">~</span><span class="mi">1</span> <span class="c1"># concrete result</span>
<span class="o">-</span><span class="mi">2</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">counter_example_k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">counter_example_k1</span>
<span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">counter_example_k2</span> <span class="o">=</span> <span class="n">counter_example_k1</span><span class="o">.</span><span class="n">abstract_invert</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">counter_example_k2</span>
<span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="c1"># let's check the failing condition</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">counter_example_k2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="o">~</span><span class="mi">1</span><span class="p">)</span>
<span class="kc">False</span>
</pre></div>

<p>What is the problem here? We didn't tell Z3 that <code>n1</code> was supposed to be a
member of <code>k1</code>. We can add this as a precondition to the solver, and then the
prove works:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt;&gt; solver.add(k1.contains(n1))
&gt;&gt;&gt;&gt; prove(k2.contains(n2)) # works!
</pre></div>

<p>This is super cool! It's really a proof about the actual implementation, because
we call the implementation methods directly, and due to the operator overloading
that Z3 does we can be sure that we are actually checking a formula that
corresponds to the Python code. This eliminates one source of errors in formal
methods.</p>
<p>Doing the proof manually on the Python REPL is kind of annoying though, and we
also would like to make sure that the proofs are re-done when we change the
code. What we would really like to do is writing the proofs as a unit-test that
we can run while developing and in CI. Doing this is possible, and the unit
tests that really perform proofs look pleasingly similar to the
Hypothesis-based ones.</p>
<p>First we need to set up a bit of infrastructure:</p>
<div class="code"><pre class="code literal-block"><span class="n">INTEGER_WIDTH</span> <span class="o">=</span> <span class="mi">64</span>

<span class="k">def</span><span class="w"> </span><span class="nf">BitVec</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">BitVecVal</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">z3</span><span class="o">.</span><span class="n">BitVecVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">INTEGER_WIDTH</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">z3_setup_variables</span><span class="p">():</span>
    <span class="c1"># instantiate a solver</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>

    <span class="c1"># a Z3 variable for the first concrete value</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">BitVec</span><span class="p">(</span><span class="s2">"n1"</span><span class="p">)</span>
    <span class="c1"># a KnownBits instances that uses Z3 variables as its ones and unknowns,</span>
    <span class="c1"># representing the first abstract value</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">BitVec</span><span class="p">(</span><span class="s2">"n1_ones"</span><span class="p">),</span> <span class="n">BitVec</span><span class="p">(</span><span class="s2">"n1_unkowns"</span><span class="p">))</span>
    <span class="c1"># add the precondition to the solver that the concrete value n1 must be a</span>
    <span class="c1"># member of the abstract value k1</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n1</span><span class="p">))</span>

    <span class="c1"># a Z3 variable for the second concrete value</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">BitVec</span><span class="p">(</span><span class="s2">"n2"</span><span class="p">)</span>
    <span class="c1"># a KnownBits instances for the second abstract value</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">BitVec</span><span class="p">(</span><span class="s2">"n2_ones"</span><span class="p">),</span> <span class="n">BitVec</span><span class="p">(</span><span class="s2">"n2_unkowns"</span><span class="p">))</span>
    <span class="c1"># add the precondition linking n2 and k2 to the solver</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">solver</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span>

<span class="k">def</span><span class="w"> </span><span class="nf">prove</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="n">z3res</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">cond</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">z3res</span> <span class="o">!=</span> <span class="n">z3</span><span class="o">.</span><span class="n">unsat</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">z3res</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">sat</span> <span class="c1"># can't be timeout, we set no timeout</span>
        <span class="c1"># make the model with the counterexample global, to make inspecting the</span>
        <span class="c1"># bug easier when running pytest --pdb</span>
        <span class="k">global</span> <span class="n">model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"n1=</span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span><span class="si">}</span><span class="s2">, n2=</span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">counter_example_k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">ones</span><span class="p">)</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">(),</span>
                                       <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">unknowns</span><span class="p">)</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">())</span>
        <span class="n">counter_example_k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">k2</span><span class="o">.</span><span class="n">ones</span><span class="p">)</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">(),</span>
                                       <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">k2</span><span class="o">.</span><span class="n">unknowns</span><span class="p">)</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"k1=</span><span class="si">{</span><span class="n">counter_example_k1</span><span class="si">}</span><span class="s2">, k2=</span><span class="si">{</span><span class="n">counter_example_k2</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"but </span><span class="si">{</span><span class="n">cond</span><span class="si">=}</span><span class="s2"> evaluates to </span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
</pre></div>

<p>And then we can write proof-unit-tests like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_z3_abstract_invert</span><span class="p">():</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">z3_setup_variables</span><span class="p">()</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_invert</span><span class="p">()</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="o">~</span><span class="n">n1</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">k2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n2</span><span class="p">),</span> <span class="n">solver</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_z3_abstract_and</span><span class="p">():</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">z3_setup_variables</span><span class="p">()</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_and</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">&amp;</span> <span class="n">n2</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n3</span><span class="p">),</span> <span class="n">solver</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_z3_abstract_or</span><span class="p">():</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">z3_setup_variables</span><span class="p">()</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_or</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">|</span> <span class="n">n2</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n3</span><span class="p">),</span> <span class="n">solver</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_z3_abstract_add</span><span class="p">():</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">z3_setup_variables</span><span class="p">()</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_add</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n3</span><span class="p">),</span> <span class="n">solver</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_z3_abstract_sub</span><span class="p">():</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">z3_setup_variables</span><span class="p">()</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_sub</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">-</span> <span class="n">n2</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n3</span><span class="p">),</span> <span class="n">solver</span><span class="p">)</span>
</pre></div>

<p>It's possible to write a bit more Python-metaprogramming-magic and unify the
Hypothesis and Z3 tests into the same test definition.<sup id="fnref:proof_bitwidths"><a class="footnote-ref" href="toy-knownbits.html#fn:proof_bitwidths">1</a></sup></p>
<h3 id="cases-where-this-style-of-z3-proof-doesnt-work">Cases where this style of Z3 proof doesn't work<a href="#cases-where-this-style-of-z3-proof-doesnt-work" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Unfortunately the approach described in the previous section only works for a
very small number of cases. It breaks down as soon as the <code>KnownBits</code> methods
that we're calling contain any <code>if</code> conditions (including hidden ones like
the short-circuiting <code>and</code> and <code>or</code> in Python). Let's look at an example and
implement <code>abstract_eq</code>. <code>eq</code> is supposed to be an operation that compares two
integers and returns <code>0</code> or <code>1</code> if they are different or equal, respectively.
Implementing this in knownbits looks like this (with example and hypothesis
tests):</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># the result is a 0, 1, or ?</span>

        <span class="c1"># if they are both the same constant, they must be equal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">ones</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># check whether we have known disagreeing bits, then we know the result</span>
        <span class="c1"># is 0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_disagrees</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># an unknown boolean</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_disagrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># check whether the bits disagree in any place where both are known</span>
        <span class="n">both_known</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knowns</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">knowns</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span> <span class="o">&amp;</span> <span class="n">both_known</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">ones</span> <span class="o">&amp;</span> <span class="n">both_known</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_eq</span><span class="p">():</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'...?'</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s1">'...?'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">abstract_eq</span><span class="p">(</span><span class="n">k2</span><span class="p">))</span> <span class="o">==</span> <span class="s1">'?'</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">abstract_eq</span><span class="p">(</span><span class="n">k1</span><span class="p">))</span> <span class="o">==</span> <span class="s1">'1'</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">abstract_eq</span><span class="p">(</span><span class="n">k2</span><span class="p">))</span> <span class="o">==</span> <span class="s1">'0'</span>

<span class="nd">@given</span><span class="p">(</span><span class="n">knownbits_and_contained_number</span><span class="p">,</span> <span class="n">knownbits_and_contained_number</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_hypothesis_eq</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
    <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">t2</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_eq</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="p">))</span>
</pre></div>

<p>Trying to do the proof in the same style as before breaks:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_eq</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">"knownbits.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">246</span><span class="p">,</span> <span class="ow">in</span> <span class="n">abstract_eq</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_disagrees</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"venv/site-packages/z3/z3.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">381</span><span class="p">,</span> <span class="ow">in</span> <span class="fm">__bool__</span>
    <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">"Symbolic expressions cannot be cast to concrete Boolean values."</span><span class="p">)</span>
<span class="n">z3</span><span class="o">.</span><span class="n">z3types</span><span class="o">.</span><span class="n">Z3Exception</span><span class="p">:</span> <span class="n">Symbolic</span> <span class="n">expressions</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">cast</span> <span class="n">to</span> <span class="n">concrete</span> <span class="n">Boolean</span> <span class="n">values</span><span class="o">.</span>
</pre></div>

<p>We cannot call <code>abstract_eq</code> on a <code>KnownBits</code> with Z3 variables as fields,
because once we hit an <code>if</code> statement, the whole approach of relying on the
operator overloading breaks down. Z3 doesn't actually parse the Python code or
anything advanced like that, we rather build an expression only by running the
code and letting the Z3 formulas build up.</p>
<p>To still prove the correctness of <code>abstract_eq</code> we need to manually transform
the control flow logic of the function into a Z3 formula that uses the <code>z3.If</code>
expression, using a small helper function:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">z3_cond</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">trueval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">falseval</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">z3</span><span class="o">.</span><span class="n">If</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">BitVecVal</span><span class="p">(</span><span class="n">trueval</span><span class="p">),</span> <span class="n">BitVecVal</span><span class="p">(</span><span class="n">falseval</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">z3_abstract_eq</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">):</span>
    <span class="c1"># follow the *logic* of abstract_eq, we can't call it due to the ifs in it</span>
    <span class="n">case1cond</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(),</span> <span class="n">k2</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(),</span> <span class="n">k1</span><span class="o">.</span><span class="n">ones</span> <span class="o">==</span> <span class="n">k2</span><span class="o">.</span><span class="n">ones</span><span class="p">)</span>
    <span class="n">case2cond</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">_disagrees</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>

    <span class="c1"># ones is 1 in the first case, 0 otherwise</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">z3_cond</span><span class="p">(</span><span class="n">case1cond</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># in the first two cases, unknowns is 0, 1 otherwise</span>
    <span class="n">unknowns</span> <span class="o">=</span> <span class="n">z3_cond</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Or</span><span class="p">(</span><span class="n">case1cond</span><span class="p">,</span> <span class="n">case2cond</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_z3_abstract_eq_logic</span><span class="p">():</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">z3_setup_variables</span><span class="p">()</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="n">z3_cond</span><span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="p">)</span> <span class="c1"># concrete result</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">z3_abstract_eq</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">n3</span><span class="p">),</span> <span class="n">solver</span><span class="p">)</span>
</pre></div>

<p>This proof works. It is a lot less satisfying than the previous ones though,
because we could have done an error in the manual transcription from Python code
to Z3 formulas (there are possibly more heavy-handed approaches where we do
this transformation more automatically using e.g. the <code>ast</code> module to analyze
the source code, but that's a much more complicated researchy project). To
lessen this problem somewhat we can factor out the parts of the logic that don't
have any conditions into small helper methods (like <code>_disagrees</code> in this
example) and use them in the manual conversion of the code to Z3 formulas.<sup id="fnref:tests_vs_proofs"><a class="footnote-ref" href="toy-knownbits.html#fn:tests_vs_proofs">2</a></sup></p>
<p>The final condition that Z3 checks, btw, is this one:</p>
<div class="code"><pre class="code literal-block">If(n1 == n2, 1, 0) &amp;
~If(Or(And(n1_unkowns == 0,
           n2_unkowns == 0,
           n1_ones == n2_ones),
       n1_ones &amp; ~n1_unkowns &amp; ~n2_unkowns !=
       n2_ones &amp; ~n1_unkowns &amp; ~n2_unkowns),
    0, 1) ==
If(And(n1_unkowns == 0, n2_unkowns == 0, n1_ones == n2_ones),
   1, 0)
</pre></div>

<h3 id="making-statements-about-precision">Making Statements about Precision<a href="#making-statements-about-precision" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>So far we have only used Z3 to prove statements about correctness, i.e. that
our abstract operations overapproximate what can happen with concrete values.
While proving this property is essential if we want to avoid miscompilation,
correctness alone is not a very strong constraint on the implementation of our
abstract transfer functions. We could simply return <code>Knownbits.unknowns()</code> for
every <code>abstract_*</code> method and the resulting overapproximation would be correct,
but useless in practice.</p>
<p>It's much harder to make statements about whether the transfer functions are
maximally precise. There are two aspects of precision I want to discuss in this
section, however.</p>
<p>The first aspect is that we would really like it if the transfer functions
compute the maximally precise results for singleton sets. If all abstract
arguments of an operations are constants, i.e. contain only a single concrete
element, then we know that the resulting set also has only a single element. We
can prove that all our transfer functions have this property:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_z3_prove_constant_folding</span><span class="p">():</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">z3_setup_variables</span><span class="p">()</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_invert</span><span class="p">()</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(),</span>
                     <span class="n">k3</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()),</span> <span class="n">solver</span><span class="p">)</span>

    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_and</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(),</span> <span class="n">k2</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()),</span>
                     <span class="n">k3</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()),</span> <span class="n">solver</span><span class="p">)</span>

    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_or</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(),</span> <span class="n">k2</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()),</span>
                     <span class="n">k3</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()),</span> <span class="n">solver</span><span class="p">)</span>

    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_sub</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(),</span> <span class="n">k2</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()),</span>
                     <span class="n">k3</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()),</span> <span class="n">solver</span><span class="p">)</span>

    <span class="n">k3</span> <span class="o">=</span> <span class="n">z3_abstract_eq</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(),</span> <span class="n">k2</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()),</span>
                     <span class="n">k3</span><span class="o">.</span><span class="n">is_constant</span><span class="p">()),</span> <span class="n">solver</span><span class="p">)</span>
</pre></div>

<p>Proving with Z3 that the transfer functions are maximally precise for
non-constant arguments seems to be relatively hard. I tried a few completely
rigorous approaches and failed. The paper <a href="https://arxiv.org/pdf/2105.05398">Sound, Precise, and Fast Abstract
Interpretation with Tristate Numbers</a>
contains an optimality proof for the transfer functions of addition and
subtraction, so we can be certain that they are as precise as is
possible.</p>
<p>I still want to show an approach for trying to find concrete examples of
abstract values that are less precise than they could be, using a combination
of Hypothesis and Z3. The idea is to use hypothesis to pick random abstract
values. Then we compute the abstract result using our transfer function.
Afterwards we can ask Z3 to find us an abstract result that is better than the
one our transfer function produced. If Z3 finds a better abstract result, we
have a concrete example of imprecision for our transfer function. Those tests
aren't strict proofs, because they rely on generating random abstract values,
but they can still be valuable (not for the transfer functions in this blog
post, which are all optimal).</p>
<p>Here is what the code looks like (this is a little bit bonus content, I'll not
explain the details and can only hope that the comments are somewhat helpful):</p>
<div class="code"><pre class="code literal-block"><span class="nd">@given</span><span class="p">(</span><span class="n">random_knownbits_and_contained_number</span><span class="p">,</span> <span class="n">random_knownbits_and_contained_number</span><span class="p">)</span>
<span class="nd">@settings</span><span class="p">(</span><span class="n">deadline</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_check_precision</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
    <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">t2</span>
    <span class="c1"># apply transfer function</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">abstract_add</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="n">example_res</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span>

    <span class="c1"># try to find a better version of k3 with Z3</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">"timeout"</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>

    <span class="n">var1</span> <span class="o">=</span> <span class="n">BitVec</span><span class="p">(</span><span class="s1">'v1'</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">BitVec</span><span class="p">(</span><span class="s1">'v2'</span><span class="p">)</span>

    <span class="n">ones</span> <span class="o">=</span> <span class="n">BitVec</span><span class="p">(</span><span class="s1">'ones'</span><span class="p">)</span>
    <span class="n">unknowns</span> <span class="o">=</span> <span class="n">BitVec</span><span class="p">(</span><span class="s1">'unknowns'</span><span class="p">)</span>
    <span class="n">better_k3</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">k3</span><span class="p">)</span>

    <span class="c1"># we're trying to find an example for a better k3, so we use check, without</span>
    <span class="c1"># negation:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span>
        <span class="c1"># better_k3 should be a valid knownbits instance</span>
        <span class="n">better_k3</span><span class="o">.</span><span class="n">is_well_formed</span><span class="p">(),</span>
        <span class="c1"># it should be better than k3, ie there are known bits in better_k3</span>
        <span class="c1"># that we don't have in k3</span>
        <span class="n">better_k3</span><span class="o">.</span><span class="n">knowns</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">k3</span><span class="o">.</span><span class="n">knowns</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="c1"># now encode the correctness condition for better_k3 with a ForAll:</span>
        <span class="c1"># for all concrete values var1 and var2, it must hold that if</span>
        <span class="c1"># var1 is in k1 and var2 is in k2 it follows that var1 + var2 is in</span>
        <span class="c1"># better_k3</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="p">(</span>
        <span class="p">[</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">],</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span>
            <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">var1</span><span class="p">),</span> <span class="n">k2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">var2</span><span class="p">)),</span>
            <span class="n">better_k3</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">var1</span> <span class="o">+</span> <span class="n">var2</span><span class="p">)))))</span>
    <span class="c1"># if this query is satisfiable, we have found a better result for the</span>
    <span class="c1"># abstract_add</span>
    <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">sat</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
        <span class="n">rk3</span> <span class="o">=</span> <span class="n">KnownBits</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">ones</span><span class="p">)</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">(),</span> <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">unknowns</span><span class="p">)</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"better"</span><span class="p">,</span> <span class="n">rk3</span><span class="p">)</span>
        <span class="k">assert</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">unknown</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"timeout"</span><span class="p">)</span>
</pre></div>

<p>It does not actually fail for <code>abstract_add</code> (nor the other abstract
functions). To see the test failing we can add some imprecision to the
implementation of <code>abstract_add</code> to see Hypothesis and Z3 find examples of
values that are not optimally precise (for example by setting some bits
of <code>unknowns</code> in the implementation of <code>abstract_add</code> unconditionally).</p>
<h3 id="using-the-abstract-domain-in-the-toy-optimizer-for-generalized-constant-folding">Using the Abstract Domain in the Toy Optimizer for Generalized Constant Folding<a href="#using-the-abstract-domain-in-the-toy-optimizer-for-generalized-constant-folding" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Now after all this work we can finally actually use the knownbits abstract
domain in the toy optimizer. The code for this follows <a href="https://bernsteinbear.com/blog/toy-abstract-interpretation/">Max' intro post about
abstract interpretation</a>
quite closely.</p>
<p>For completeness sake, in the fold there's the basic infrastructure classes
that make up the IR again (they are identical or at least extremely close to
the previous toy posts).</p>
<details><summary>toy infrastructure</summary><div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Value</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"abstract"</span><span class="p">)</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Operation</span><span class="p">(</span><span class="n">Value</span><span class="p">):</span>
    <span class="n">name</span> <span class="p">:</span> <span class="nb">str</span>
    <span class="n">args</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Value</span><span class="p">]</span>

    <span class="n">forwarded</span> <span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Value</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
            <span class="nb">next</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">forwarded</span>
            <span class="k">if</span> <span class="nb">next</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">op</span>
            <span class="n">op</span> <span class="o">=</span> <span class="nb">next</span>
        <span class="k">return</span> <span class="n">op</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">make_equal_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="p">:</span> <span class="n">Value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">()</span><span class="o">.</span><span class="n">forwarded</span> <span class="o">=</span> <span class="n">value</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Constant</span><span class="p">(</span><span class="n">Value</span><span class="p">):</span>
    <span class="n">value</span> <span class="p">:</span> <span class="nb">object</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Block</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opname</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">wraparg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Value</span><span class="p">):</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">arg</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">make_op</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span>
                <span class="p">[</span><span class="n">wraparg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">op</span>
        <span class="k">return</span> <span class="n">make_op</span>


<span class="k">def</span><span class="w"> </span><span class="nf">bb_to_str</span><span class="p">(</span><span class="n">l</span> <span class="p">:</span> <span class="n">Block</span><span class="p">,</span> <span class="n">varprefix</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"var"</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">arg_to_str</span><span class="p">(</span><span class="n">arg</span> <span class="p">:</span> <span class="n">Value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">varnames</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>

    <span class="n">varnames</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        <span class="c1"># give the operation a name used while</span>
        <span class="c1"># printing:</span>
        <span class="n">var</span> <span class="o">=</span>  <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">varprefix</span><span class="si">}{</span><span class="n">index</span><span class="si">}</span><span class="s2">"</span>
        <span class="n">varnames</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">arg_to_str</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">strop</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">arguments</span><span class="si">}</span><span class="s2">)"</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strop</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</pre></div>



</details><p>Now we can write some first tests, the first one simply checking constant
folding:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_constfold_two_ops</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_add</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">var3</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_add</span><span class="p">(</span><span class="n">var2</span><span class="p">,</span> <span class="n">var0</span><span class="p">)</span>

    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">,</span> <span class="s2">"optvar"</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">optvar0 = getarg(0)</span>
<span class="s2">optvar1 = int_add(19, optvar0)"""</span>
</pre></div>

<p>Calling the transfer functions on constant <code>KnownBits</code> produces a constant
results, as we have seen. Therefore "regular" constant folding should hopefully
be achieved by optimizing with the <code>KnownBits</code> abstract domain too.</p>
<p>The next two tests are slightly more complicated and can't be optimized by
regular constant-folding. They follow the motivating examples from the start of
this blog post, a hundred years ago:</p>
<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">test_constfold_via_knownbits</span><span class="p">():</span>
<span class="w">    </span><span class="n">bb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Block</span><span class="p">()</span>
<span class="w">    </span><span class="n">var0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">var1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">int_or</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">var2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">int_and</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">var3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">dummy</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>

<span class="w">    </span><span class="n">opt_bb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">simplify</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
<span class="w">    </span><span class="nb">assert</span><span class="w"> </span><span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">,</span><span class="w"> </span><span class="s2">"optvar"</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"""</span><span class="se">\</span>
<span class="s2">optvar0 = getarg(0)</span>
<span class="s2">optvar1 = int_or(optvar0, 1)</span>
<span class="s2">optvar2 = dummy(1)"""</span>

<span class="n">def</span><span class="w"> </span><span class="n">test_constfold_alignment_check</span><span class="p">():</span>
<span class="w">    </span><span class="n">bb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Block</span><span class="p">()</span>
<span class="w">    </span><span class="n">var0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">var1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">int_invert</span><span class="p">(</span><span class="mi">0</span><span class="n">b111</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># mask off the lowest three bits, thus var2 is aligned</span>
<span class="w">    </span><span class="n">var2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">int_and</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span><span class="w"> </span><span class="n">var1</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># add 16 to aligned quantity</span>
<span class="w">    </span><span class="n">var3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">int_add</span><span class="p">(</span><span class="n">var2</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># check alignment of result</span>
<span class="w">    </span><span class="n">var4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">int_and</span><span class="p">(</span><span class="n">var3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="n">b111</span><span class="p">)</span>
<span class="w">    </span><span class="n">var5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">int_eq</span><span class="p">(</span><span class="n">var4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># var5 should be const-folded to 1</span>
<span class="w">    </span><span class="n">var6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb</span><span class="o">.</span><span class="n">dummy</span><span class="p">(</span><span class="n">var5</span><span class="p">)</span>

<span class="w">    </span><span class="n">opt_bb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">simplify</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
<span class="w">    </span><span class="nb">assert</span><span class="w"> </span><span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">,</span><span class="w"> </span><span class="s2">"optvar"</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"""</span><span class="se">\</span>
<span class="s2">optvar0 = getarg(0)</span>
<span class="s2">optvar1 = int_and(optvar0, -8)</span>
<span class="s2">optvar2 = int_add(optvar1, 16)</span>
<span class="s2">optvar3 = dummy(1)"""</span>
</pre></div>

<p>Here is <code>simplify</code> to make these tests pass:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">unknown_transfer_functions</span><span class="p">(</span><span class="o">*</span><span class="n">abstract_args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">all_unknown</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Block</span><span class="p">:</span>
    <span class="n">abstract_values</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># dict mapping Operation to KnownBits</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">knownbits_of</span><span class="p">(</span><span class="n">val</span> <span class="p">:</span> <span class="n">Value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">KnownBits</span><span class="o">.</span><span class="n">from_constant</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">abstract_values</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>

    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="c1"># apply the transfer function on the abstract arguments</span>
        <span class="n">name_without_prefix</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">removeprefix</span><span class="p">(</span><span class="s2">"int_"</span><span class="p">)</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"abstract_</span><span class="si">{</span><span class="n">name_without_prefix</span><span class="si">}</span><span class="s2">"</span>
        <span class="n">transfer_function</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">KnownBits</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">unknown_transfer_functions</span><span class="p">)</span>
        <span class="n">abstract_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">knownbits_of</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">find</span><span class="p">())</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">abstract_res</span> <span class="o">=</span> <span class="n">abstract_values</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="p">(</span><span class="o">*</span><span class="n">abstract_args</span><span class="p">)</span>
        <span class="c1"># if the result is a constant, we optimize the operation away and make</span>
        <span class="c1"># it equal to the constant result</span>
        <span class="k">if</span> <span class="n">abstract_res</span><span class="o">.</span><span class="n">is_constant</span><span class="p">():</span>
            <span class="n">op</span><span class="o">.</span><span class="n">make_equal_to</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">abstract_res</span><span class="o">.</span><span class="n">ones</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="c1"># otherwise emit the op</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>The code follows the approach from the previous blog post very closely. The
only difference is that we apply the transfer function <em>first</em>, to be able to
detect whether the abstract domain can tell us that the result has to always be
a constant. This code makes all three tests pass.</p>
<h3 id="using-the-knownbits-domain-for-conditional-peephole-rewrites">Using the <code>KnownBits</code> Domain for Conditional Peephole Rewrites<a href="#using-the-knownbits-domain-for-conditional-peephole-rewrites" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>So far we are only using the <code>KnownBits</code> domain to find out that certain
operations have to produce a constant. We can also use the <code>KnownBits</code> domain
to check whether certain operation rewrites are correct. Let's use one of the
examples from the <a href="../07/mining-jit-traces-missing-optimizations-z3.html">Mining JIT traces for missing optimizations with
Z3</a>
post, where Z3 found the inefficiency <code>(x &lt;&lt; 4) &amp; -0xf == x &lt;&lt; 4</code> in PyPy JIT
traces. We don't have shift operations, but we want to generalize this optimization
anyway. The general form of this rewrite is that under some circumstances <code>x &amp;
y == x</code>, and we can use the <code>KnownBits</code> domain to detect situations where this
must be true.</p>
<p>To understand <em>when</em> <code>x &amp; y == x</code> is true, we can think about individual pairs of
bits <code>a</code> and <code>b</code>. If <code>a == 0</code>, then <code>a &amp; b == 0 &amp; b == 0 == a</code>. If <code>b == 1</code>
then <code>a &amp; b == a &amp; 1 == a</code>. So if either <code>a == 0</code> or <code>b == 1</code> is true,
<code>a &amp; b == a</code> follows. And if either of these conditions is true for <em>all</em> the
bits of <code>x</code> and <code>y</code>, we can know that <code>x &amp; y == x</code>.</p>
<p>We can write a method on <code>KnownBits</code> to check for this condition:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">KnownBits</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_and_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">""" Return True if n1 &amp; n2 == n1 for any n1 in self and n2 in other.</span>
<span class="sd">        (or, equivalently, return True if n1 | n2 == n2)"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">ones</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>

<p>Since my reasoning about this feels ripe for errors, let's check that our
understanding is correct with Z3:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_prove_is_and_identity</span><span class="p">():</span>
    <span class="n">solver</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">z3_setup_variables</span><span class="p">()</span>
    <span class="n">prove</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">is_and_identity</span><span class="p">(</span><span class="n">k2</span><span class="p">),</span> <span class="n">n1</span> <span class="o">&amp;</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">n1</span><span class="p">),</span> <span class="n">solver</span><span class="p">)</span>
</pre></div>

<p>Now let's use this in the toy optimizer. Here are two tests for this rewrite:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_remove_redundant_and</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_invert</span><span class="p">(</span><span class="mb">0b1111</span><span class="p">)</span>
    <span class="c1"># mask off the lowest four bits</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_and</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="n">var1</span><span class="p">)</span>
    <span class="c1"># applying the same mask is not redundant</span>
    <span class="n">var3</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_and</span><span class="p">(</span><span class="n">var2</span><span class="p">,</span> <span class="n">var1</span><span class="p">)</span>
    <span class="n">var4</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">dummy</span><span class="p">(</span><span class="n">var3</span><span class="p">)</span>

    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">,</span> <span class="s2">"optvar"</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">optvar0 = getarg(0)</span>
<span class="s2">optvar1 = int_and(optvar0, -16)</span>
<span class="s2">optvar2 = dummy(optvar1)"""</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_remove_redundant_and_more_complex</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># var2 has bit pattern ????</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_and</span><span class="p">(</span><span class="n">var0</span><span class="p">,</span> <span class="mb">0b1111</span><span class="p">)</span>
    <span class="c1"># var3 has bit pattern ...?1111</span>
    <span class="n">var3</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_or</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="mb">0b1111</span><span class="p">)</span>
    <span class="c1"># var4 is just var2</span>
    <span class="n">var4</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_and</span><span class="p">(</span><span class="n">var2</span><span class="p">,</span> <span class="n">var3</span><span class="p">)</span>
    <span class="n">var5</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">dummy</span><span class="p">(</span><span class="n">var4</span><span class="p">)</span>

    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">,</span> <span class="s2">"optvar"</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">optvar0 = getarg(0)</span>
<span class="s2">optvar1 = getarg(1)</span>
<span class="s2">optvar2 = int_and(optvar0, 15)</span>
<span class="s2">optvar3 = int_or(optvar1, 15)</span>
<span class="s2">optvar4 = dummy(optvar2)"""</span>
</pre></div>

<p>The first test could also be made to pass by implementing a reassociation
optimization that turns <code>(x &amp; c1) &amp; c2</code> into <code>x &amp; (c1 &amp; c2)</code> and then constant-folds the second <code>and</code>. But here we want to
use <code>KnownBits</code> and conditionally rewrite <code>int_and</code> to its first argument. So to make the tests pass,
we can change <code>simplify</code> like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">Block</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Block</span><span class="p">:</span>
    <span class="n">abstract_values</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># dict mapping Operation to KnownBits</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">knownbits_of</span><span class="p">(</span><span class="n">val</span> <span class="p">:</span> <span class="n">Value</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
        <span class="c1"># apply the transfer function on the abstract arguments</span>
        <span class="n">name_without_prefix</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">removeprefix</span><span class="p">(</span><span class="s2">"int_"</span><span class="p">)</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"abstract_</span><span class="si">{</span><span class="n">name_without_prefix</span><span class="si">}</span><span class="s2">"</span>
        <span class="n">transfer_function</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">KnownBits</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">unknown_transfer_functions</span><span class="p">)</span>
        <span class="n">abstract_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">knownbits_of</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">find</span><span class="p">())</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">abstract_res</span> <span class="o">=</span> <span class="n">abstract_values</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="p">(</span><span class="o">*</span><span class="n">abstract_args</span><span class="p">)</span>
        <span class="c1"># if the result is a constant, we optimize the operation away and make</span>
        <span class="c1"># it equal to the constant result</span>
        <span class="k">if</span> <span class="n">abstract_res</span><span class="o">.</span><span class="n">is_constant</span><span class="p">():</span>
            <span class="n">op</span><span class="o">.</span><span class="n">make_equal_to</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">abstract_res</span><span class="o">.</span><span class="n">ones</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="c1"># &lt;&lt;&lt;&lt; new code</span>
        <span class="c1"># conditionally rewrite int_and(x, y) to x</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"int_and"</span><span class="p">:</span>
            <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">abstract_args</span>
            <span class="k">if</span> <span class="n">k1</span><span class="o">.</span><span class="n">is_and_identity</span><span class="p">(</span><span class="n">k2</span><span class="p">):</span>
                <span class="n">op</span><span class="o">.</span><span class="n">make_equal_to</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                <span class="k">continue</span>
        <span class="c1"># &gt;&gt;&gt;&gt; end changes</span>
        <span class="n">opt_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_bb</span>
</pre></div>

<p>And with that, the new tests pass as well. A real implementation would also
check the other argument order, but we leave that out for the sake of brevity.</p>
<p>This rewrite also generalizes the <a href="https://pypy.org/posts/2024/07/finding-simple-rewrite-rules-jit-z3.html">rewrites</a> <code>int_and(0, x) -&gt; 0</code> and
<code>int_and(-1, x) -&gt; x</code>, let's add a test for those:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">test_remove_and_simple</span><span class="p">():</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">getarg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_and</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">var0</span><span class="p">)</span> <span class="c1"># == 0</span>
    <span class="n">var3</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_invert</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span> <span class="c1"># == -1</span>
    <span class="n">var4</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">int_and</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var3</span><span class="p">)</span> <span class="c1"># == var1</span>
    <span class="n">var5</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">dummy</span><span class="p">(</span><span class="n">var4</span><span class="p">)</span>

    <span class="n">opt_bb</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bb_to_str</span><span class="p">(</span><span class="n">opt_bb</span><span class="p">,</span> <span class="s2">"optvar"</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">optvar0 = getarg(0)</span>
<span class="s2">optvar1 = getarg(1)</span>
<span class="s2">optvar2 = dummy(optvar1)"""</span>
</pre></div>

<p>This test just passes. And that's it for this post!</p>
<h3 id="conclusion">Conclusion<a href="#conclusion" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>In this post we've seen the implementation, testing and proofs about a 'known
bits' abstract domain, as well as its use in the toy optimizer to generalize
constant folding, and to implement conditional peephole rewrites.</p>
<p>In the next posts I'll write about the real implementation of a knownbits
domain in PyPy's JIT, its combination with the existing interval abstract
domain, how to deal with gaining information from conditions in the program,
and some lose ends.</p>
<p>Sources:</p>
<ul>
<li><a href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/Support/KnownBits.cpp">Known bits in LLVM</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/kernel/bpf/tnum.c">Tristate numbers for known bits in Linux eBPF</a></li>
<li><a href="https://arxiv.org/abs/2105.05398">Sound, Precise, and Fast Abstract Interpretation with Tristate Numbers</a></li>
<li><a href="https://people.cs.rutgers.edu/~sn349/papers/agni-cav2023.pdf">Verifying the Veriﬁer: eBPF Range Analysis Veriﬁcation</a></li>
<li>
<a href="https://dougallj.wordpress.com/2020/01/13/bit-twiddling-addition-with-unknown-bits/">Bit-Twiddling: Addition with Unknown
  Bits</a>
  is a super readable blog post by Dougall J. I've taken the <code>ones</code> and
  <code>unknowns</code> naming from this post, which I find significantly clearer than
  <code>value</code> and <code>mask</code>, which the Linux kernel uses.</li>
<li>
<a href="https://bitmath.blogspot.com/">Bits, Math and Performance(?)</a>, a fantastic
  blog by <a href="https://mastodon.gamedev.place/@harold">Harold Aptroot</a>. There are a
  lot of relevant posts about known bits, range analysis etc. Harold is also
  the author of <a href="http://haroldbot.nl/">Haroldbot</a>, a website that can be used
  for bitvector calculations, and also checks bitvector identities.</li>
<li><a href="https://cea.hal.science/cea-01795779/document">Sharpening Constraint Programming approaches for Bit-Vector Theory</a></li>
<li><a href="https://users.cs.utah.edu/~regehr/papers/lctes06_2/fp019-regehr.pdf">Deriving Abstract Transfer Functions for Analyzing Embedded Software</a></li>
<li><a href="https://arxiv.org/abs/2105.00493">Synthesizing Abstract Transformers</a></li>
</ul>
<div class="footnote">
<hr>
<ol>
<li id="fn:proof_bitwidths">
<p>There's a subtletly about the Z3 proofs that I'm sort of
glossing over here. Python integers are of arbitrary width, and the
<code>KnownBits</code> code is actually carefully written to work for integers of any
size. This property is tested by the Hypothesis tests, which don't limit
the sizes of the generated random integers. However, the Z3 proofs only
check bitvectors of a fixed bitwidth of 64. There are various ways to deal
with this situation. For most "real" compilers, the bitwidth of integers
would be fixed anyway. Then the components <code>ones</code> and <code>unknowns</code> of the
<code>KnownBits</code> class would use the number of bits the corresponding integer
variable has, and the Z3 proofs would use the same width. This is what we
do in the PyPy JIT. <a class="footnote-backref" href="toy-knownbits.html#fnref:proof_bitwidths" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:tests_vs_proofs">
<p>The less close connection between implementation and proof
for <code>abstract_eq</code> is one of the reasons why it makes sense to do
unit-testing <em>in addition</em> to proofs. For a more detailed explanation of
why both tests and proofs are good to
have, see <a href="https://siek.blogspot.com/2024/06/data-structures-and-algorithms-correctly.html#correct-software-via-write-test-and-prove:~:text=We%20recognize%20that%20once%20step,detect%20most%20of%20the%20bugs">Jeremy Siek's blog
post</a>,
as well as the <a href="https://www-cs-faculty.stanford.edu/~knuth/faq.html#:~:text=What's%20the%20exact%20citation%20of%20your%20oft%2Dcited%20comment%20about%20bugs?">Knuth
quote</a>. <a class="footnote-backref" href="toy-knownbits.html#fnref:tests_vs_proofs" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
</ol>
</div>
      </div>
      <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/toy-optimizer.html" rel="tag">toy-optimizer</a></li>
            <li><a class="tag p-category" href="../../../categories/z3.html" rel="tag">z3</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../07/toy-abstract-interpretation.html" rel="prev" title="Abstract interpretation in the Toy Optimizer">Previous post</a>
            </li>
            <li class="next">
                <a href="conda-forge-proposes-dropping-support-for-pypy.html" rel="next" title="Conda-forge proposes sunsetting support for PyPy">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
                      <div data-title="A Knownbits Abstract Domain for the Toy Optimizer, Correctly" id="utterances-thread"></div>
        <script src="https://utteranc.es/client.js" repo="pypy/pypy.org" issue-term="title" label="Comments" theme="github-light" crossorigin="anonymous"></script></section><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    <div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/12/toy-load-store.html" class="listtitle">Load and store forwarding in the Toy Optimizer</a>
      </li>
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (9)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (6)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div>    </div>
</article></main><footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    © 2026 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
     
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
     
    Last built 2026-01-17T00:22
  </div>
  <div style="margin-left: auto">
  <a href="../../../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../../../assets/js/styles.js"></script></footer>
</div>
</body>
</html>