<html><body><p>"extern C" is "just" modifying the symbol mangling mechanism of the identifiers inside the extern-C block.<br><br>just try this example from the link I posted earlier:<br>https://stackoverflow.com/questions/1201593/c-subset-of-c-where-not-examples<br><br>"""<br>struct A { struct B { int a; } b; int c; };<br>struct B b; // ill-formed: b has incomplete type (*not* A::B)<br>"""<br><br>even if you create a foo.h like so:<br><br>"""<br>#ifdef __cplusplus<br>extern "C" {<br>#endif<br><br>struct A { struct B { int a; } b; int c; };<br>  struct B b;<br>#ifdef __cplusplus<br>}<br>#endif<br>"""<br><br>and compile some main.c/cxx (which just includes that header) with gcc/g++, you'll get:<br><br>"""<br>$ gcc main.c<br>$ echo $?<br>0<br><br>$ g++ main.cxx<br>In file included from main.cxx:2:0:<br>foo.h:7:12: error: aggregate ‘B b’ has incomplete type and cannot be defined<br>zsh: exit 1     g++ main.cxx<br>"""<br><br>gccxml is using the C++ parser, thus my first remark :}</p></body></html>