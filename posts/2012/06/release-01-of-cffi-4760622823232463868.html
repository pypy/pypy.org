<html><body><div dir="ltr" style="text-align: left;"><p>Hi.</p><p>We're pleased to announce the first public release, 0.1 of CFFI, a way to call C from Python.<br>
(This release does not support PyPy yet --- but we announce it here as it is planned for the<br>
next release :-)</p><p>The package is available <a class="reference external" href="https://foss.heptapod.net/cffi/cffi">on bitbucket</a> as well as <a class="reference external" href="https://cffi.readthedocs.org">documented</a>. You can also install it<br>
straight from the python package index (pip).</p><p>The aim of this project is to provide a convenient and reliable way of calling C code from Python.<br>
The interface is based on <a class="reference external" href="https://luajit.org/ext_ffi.html">LuaJIT's FFI</a> and follows a few principles:</p><ul class="simple"><li>The goal is to call C code from Python.  You should be able to do so<br>
without learning a 3rd language: every alternative requires you to learn<br>
their own language (<a class="reference external" href="https://www.cython.org">Cython</a>, <a class="reference external" href="https://www.swig.org/">SWIG</a>) or API (<a class="reference external" href="https://docs.python.org/library/ctypes.html">ctypes</a>).  So we tried to<br>
assume that you know Python and C and minimize the extra bits of API that<br>
you need to learn.</li>
<li>Keep all the Python-related logic in Python so that you don't need to<br>
write much C code (unlike <a class="reference external" href="https://docs.python.org/extending/extending.html">CPython native C extensions</a>).</li>
<li>Work either at the level of the ABI (Application Binary Interface)<br>
or the API (Application Programming Interface).  Usually, C<br>
libraries have a specified C API but often not an ABI (e.g. they may<br>
document a "struct" as having at least these fields, but maybe more).<br>
(<a class="reference external" href="https://docs.python.org/library/ctypes.html">ctypes</a> works at the ABI level, whereas Cython or <a class="reference external" href="https://docs.python.org/extending/extending.html">native C extensions</a><br>
work at the API level.)</li>
<li>We try to be complete.  For now some C99 constructs are not supported,<br>
but all C89 should be, including macros (and including macro "abuses",<br>
which you can manually wrap in saner-looking C functions).</li>
<li>We attempt to support both PyPy and CPython (although PyPy support is not<br>
complete yet) with a reasonable path for other Python implementations like<br>
IronPython and Jython.</li>
<li>Note that this project is <strong>not</strong> about embedding executable C code in<br>
Python, unlike <a class="reference external" href="https://www.scipy.org/Weave">Weave</a>.  This is about calling existing C libraries<br>
from Python.</li>
</ul><div class="section" id="status-of-the-project"><h3>Status of the project</h3><p>Consider this as a beta release. Creating CPython extensions is fully supported and the API should<br>
be relatively stable; however, minor adjustements of the API are possible.</p><p>PyPy support is not yet done and this is a goal for the next release. There are vague plans to make this the<br>
preferred way to call C from Python that can reliably work between PyPy and CPython.</p><p>Right now CFFI's verify() requires a C compiler and header files to be available at run-time.<br>
This limitation will be lifted in the near future and it'll contain a way to cache the resulting binary.</p><p>Cheers,<br>
<br>
Armin Rigo and Maciej Fija≈Çkowski</p></div></div></body></html>