<html><body><p>Trying to give some notes about the <a class="reference" href="https://www.swa.hpi.uni-potsdam.de/s3/index.html">S3 Workshop</a> in Potsdam that several
PyPyers and Spies (Armin, Carl Friedrich, Niko, Toon, Adrian) attended before
the Berlin sprint.  We presented a <a class="reference" href="https://codespeak.net/svn/pypy/extradoc/paper/spy-s3.pdf">paper</a> about SPy there. Below are some mostly
random note about my (Carl Friedrich's) impressions of the conference and some
talk notes. Before that I'd like to give thanks to the organizers who did a
great job. The workshop was well organized, the social events were wonderful (a
very relaxing boat trip in the many lakes around Potsdam and a conference
dinner).</p>
<p>Video recordings of all the talks can be found on the <a class="reference" href="https://www.swa.hpi.uni-potsdam.de/s3/program/index.html">program page</a>.</p>
<div class="section">
<h2><a id="invited-talks" name="invited-talks">Invited Talks</a></h2>
<p>"Late-bound Object Lambda Architectures" by Ian Piumarta was quite an inspiring
talk about <a class="reference" href="#vpri">VPRI</a>'s attempt at writing a flexible and understandable computing
system in 20K lines of code. The talk was lacking a bit in technical details, so
while it was inspiring I couldn't really say much about their implementation.
Apart from that, I disagree with some of their goals, but that's the topic of
another blog post.</p>
<p id="vpri">"The Lively Kernel – A Self-supporting System on a Web Page" by Dan Ingalls. Dan
Ingalls is one of the inventors of the original Smalltalk and of Squeak. He was
talking about his latest work, the attempts of bringing a Squeak-like system to
a web browser using JavaScript and SVG. To get some feel for what exactly <a class="reference" href="https://research.sun.com/projects/lively/">The
Lively Kernel</a> is, it is easiest to just <a class="reference" href="https://livelykernel.sunlabs.com/0.8.5/index.xhtml">try it out</a> (only works in Safari
and Firefox 3 above Beta 5 though). I guess in a sense the progress of the
Lively Kernel over Squeak is not that great but Dan seems to be having fun.  Dan
is an incredibly enthusiastic, friendly and positive person, it was really great
meeting him. He even seemed to like some of the ideas in SPy.</p>
<p>"On Sustaining Self" by Richard P. Gabriel was a sort of deconstructivist
multi-media-show train wreck of a presentation that was a bit too weird for my
taste. There was a lot of music, there were sections in the presentation
where Richard discussed with an alter ego, whose part he had recorded in advance
and mangled with a sound editor. There was a large bit of a documentary
about <a class="reference" href="https://en.wikipedia.org/wiki/Levittown,_New_York">Levittown</a>. Even the introduction and the questions were weird, with Pascal
Constanza staring down the audience, without saying a word (nobody dared to ask
questions). I am not sure I saw the point of the presentation, apart from
getting the audience to think, which probably worked. It seems that there are
people (e.g. <a class="reference" href="https://chneukirchen.org/blog/archive/2008/05/workshop-on-self-sustaining-systems-2008.html">Christian Neukirchen</a>) that liked the presentation, though.</p>
</div>
<div class="section">
<h2><a id="research-papers" name="research-papers">Research Papers</a></h2>
<p>"SBCL - A Sanely Bootstrappable Common Lisp by Christophe Rhodes described the
bootstrapping process of <a class="reference" href="https://sbcl.org">SBCL</a> (Steel Bank Common Lisp). SBCL can be bootstrapped
by a variety of Common Lisps, not just by itself. SBCL contains a complete
blueprint of the initial image instead of always getting the new image by
carefully mutating the old one. This bootstrapping approach is sort of similar
to that of PyPy.</p>
<p>"Reflection for the Masses" by Charlotte Herzeel, Pascal Costanza, and Theo
D'Hondt retraced some of the work of Brian Smith on reflection in Lisp. The
talk was not very good, it was way too long (40 min), quite hard to understand
because Charlotte Herzeel was talking in a very low voice. The biggest mistake
in her talk was in my opinion that she spent too much time explaining a more or
less standard meta-circular interpreter for Lisp and then running out of time
when she was trying to explain the modifications. I guess it would have been a
fair assumptions that large parts of the audience know such interpreters, so
glossing over the details would have been fine. A bit of a pity, since the paper
seems interesting.</p>
<p>"Back to the Future in One Week - Implementing a Smalltalk VM in PyPy"
by Carl Friedrich Bolz, Adrian Kuhn, Adrian Lienhard, Nicholas D. Matsakis,
Oscar Nierstrasz, Lukas Renggli, Armin Rigo and Toon Verwaest, the paper with
the longest author list. We just made everybody an author who was at the sprint
in Bern. Our <a class="reference" href="https://codespeak.net/svn/pypy/extradoc/paper/spy-s3.pdf">paper</a> had more authors than all the other papers together :-). I
gave the <a class="reference" href="https://codespeak.net/svn/pypy/extradoc/talk/s3-2008/talk.pdf">presentation</a> at the workshop, which went quite well, judging from the
feedback I got.</p>
<p>"Huemul - A Smalltalk Implementation" by Guillermo Adrián Molina. <a class="reference" href="https://www.guillermomolina.com.ar/huemul/">Huemul</a> is a
Smalltalk implementation that doesn't contain an interpreter but directly
compiles all methods to assembler (and also saves the assembler in the image).
In addition, as much functionality (such as threading, GUI) as possible is
delegated to libraries instead of reimplementing them in Smalltalk
(as e.g. Squeak is doing). The approach seems to suffer from the usual problems
of manually writing a JIT, e.g. the VM seems to segfault pretty often. Also I
don't agree with some of the design decisions of the threading scheme, there is
no automatic locking of objects at all, instead the user code is responsible for
preventing concurrent accesses from messing up things (which even seems to lead
to segfaults in the default image).</p>
<p>"Are Bytecodes an Atavism?" by Theo D'Hondt argued that using AST-based
interpreters can be as fast as bytecode-based interpreters which he proved by
writing two AST-interpreters, one for <a class="reference" href="https://pico.vub.ac.be/">Pico</a> and one for Scheme. Both of these
implementations seem to perform pretty well. Theo seems to have many similar
views as PyPy, for example that writing simple straightforward interpreters is
often preferable than writing complex (JIT-)compilers.</p>
</div></body></html>