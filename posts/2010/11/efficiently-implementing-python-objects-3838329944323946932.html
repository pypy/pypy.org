<!DOCTYPE html>
<html \ prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Efficiently Implementing Python Objects With Maps | PyPy</title>
<link href="../../../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../../rss.xml">
<link rel="canonical" href="https://www.pypy.org/posts/2010/11/efficiently-implementing-python-objects-3838329944323946932.html">
<link rel="icon" href="../../../favicon2.ico" sizes="16x16">
<link rel="icon" href="../../../favicon32x32.ico" sizes="32x32">
<!--[if lt IE 9]><script src="../../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../../assets/css/tipuesearch.css">
<meta name="author" content="Carl Friedrich Bolz-Tereick">
<link rel="prev" href="speeding-up-pypy-by-donations-6035529829962326007.html" title="Speeding up PyPy by donations" type="text/html">
<link rel="next" href="running-large-radio-telescope-software-7600337209616168504.html" title="Running large radio telescope software on top of PyPy and twisted" type="text/html">
<meta property="og:site_name" content="PyPy">
<meta property="og:title" content="Efficiently Implementing Python Objects With Maps">
<meta property="og:url" content="https://www.pypy.org/posts/2010/11/efficiently-implementing-python-objects-3838329944323946932.html">
<meta property="og:description" content="As could be foreseen by my Call for Memory Benchmarks post a while ago, I am
currently working on improving the memory behaviour of PyPy's Python
interpreter. In this blog post I want to describe the ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2010-11-13T16:40:00Z">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../../../index.html">
                    <image id="toplogo" src="../../../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../../../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../../../compat.html">Compatibility</a> </li>  
                    <li> <a href="../../../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../../../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href="../../../blog/">Index</a> </li>  
                    <li> <a href="../../../categories/">Tags</a> </li>  
                    <li> <a href="../../../archive.html">Archive by year</a> </li>  
                    <li> <a href="../../../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://bsky.app/profile/pypyproject.bsky.social">Bluesky</a> </li>  
                    <li> <a href="https://libera.irclog.whitequark.org/pypy">IRC logs</a> </li>  
                    <li> <a href="https://www.youtube.com/playlist?list=PLADqad94yVqDRQXuqxKrPS5QnVqbDLlRt">YouTube</a> </li>  
                    <li> <a href="https://www.twitch.tv/pypyproject">Twitch</a> </li>  
                    <li> <a href="../../../pypy-sponsors.html">Sponsors</a> </li>  
                    <li> <a href="../../../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../../../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section><div class="searchform" role="search">
                
<form class="navbar-form navbar-left" action="../../../search.html" role="search">
    <div class="form-group">
        <input type="text" class="form-control" id="tipue_search_input" name="q" placeholder="Search…" autocomplete="off">
</div>
    <input type="submit" value="Local Search" style="visibility: hidden;">
</form>

            </div>
    </header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><div class="post">
          <header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Efficiently Implementing Python Objects With Maps</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../../authors/carl-friedrich-bolz-tereick.html">Carl Friedrich Bolz-Tereick</a>
            </span></p>
            <p class="dateline">
            <a href="#" rel="bookmark">
            <time class="published dt-published" datetime="2010-11-13T16:40:00Z" itemprop="datePublished" title="2010-11-13 16:40">2010-11-13 16:40</time></a>
            </p>
                <p class="commentline">15 comments</p>

                <p class="commentline">            <a href="efficiently-implementing-python-objects-3838329944323946932.html#utterances-thread">Comments</a>


            
        </p>
</div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
      <p>As could be foreseen by my <a class="reference external" href="../08/call-for-benchmarks-2605012131351543912.html">Call for Memory Benchmarks</a> post a while ago, I am
currently working on improving the memory behaviour of PyPy's Python
interpreter. In this blog post I want to describe the various data a Python
instance can store. Then I want to describe how a branch that I did and that was
recently merged implements the various features of instances in a very
memory-efficient way.</p>
<div class="section" id="python-s-object-model">
<h2>Python's Object Model<a href="#python-s-object-model" class="headerlink" title="Permalink to this heading">¶</a></h2>
<p>All "normal" new-style Python instances (i.e. instances of subclasses of <tt class="docutils literal">object</tt>
without added declarations) store two (or possibly three) kinds of information.</p>
<div class="section" id="storing-the-class">
<h3>Storing the Class<a href="#storing-the-class" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Every instance knows which class it belongs to. This information is accessible
via the <tt class="docutils literal">.__class__</tt> attribute. It can also be changed to other (compatible
enough) classes by writing to that attribute.</p>
</div>
<div class="section" id="instance-variables">
<h3>Instance Variables<a href="#instance-variables" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Every instance also has an arbitrary number of attributes stored (also called
instance variables). The instance variables used can vary per instance, which is
not the case in most other class-based languages: traditionally (e.g. in
Smalltalk or Java) the class describes the shape of its instances,
which means that the
set of admissible instance variable names is the same for all instances of a
class.</p>
<p>In Python on the other hand, it is possible to add arbitrary attributes to an
instance at any point. The instance behaves like a dictionary mapping attribute
names (as strings) to the attribute values.</p>
<p>This is actually how CPython implements instances. Every instance has a
reference to a dictionary that stores all the attributes of the instance. This
dictionary can be reached via the <tt class="docutils literal">.__dict__</tt> attribute. To make things more
fun, the dictionary can also be <em>changed</em> by writing to that attribute.</p>
</div>
<div class="section" id="example">
<h3>Example<a href="#example" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>As an example, consider the following code:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">A</span>(<span style="color: #336666;">object</span>):
    <span style="color: #006699; font-weight: bold;">pass</span>

instance1 <span style="color: #555555;">=</span> A()
instance1<span style="color: #555555;">.</span>x <span style="color: #555555;">=</span> <span style="color: #FF6600;">4</span>
instance1<span style="color: #555555;">.</span>y <span style="color: #555555;">=</span> <span style="color: #FF6600;">6</span>
instance1<span style="color: #555555;">.</span>z <span style="color: #555555;">=</span> <span style="color: #555555;">-</span><span style="color: #FF6600;">1</span>

instance2 <span style="color: #555555;">=</span> A()
instance2<span style="color: #555555;">.</span>x <span style="color: #555555;">=</span> <span style="color: #FF6600;">1</span>
instance2<span style="color: #555555;">.</span>y <span style="color: #555555;">=</span> <span style="color: #FF6600;">2</span>
instance2<span style="color: #555555;">.</span>z <span style="color: #555555;">=</span> <span style="color: #FF6600;">3</span>
</pre></div>
<p>These two instances would look something like this in memory:</p>
<a href="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6__OBefcI/AAAAAAAAAMg/vmOMwGa5mKw/s1600/instance-grey.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075684529241538" src="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6__OBefcI/AAAAAAAAAMg/vmOMwGa5mKw/s400/instance-grey.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 57px;"></a>
<p>(The picture glosses over a number of details, but it still shows the essential
issues.)</p>
<p>This way of storing things is simple, but unfortunately rather inefficient. Most
instances of the same class have the same shape, i.e. the same set of instance
attribute names. That means that the key part of all the dictionaries is
identical (shown grey here). Therefore storing that part repeatedly in all
instances is a waste. In addition, dictionaries are themselves rather large.
Since they are typically implemented as hashmaps, which must not be too full to
be efficient, a dictionary will use something like 6 words on average per key.</p>
</div>
<div class="section" id="slots">
<h3>Slots<a href="#slots" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Since normal instances are rather large, CPython 2.2 introduced slots, to make
instances consume less memory. Slots are a way to fix the set of attributes an
instance can have. This is achieved by adding a declaration to a class, like
this:</p>
<div class="highlight" style="background: #f0f3f3;"><pre style="line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00AA88; font-weight: bold;">B</span>(<span style="color: #336666;">object</span>):
    __slots__ <span style="color: #555555;">=</span> [<span style="color: #CC3300;">"x"</span>, <span style="color: #CC3300;">"y"</span>, <span style="color: #CC3300;">"z"</span>]
</pre></div>
<p>Now the instances of <tt class="docutils literal">B</tt> can only have <tt class="docutils literal">x</tt>, <tt class="docutils literal">y</tt> and <tt class="docutils literal">z</tt> as attributes
and don't have a dictionary at all. Instead, the instances of <tt class="docutils literal">B</tt> get
allocated with enough size to hold exactly the number of instance variables that
the class permits. This clearly saves a lot of memory over the dictionary
approach, but has a number of disadvantages. It is obviously less flexible, as
you cannot add additional instance variables to an instance if you happen to
need to do that. It also introduces a set of <a class="reference external" href="https://docs.python.org/reference/datamodel.html#slots">rules and corner-cases</a> that can
be surprising sometimes (e.g. instances of a subclass of a class with slots that
doesn't have a slots declaration will have a dict).</p>
</div>
</div>
<div class="section" id="using-maps-for-memory-efficient-instances">
<h2>Using Maps for Memory-Efficient Instances<a href="#using-maps-for-memory-efficient-instances" class="headerlink" title="Permalink to this heading">¶</a></h2>
<p>As we have seen in the diagram above, the dictionaries of instances of the same
class tend to look very similar and share all the keys. The central idea to use
less memory is to "factor out" the common parts of the instance dictionaries
into a new object, called a "map" (because it is a guide to the landscape of the
object, or something). After that factoring out, the representation of the
instances above looks something like this:</p>
<a href="https://2.bp.blogspot.com/_zICyAWqZbLA/TN6__c74O3I/AAAAAAAAAMo/CxNPGbfD8bc/s1600/instancemap.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075688532294514" src="https://2.bp.blogspot.com/_zICyAWqZbLA/TN6__c74O3I/AAAAAAAAAMo/CxNPGbfD8bc/s400/instancemap.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 59px;"></a>
<p>Every instance now has a reference to its map, which describes what the instance
looks like. The actual instance variables are stored in an array (called
<tt class="docutils literal">storage</tt> in the diagram). In the example here, the map describes that the
instances have three attributes <tt class="docutils literal">x</tt>, <tt class="docutils literal">y</tt> and <tt class="docutils literal">z</tt>. The numbers after the
attributes are indexes into the storage array.</p>
<p>If somebody adds a new attribute to one of the instances, the map for that
instance will be changed to another map that also contains the new attribute,
and the storage will have to grow a field with the new attribute. The maps are
immutable, immortal and reused as much as possible. This means, that two
instances of the same class with the same set of attributes will have the same
map. This also means that the memory the map itself uses is not too important,
because it will potentially be amortized over many instances.</p>
<p>Note that using maps makes instances nearly as small as if the correct slots had
been declared in the class. The only overhead needed is the indirection to the
storage array, because you can get new instance variables, but not new slots.</p>
<p>The concept of a "map" that describes instances is kind of old and comes from
the virtual machine for the <a class="reference external" href="https://en.wikipedia.org/wiki/Self_%28programming_language%29">Self</a> programming language. The optimization was
first described in 1989 in a paper by Chambers, Ungar and Lee with the title <a class="reference external" href="https://labs.oracle.com/self/papers/implementation.html">An
Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language
Based on Prototypes</a>. A similar technique is used in Google's V8 JavaScript
engine, where the maps are called <a class="reference external" href="https://code.google.com/apis/v8/design.html#prop_access">hidden classes</a> and in the <a class="reference external" href="https://blogs.sun.com/jrose/entry/javaone_in_2010">Rhino
JavaScript engine</a>.</p>
<p>The rest of the post describes a number of further details that occur if
instances are implemented using maps.</p>
<div class="section" id="supporting-dictionaries-with-maps">
<h3>Supporting Dictionaries with Maps<a href="#supporting-dictionaries-with-maps" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>The default instance representation with maps as shown above works without
actually having a dictionary as part of each instance. If a dictionary is
actually requested, by accessing the <tt class="docutils literal">.__dict__</tt> attribute, it needs to be
created and cached. The dictionary is not a normal Python dictionary, but a thin
wrapper around the object that forwards all operations to it. From the user's
point of view it behaves like a normal dictionary though (it even has the
correct type).</p>
<p>The dictionary needs to be cached, because accessing <tt class="docutils literal">.__dict__</tt> several times
should always return the same dictionary. The caching happens by using a
different map that knows about the dictionary and putting the dictionary into
the storage array:</p>
<a href="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6__ibswtI/AAAAAAAAAMw/ZBY7pvZAel8/s1600/dictinstancemap.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075690007937746" src="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6__ibswtI/AAAAAAAAAMw/ZBY7pvZAel8/s400/dictinstancemap.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 102px;"></a>
<p>Things become really complex if the fake dict is used in strange ways. As long
as the keys are strings, everything is fine. If somebody adds other keys to the
dict, they cannot be represented by the map any more (which supports only
attributes, i.e. string keys in the <tt class="docutils literal">__dict__</tt>). If that happens, all the
information of the instance will move into the fake dictionary, like this:</p>
<a href="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6___mTkZI/AAAAAAAAAM4/2F-B8drBvKk/s1600/dictinstancemapdevolved.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075697837052306" src="https://3.bp.blogspot.com/_zICyAWqZbLA/TN6___mTkZI/AAAAAAAAAM4/2F-B8drBvKk/s400/dictinstancemapdevolved.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 249px;"></a>
<p>In this picture, the key <tt class="docutils literal"><span class="pre">-1</span></tt> was added to the instance's dictionary. Since
using the dictionary in arbitrary ways should be rare, we are fine with the
additional time and memory that the approach takes.</p>
</div>
<div class="section" id="slots-and-maps">
<h3>Slots and Maps<a href="#slots-and-maps" class="headerlink" title="Permalink to this heading">¶</a></h3>
<p>Maps work perfectly together with slots, because the slots can just be stored
into the storage array used by the maps as well (in practise there are some
refinements to that scheme).  This means that putting a <tt class="docutils literal">__slots__</tt> on a
class has mostly no effect, because the instance only stores the values of the
attributes (and not the names), which is equivalent to the way slots are stored
in CPython.</p>
</div>
</div>
<div class="section" id="implementation-details">
<h2>Implementation Details<a href="#implementation-details" class="headerlink" title="Permalink to this heading">¶</a></h2>
<p>In the diagrams above, I represented the maps as flat objects. In practise this
is a bit more complex, because it needs to be efficient to go from one map to
the next when new attributes are added. Thus the maps are organized in a tree.</p>
<p>The instances with their maps from above look a bit more like this in practise:</p>
<a href="https://4.bp.blogspot.com/_zICyAWqZbLA/TN7AABHntqI/AAAAAAAAANA/YHVsUp51d60/s1600/realmap.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5539075698245220002" src="https://4.bp.blogspot.com/_zICyAWqZbLA/TN7AABHntqI/AAAAAAAAANA/YHVsUp51d60/s400/realmap.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 271px;"></a>
<p>Every map just describes one attribute of the object, with a name and a an
index. Every map also has a <tt class="docutils literal">back</tt> field, that points to another map
describing what the rest of the object looks like. This chain ends with a
terminator, which also stores the class of the object.</p>
<p>The maps also contain the information necessary for making a new object of
class <tt class="docutils literal">A</tt>. Immediately after the new object has been created, its map is the
terminator. If the <tt class="docutils literal">x</tt> attribute is added, its maps is changed to the
second-lowest map, and so on. The blue arrows show the sequence of maps that
the new object goes through when the attributes <tt class="docutils literal">x, y, z</tt> are added.</p>
<p>This representation of maps as chains of objects sounds very inefficient if an
object has many attributes. The whole chain has to be walked to find the index.
This is true to some extent. The problem goes away in the presence of the JIT,
which knows that the chain of maps is an immutable structure, and will thus
optimize away all the chain-walking. If the JIT is not used, there are a few
caches that try to speed up the walking of this chain (similar to the method
cache in CPython and PyPy).</p>
</div>
<div class="section" id="results">
<h2>Results<a href="#results" class="headerlink" title="Permalink to this heading">¶</a></h2>
<p>It's hard to compare the improvements of this optimization in a fair way, as
the trade-offs are just very different. Just to give an impression, a million
objects of the same class with three fields on a 32bit system takes:</p>
<p>without slots:</p>
<ul class="simple">
<li>182 MiB memory in CPython</li>
<li>177 MiB memory in PyPy without maps</li>
<li>40 MiB memory in PyPy with maps</li>
</ul>
<p>with slots:</p>
<ul class="simple">
<li>45 MiB memory in CPython</li>
<li>50 MiB memory in PyPy without maps</li>
<li>40 MiB memory in PyPy with maps</li>
</ul>
<p>Note how maps make the objects a bit more efficient like CPython using slots.
Also, using slots has no additional effect in PyPy.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a href="#conclusion" class="headerlink" title="Permalink to this heading">¶</a></h2>
<p>Maps are a powerful approach to shrinking the memory used by many similar
instances. I think they can be pushed even further (e.g. by adding information
about the types of the attributes) and plan to do so in the following months.
Details will be forthcoming.</p>
</div>
      </div>
      <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="speeding-up-pypy-by-donations-6035529829962326007.html" rel="prev" title="Speeding up PyPy by donations">Previous post</a>
            </li>
            <li class="next">
                <a href="running-large-radio-telescope-software-7600337209616168504.html" rel="next" title="Running large radio telescope software on top of PyPy and twisted">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
                <div class="comment-level comment-level-1">
      <div class="comment comment-5783692099276223419">
        <div class="comment-header">
          <a name="comment-5783692099276223419"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2010-11-13 17:28</span>:
        </div>
        <div class="comment-content">
          <p>Not sure if you are glossing over this, but it seems trivial to avoid the map chain walking by duplicating all of the information in a maps back pointer chain into the map itself.  However, the lookup keys are still strings, so your options are some kind of frozen hashtable (which could be nice) or a sorted array.<br><br>Both of those still seem much more efficient than chasing pointers.</p>
        </div>
      </div>
      <div class="comment comment-3507693547785476828">
        <div class="comment-header">
          <a name="comment-3507693547785476828"></a>
            <span class="author">Erez</span> wrote on <span class="date">2010-11-13 19:08</span>:
        </div>
        <div class="comment-content">
          <p>What about the additional running time overhead?</p>
        </div>
      </div>
      <div class="comment comment-5462825228324060529">
        <div class="comment-header">
          <a name="comment-5462825228324060529"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-13 20:48</span>:
        </div>
        <div class="comment-content">
          <p>I was surprised not to see any real-world benchmarks (since you collected them earlier). That leaves the impression, that it might be disapointing (knowing that the object/class ratio generally isn't very large).</p>
        </div>
      </div>
      <div class="comment comment-1445643915832363259">
        <div class="comment-header">
          <a name="comment-1445643915832363259"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-11-13 21:48</span>:
        </div>
        <div class="comment-content">
          <p>@Reid:<br>I am glossing over the runtime overhead, because the JIT completely removes it, as it knows that the maps are immutable. So you only have a problem if you don't want a JIT, in which case maps indeed make some things a bit slower. Duplicating the information everywhere is possible, but I would like to avoid it (we had a prototype that did it, and it became messy quickly).<br><br>@Erez<br>There is no additional runtime overhead if you have the JIT – in fact, things become faster, because the JIT can turn an attribute access into a array field read out of the storage array at a fixed offset.<br><br>@Anonymous<br>I have not presented any real-world benchmarks, because I actually did not get around to running them. Yes, I collected some and started writing a memory benchmark framework. But I didn't have time for a full analysis yet. I plan to do such an analysis hopefully soon.<br><br>Anyway, maps never make anything larger, so it is really just a matter of how many instances there are in practice. This will just depend on the benchmark.</p>
        </div>
      </div>
      <div class="comment comment-4973317805930862659">
        <div class="comment-header">
          <a name="comment-4973317805930862659"></a>
            <span class="author">Zeev</span> wrote on <span class="date">2010-11-14 00:13</span>:
        </div>
        <div class="comment-content">
          <p>Does this optimization enable building pypy using pypy without having 16GB of ram?</p>
        </div>
      </div>
      <div class="comment comment-8109962982969843413">
        <div class="comment-header">
          <a name="comment-8109962982969843413"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2010-11-14 01:29</span>:
        </div>
        <div class="comment-content">
          <p>Is there anything intrinsic toPyPy in this, or can this optimisation be used in CPython as well?</p>
        </div>
      </div>
      <div class="comment comment-4211257088140676616">
        <div class="comment-header">
          <a name="comment-4211257088140676616"></a>
            <span class="author">ot</span> wrote on <span class="date">2010-11-14 03:16</span>:
        </div>
        <div class="comment-content">
          <p>To remove the chain-walking overhead when the code is not JITted, would it be possible to use a persistent hashtable, like for example the hash trie used in Clojure (see https://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice/)? They are quite simple to implement and very fast (almost as fast as a normal hashtable lookup)</p>
        </div>
      </div>
      <div class="comment comment-5202625175156727929">
        <div class="comment-header">
          <a name="comment-5202625175156727929"></a>
            <span class="author">Allen Short</span> wrote on <span class="date">2010-11-14 08:34</span>:
        </div>
        <div class="comment-content">
          <p>ot: i'm part way to implementing that for Python.<br><br>https://bazaar.launchpad.net/~washort/%2Bjunk/perseus/annotate/head:/perseus/__init__.py</p>
        </div>
      </div>
      <div class="comment comment-5294634611556603176">
        <div class="comment-header">
          <a name="comment-5294634611556603176"></a>
            <span class="author">ot</span> wrote on <span class="date">2010-11-14 21:23</span>:
        </div>
        <div class="comment-content">
          <p>@Allen: interesting, I wonder how much code would need to be changed to make it RPython...</p>
        </div>
      </div>
      <div class="comment comment-5681147692410048223">
        <div class="comment-header">
          <a name="comment-5681147692410048223"></a>
            <span class="author">verte</span> wrote on <span class="date">2010-11-15 07:45</span>:
        </div>
        <div class="comment-content">
          <p>What are the pypy "with slots" and "without slots" numbers? They are different even though you point out that they have no effect. Is the pypy in question one with sharing dicts?</p>
        </div>
      </div>
      <div class="comment comment-7772094251400965646">
        <div class="comment-header">
          <a name="comment-7772094251400965646"></a>
            <span class="author">Maciej Fijalkowski</span> wrote on <span class="date">2010-11-15 07:56</span>:
        </div>
        <div class="comment-content">
          <p>@verte mapdicts help pypy objects with or without slots (although much more for the latter). There is no difference in pypy with mapdict between having slots or not having slots.</p>
        </div>
      </div>
      <div class="comment comment-3845360728805325221">
        <div class="comment-header">
          <a name="comment-3845360728805325221"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2010-11-15 12:58</span>:
        </div>
        <div class="comment-content">
          <p>@Zeev no, the translation results from last week already included this optimization. Maps don't help translation much, because we already added all the necessary slot declarations to save memory on CPython.<br><br>@ot Would be possible, yes. Not sure it is worth it, given that the total set of attributes of typical instances is not very large. The data structure looks interesting though.</p>
        </div>
      </div>
      <div class="comment comment-2328794658467699116">
        <div class="comment-header">
          <a name="comment-2328794658467699116"></a>
            <span class="author">ot</span> wrote on <span class="date">2010-11-15 13:21</span>:
        </div>
        <div class="comment-content">
          <p>@Carl: yes, it was just hypotetic, "if it is a bottleneck". I think anyway that even with very small instance dictionaries there could be a benefit: most keys would be resolved within the first layer of the trie, so with a single lookup or two at most. But it could be premature optimization.</p>
        </div>
      </div>
      <div class="comment comment-2140109847813676734">
        <div class="comment-header">
          <a name="comment-2140109847813676734"></a>
            <span class="author">verte</span> wrote on <span class="date">2010-11-16 00:30</span>:
        </div>
        <div class="comment-content">
          <p>I still don't understand. Was there a difference with __slots__ on pypy before mapdict? Why are the numbers different on pypy without mapdict? Are those the numbers with or without the old sharing dictimpl? If without, what is the memory usage with sharing dicts?</p>
        </div>
      </div>
      <div class="comment comment-2450714668067085687">
        <div class="comment-header">
          <a name="comment-2450714668067085687"></a>
            <span class="author">barnert</span> wrote on <span class="date">2014-08-03 23:31</span>:
        </div>
        <div class="comment-content">
          <p>This came up on <a href="https://stackoverflow.com/questions/13761423/does-pep-412-make-slots-redundant/13763204#comment39074868_13763204" rel="nofollow">StackOverflow</a>, but let me answer it here.<br><br>While the CPython split-dict implementation in 3.3+ (<a href="https://legacy.python.org/dev/peps/pep-0412/" rel="nofollow">PEP 412</a>) may be inspired by your design, it's not the same, and it doesn't provide nearly as much savings.<br><br>The first difference is that it still has a full dict struct in the instance. For classes without that many attributes (i.e., most of them), the dict struct is almost as big as the hash table, so this means you typically only get half the savings as in PyPy. However, this means the thing you can access by __dict__ isn't created dynamically, it acts exactly like a dict even at the C API level, and it can transparently (again, even at the C API level) convert itself to a combined dict if needed (if the table needs to expand and there's more than one reference to the shared key table). The fact that the difference between 3.2 and 3.3 is completely undetectable to any code that doesn't directly access the hash buckets is a big part of the reason Mark Shannon was able to get everyone to agree to accept it, and as far as I know there's no serious consideration for changing it.<br><br>The second difference is that the dict struct's array is kept in the same (sparse) order as the shared key table, rather than being a compact array indexed by the values of the shared key table. This means it's kept at least 1/3rd unloaded, meaning that again you get less space savings than with PyPy. There's less of a good rationale here; there's a small performance cost to the slightly more complicated code needed for indexing PyPy-style, and it would make small combined dicts one word larger (which could affect classes whose instances all have different attributes, or cases where you have a huge number of classes with few instances, or other edge cases). The PEP implies that using the sparse implementation is probably overly conservative, and leaves open the possibility of changing it after 3.3.</p>
        </div>
      </div>
         </div>

          </section>
</div>
    <div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2025/07/pypy-v7320-release.html" class="listtitle">PyPy v7.3.20 release</a>
      </li>
      <li>
        <a href="/posts/2025/06/rpython-gc-allocation-speed.html" class="listtitle">How fast can the RPython GC allocate?</a>
      </li>
      <li>
        <a href="/posts/2025/04/prospero-in-rpython.html" class="listtitle">Doing the Prospero-Challenge in RPython</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7319-release.html" class="listtitle">PyPy v7.3.19 release</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-gc-sampling.html" class="listtitle">Low Overhead Allocation Sampling with VMProf in PyPy's GC</a>
      </li>
      <li>
        <a href="/posts/2025/02/pypy-v7318-release.html" class="listtitle">PyPy v7.3.18 release</a>
      </li>
      <li>
        <a href="/posts/2025/01/musings-tracing.html" class="listtitle">Musings on Tracing in PyPy</a>
      </li>
      <li>
        <a href="/posts/2025/01/towards-pypy311-an-update.html" class="listtitle">Towards PyPy3.11 - an update</a>
      </li>
      <li>
        <a href="/posts/2024/11/guest-post-final-encoding-in-rpython.html" class="listtitle">Guest Post: Final Encoding in RPython Interpreters</a>
      </li>
      <li>
        <a href="/posts/2024/10/jit-peephole-dsl.html" class="listtitle">A DSL for Peephole Transformation Rules of Integer Operations in the PyPy JIT</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
            <li><a class="reference" href="/2021/">2021</a> (10)
            </li>
            <li><a class="reference" href="/2022/">2022</a> (13)
            </li>
            <li><a class="reference" href="/2023/">2023</a> (6)
            </li>
            <li><a class="reference" href="/2024/">2024</a> (13)
            </li>
            <li><a class="reference" href="/2025/">2025</a> (8)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (2)</li>
            <li><a class="reference" href="/categories/benchmarking.html">benchmarking</a> (1)</li>
            <li><a class="reference" href="/categories/casestudy.html">casestudy</a> (3)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/conda-forge.html">conda-forge</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (4)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (3)</li>
            <li><a class="reference" href="/categories/gc.html">gc</a> (3)</li>
            <li><a class="reference" href="/categories/guestpost.html">guestpost</a> (3)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (23)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/meta.html">meta</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/performance.html">performance</a> (2)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (7)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (66)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (2)</li>
            <li><a class="reference" href="/categories/rpython.html">rpython</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (6)</li>
            <li><a class="reference" href="/categories/sponsors.html">sponsors</a> (7)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/sprints.html">sprints</a> (1)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/testing.html">testing</a> (1)</li>
            <li><a class="reference" href="/categories/toy-optimizer.html">toy-optimizer</a> (5)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
            <li><a class="reference" href="/categories/vmprof.html">vmprof</a> (3)</li>
            <li><a class="reference" href="/categories/z3.html">z3</a> (5)</li>
          </ul>
        </div>    </div>
</article></main><footer id="footer"><p>
</p>
<div class="myfooter">
  <div class="logotext">
    © 2025 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
     
    Built with <a href="https://getnikola.com" rel="nofollow">Nikola</a>
     
    Last built 2025-07-07T11:01
  </div>
  <div style="margin-left: auto">
  <a href="../../../rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../../../assets/js/styles.js"></script></footer>
</div>
</body>
</html>