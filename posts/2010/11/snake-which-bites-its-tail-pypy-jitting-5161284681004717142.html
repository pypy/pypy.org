<html><body><a href="https://2.bp.blogspot.com/_4gR6Ggu8oHQ/TNmLArIQa0I/AAAAAAAAAKk/S86e8w4lF6g/s1600/pypy.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5537610060522351426" src="https://2.bp.blogspot.com/_4gR6Ggu8oHQ/TNmLArIQa0I/AAAAAAAAAKk/S86e8w4lF6g/s400/pypy.png" style="float: right; margin: 0 0 10px 10px; cursor: pointer; cursor: hand; width: 321px; height: 263px;"></a>


<p>We have to admit: even if we have been writing for years about the fantastic
speedups that the PyPy JIT gives, we, the PyPy developers, still don't use it
for our daily routine.  <strong>Until today</strong> :-).</p>
<p>Readers brave enough to run <tt class="docutils literal">translate.py</tt> to translate PyPy by themselves
surely know that the process takes quite a long time to complete, about a hour
on super-fast hardware and even more on average computers.  Unfortunately, it
happened that <tt class="docutils literal">translate.py</tt> was a bad match for our JIT and thus ran much
slower on PyPy than on CPython.</p>
<p>One of the main reasons is that the PyPy translation toolchain makes heavy use
of custom metaclasses, and until few weeks ago metaclasses disabled some of
the central optimizations which make PyPy so fast.  During the recent
<a class="reference external" href="https://morepypy.blogspot.com/2010/10/dusseldorf-sprint-report-2010.html">DÃ¼sseldorf sprint</a>, Armin and Carl Friedrich <a class="reference external" href="https://codespeak.net/pipermail/pypy-svn/2010-October/044046.html">fixed</a> this problem and
re-enabled all the optimizations even in presence of metaclasses.</p>
<p>So, today we decided that it was time to benchmark again PyPy against itself.
First, we tried to translate PyPy using CPython as usual, with the following
command line (on a machine with an "Intel(R) Xeon(R) CPU W3580 @ 3.33GHz" and
12 GB of RAM, running a 32-bit Ubuntu):</p>
<pre class="literal-block">
$ python ./translate.py -Ojit targetpypystandalone --no-allworkingmodules

... lots of output, fractals included ...

[Timer] Timings:
[Timer] annotate                       ---  252.0 s
[Timer] rtype_lltype                   ---  199.3 s
[Timer] pyjitpl_lltype                 ---  565.2 s
[Timer] backendopt_lltype              ---  217.4 s
[Timer] stackcheckinsertion_lltype     ---   26.8 s
[Timer] database_c                     ---  234.4 s
[Timer] source_c                       ---  480.7 s
[Timer] compile_c                      ---  258.4 s
[Timer] ===========================================
[Timer] Total:                         --- 2234.2 s
</pre>
<p>Then, we tried the same command line with PyPy (SVN revision 78903, x86-32 JIT
backend, downloaded from the <a class="reference external" href="https://buildbot.pypy.org/nightly/trunk/">nightly build</a> page):</p>
<pre class="literal-block">
$ pypy-c-78903 ./translate.py -Ojit targetpypystandalone --no-allworkingmodules

... lots of output, fractals included ...

[Timer] Timings:
[Timer] annotate                       ---  165.3 s
[Timer] rtype_lltype                   ---  121.9 s
[Timer] pyjitpl_lltype                 ---  224.0 s
[Timer] backendopt_lltype              ---   72.1 s
[Timer] stackcheckinsertion_lltype     ---    7.0 s
[Timer] database_c                     ---  104.4 s
[Timer] source_c                       ---  167.9 s
[Timer] compile_c                      ---  320.3 s
[Timer] ===========================================
[Timer] Total:                         --- 1182.8 s
</pre>
<p>Yes, it's not a typo: PyPy is almost <strong>two times faster</strong> than CPython!
Moreover, we can see that PyPy is faster in each of the individual steps apart
<tt class="docutils literal">compile_c</tt>, which consists in just a call to <tt class="docutils literal">make</tt> to invoke <tt class="docutils literal">gcc</tt>.
The slowdown comes from the fact that the Makefile also contains a lot of
calls to the <a class="reference external" href="https://codespeak.net/svn/pypy/trunk/pypy/translator/c/gcc/trackgcroot.py">trackgcroot.py</a> script, which happens to perform badly on PyPy
but we did not investigate why yet.</p>
<p>However, there is also a drawback: on this specific benchmark, PyPy consumes
much more memory than CPython.  The reason why the command line above contains
<tt class="docutils literal"><span class="pre">--no-allworkingmodules</span></tt> is that if we include all the modules the
translation crashes when it's complete at 99% because it consumes all the 4GB
of memory which is addressable by a 32-bit process.</p>
<p>A partial explanation if that so far the assembler generated by the PyPy JIT
is immortal, and the memory allocated for it is never reclaimed.  This is
clearly bad for a program like <tt class="docutils literal">translate.py</tt> which is divided into several
independent steps, and for which most of the code generated in each step could
be safely be thrown away when it's completed.</p>
<p>If we switch to 64-bit we can address the whole 12 GB of RAM that we have, and
thus translating with all working modules is no longer an issue.  This is the
time taken with CPython (note that it does not make sense to compare with the
32-bit CPython translation above, because that one does not include all the
modules):</p>
<pre class="literal-block">
$ python ./translate.py -Ojit

[Timer] Timings:
[Timer] annotate                       ---  782.7 s
[Timer] rtype_lltype                   ---  445.2 s
[Timer] pyjitpl_lltype                 ---  955.8 s
[Timer] backendopt_lltype              ---  457.0 s
[Timer] stackcheckinsertion_lltype     ---   63.0 s
[Timer] database_c                     ---  505.0 s
[Timer] source_c                       ---  939.4 s
[Timer] compile_c                      ---  465.1 s
[Timer] ===========================================
[Timer] Total:                         --- 4613.2 s
</pre>
<p>And this is for PyPy:</p>
<pre class="literal-block">
$ pypy-c-78924-64 ./translate.py -Ojit

[Timer] Timings:
[Timer] annotate                       ---  505.8 s
[Timer] rtype_lltype                   ---  279.4 s
[Timer] pyjitpl_lltype                 ---  338.2 s
[Timer] backendopt_lltype              ---  125.1 s
[Timer] stackcheckinsertion_lltype     ---   21.7 s
[Timer] database_c                     ---  187.9 s
[Timer] source_c                       ---  298.8 s
[Timer] compile_c                      ---  650.7 s
[Timer] ===========================================
[Timer] Total:                         --- 2407.6 s
</pre>
<p>The results are comparable with the 32-bit case: PyPy is still almost 2 times
faster than CPython.  And it also shows that our 64-bit JIT backend is as good
as the 32-bit one.  Again, the drawback is in the consumed memory: CPython
used 2.3 GB while PyPy took 8.3 GB.</p>
<p>Overall, the results are impressive: we knew that PyPy can be good at
optimizing small benchmarks and even middle-sized programs, but as far as we
know this is the first example in which it heavily optimizes a huge, real world
application.  And, believe us, the PyPy translation toolchain is complex
enough to contains all kinds of dirty tricks and black magic that make Python
lovable and hard to optimize :-).</p></body></html>