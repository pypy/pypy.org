<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts about extension modules)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/categories/extension-modules.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2026 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Sat, 17 Jan 2026 00:22:36 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>PyPy and conda-forge</title><link>https://www.pypy.org/posts/2022/11/pypy-and-conda-forge.html</link><dc:creator>mattip</dc:creator><description>&lt;p&gt;You can use PyPy as your python interpreter in a conda environment. The
conda-forge team has graciously provided this service.&lt;/p&gt;
&lt;p&gt;The conda-forge &lt;a href="https://conda-forge.org/docs/user/tipsandtricks.html#using-pypy-as-an-interpreter"&gt;tips-and-tricks&lt;/a&gt;
page says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The conda-forge channel supports creating and installing packages into
environments using the PyPy interpreter. Many packages are already available.
You need to enable the conda-forge channel and use the pypy identifier when
creating your environment:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;  $ conda create -c conda-forge -n my-pypy-env pypy python=3.8
  $ conda activate my-pypy-env
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;Currently supported python versions are 3.8 and 3.9. Support for pypy3.7 has
been dropped. While you can still create a python 3.7 environment, you you
will not be getting updates as new package versions are released (including
pypy itself).&lt;/p&gt;
&lt;p&gt;if you are using defaults as a low priority channel, then you need to use
strict channel priority as the metadata in defaults has not been patched yet
which allows cpython extension packages to be installed alongside pypy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;  $ conda config --set channel_priority strict
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The work required some out-of-the-box thinking on the part of conda-forge since
they needed to add the idea of a &lt;code&gt;pypy&lt;/code&gt; identifier to the python version and
the whole conda team has been very supportive of the effort needed. Binary
packages are on offer for the usual platforms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x86_64&lt;/code&gt; windows, macos, linux&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ppc64le&lt;/code&gt; and &lt;code&gt;aarch64&lt;/code&gt; linux.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are &lt;a href="https://conda-forge.org/status/#pypy38"&gt;currently over 1000 packages&lt;/a&gt; available for download via the
conda-forge channel, and more are being added as the kind package maintainers
work around various differences between CPython and PyPy. Please let us know if
your favorite package is not supported.&lt;/p&gt;</description><category>extension modules</category><guid>https://www.pypy.org/posts/2022/11/pypy-and-conda-forge.html</guid><pubDate>Sat, 05 Nov 2022 17:00:25 GMT</pubDate></item><item><title>Using CPython extension modules with PyPy natively, or: PyPy can load .pyd files with CPyExt!</title><link>https://www.pypy.org/posts/2010/04/using-cpython-extension-modules-with-5864754772659599217.html</link><dc:creator>Alexander Schremmer</dc:creator><description>&lt;p&gt;PyPy is now able to load
and run CPython extension modules (i.e. .pyd and .so files) natively by using the new CPyExt
subsystem.
Unlike the solution presented in &lt;a class="reference external" href="https://www.pypy.org/posts/2009/11/using-cpython-extension-modules-with-4951018896657992031.html"&gt;another blog post&lt;/a&gt; (where extension modules like
numpy etc. were run on CPython and proxied through TCP), this solution does not require
a running CPython anymore. We do not achieve full binary compatiblity
yet (like Ironclad), but recompiling the extension is generally enough.&lt;/p&gt;
&lt;p&gt;The only prerequisite is that the necessary functions of the C API of CPython are already
implemented in PyPy. If you are a user or an author of a module and miss certain functions
in PyPy, we invite you to implement them. Up until now, a lot of people (including a lot of
new committers) have stepped up and implemented a few functions to get their favorite module
running. See the end of this post for a list of names.&lt;/p&gt;
&lt;p&gt;Regarding speed, we tried the following: even though there is a bit of overhead when running
these modules, we could run the regular expression engine of CPython (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_sre.so&lt;/span&gt;&lt;/tt&gt;) and execute
the spambayes benchmark of the Unladen Swallow benchmark suite (cf. &lt;a class="reference external" href="https://speed.pypy.org/"&gt;speed.pypy.org&lt;/a&gt;) and
experience a speedup:
It became &lt;em&gt;two times faster&lt;/em&gt; on pypy-c than with the built-in regular
expression engine of PyPy. From &lt;a href="https://en.wikipedia.org/wiki/Amdahl%27s_law"&gt;Amdahl's Law&lt;/a&gt; it follows that the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_sre.so&lt;/span&gt;&lt;/tt&gt; must run several
times faster than the built-in engine.&lt;/p&gt;
&lt;p&gt;Currently pursued modules include PIL and others. Distutils support is nearly ready.
If you would like to participate or want information on how to use this new feature, come and join
our IRC channel &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;#pypy&lt;/span&gt;&lt;/tt&gt; on &lt;a class="reference external" href="irc://irc.freenode.net/"&gt;freenode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Amaury Forgeot d'Arc and Alexander Schremmer&lt;/p&gt;
&lt;p&gt;Further CPyExt Contributors:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Alex Gaynor
&lt;/li&gt;&lt;li&gt;Benjamin Peterson
&lt;/li&gt;&lt;li&gt;Jean-Paul Calderone
&lt;/li&gt;&lt;li&gt;Maciej Fijalkowski
&lt;/li&gt;&lt;li&gt;Jan de Mooij
&lt;/li&gt;&lt;li&gt;Lucian Branescu Mihaila
&lt;/li&gt;&lt;li&gt;Andreas Stührk
&lt;/li&gt;&lt;li&gt;Zooko Wilcox-O Hearn&lt;/li&gt;&lt;/ul&gt;</description><category>cpyext</category><category>CPython</category><category>extension modules</category><category>speed</category><guid>https://www.pypy.org/posts/2010/04/using-cpython-extension-modules-with-5864754772659599217.html</guid><pubDate>Fri, 09 Apr 2010 22:56:00 GMT</pubDate></item><item><title>Using CPython extension modules with PyPy, or: PyQt on PyPy</title><link>https://www.pypy.org/posts/2009/11/using-cpython-extension-modules-with-4951018896657992031.html</link><dc:creator>Alexander Schremmer</dc:creator><description>&lt;div class="document" id="using-cpython-extension-modules-with-pypy-or-pyqt-on-pypy"&gt;

&lt;p&gt;If you have ever wanted to use CPython extension modules on PyPy,
we want to announce that there is a solution that should be compatible
to quite a bit of the available modules. It is neither new nor written
by us, but works nevertheless great with PyPy.&lt;/p&gt;
&lt;p&gt;The trick is to use RPyC, a transparent, symmetric remote procedure
call library written in Python. The idea is to start a
CPython process that hosts the PyQt libraries
and connect to it via TCP to send RPC commands to it.&lt;/p&gt;
&lt;p&gt;I tried to run PyQt applications
using it on PyPy and could get quite a bit of the functionality of these
working. Remaining problems include regular segfaults of CPython
because of PyQt-induced memory corruption and bugs because classes
like StandardButtons behave incorrectly when it comes to arithmetical operations.&lt;/p&gt;
&lt;p&gt;Changes to RPyC needed to be done to support remote unbound &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;__init__&lt;/span&gt;&lt;/tt&gt; methods,
shallow call by value for list and dict types (PyQt4 methods want real lists and dicts
as parameters), and callbacks to methods (all remote method objects are wrapped into
small lambda functions to ease the call for PyQt4).&lt;/p&gt;
&lt;p&gt;If you want to try RPyC to run the PyQt application of your choice, you just
need to follow these steps. Please report your experience here in the blog
comments or on our &lt;a class="reference external" href="https://codespeak.net/mailman/listinfo/pypy-dev"&gt;mailing list&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Download RPyC from the &lt;a class="reference external" href="https://sourceforge.net/projects/rpyc/files/"&gt;RPyC download page&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Download this &lt;a class="reference external" href="https://codespeak.net/svn/user/xoraxax/rpyc-3.0.7-pyqt4-compat.patch"&gt;patch&lt;/a&gt; and apply it to RPyC by running
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;patch&lt;/span&gt; &lt;span class="pre"&gt;-p1&lt;/span&gt; &lt;span class="pre"&gt;&amp;lt;&lt;/span&gt; &lt;span class="pre"&gt;rpyc-3.0.7-pyqt4-compat.patch&lt;/span&gt;&lt;/tt&gt; in the RPyC directory.&lt;/li&gt;
&lt;li&gt;Install RPyc by running &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;python&lt;/span&gt; &lt;span class="pre"&gt;setup.py&lt;/span&gt; &lt;span class="pre"&gt;install&lt;/span&gt;&lt;/tt&gt; as root.&lt;/li&gt;
&lt;li&gt;Run the file &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rpyc/servers/classic_server.py&lt;/span&gt;&lt;/tt&gt; using CPython.&lt;/li&gt;
&lt;li&gt;Execute your PyQt application on PyPy.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;PyPy will automatically connect to CPython and use its PyQt libraries.&lt;/p&gt;
&lt;p&gt;Note that this scheme works with nearly every extension library. Look
at &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;pypy/lib/sip.py&lt;/span&gt;&lt;/tt&gt; on how to add new libraries (you need to create
such a file for every proxied extension module).&lt;/p&gt;
&lt;p&gt;Have fun with PyQt&lt;/p&gt;
&lt;p&gt;Alexander Schremmer&lt;/p&gt;
&lt;/div&gt;</description><category>CPython</category><category>extension modules</category><category>PyQt4</category><category>RPyC</category><guid>https://www.pypy.org/posts/2009/11/using-cpython-extension-modules-with-4951018896657992031.html</guid><pubDate>Mon, 30 Nov 2009 11:19:00 GMT</pubDate></item></channel></rss>