<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts about jit)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/categories/jit.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2025 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Mon, 07 Jul 2025 11:01:31 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>A DSL for Peephole Transformation Rules of Integer Operations in the PyPy JIT</title><link>https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html</link><dc:creator>CF Bolz-Tereick</dc:creator><description>&lt;p&gt;As is probably apparent from the sequence of blog posts about the topic in the
last year, I have been thinking about and working on integer optimizations in the JIT
compiler a lot. This work was mainly motivated by &lt;a class="reference external" href="https://docs.pydrofoil.org/en/latest/"&gt;Pydrofoil&lt;/a&gt;, where integer
operations matter a lot more than for your typical Python program.&lt;/p&gt;
&lt;p&gt;In this post I'll describe my most recent change, which is a new small domain
specific language that I implemented to specify peephole optimizations on
integer operations in the JIT.
It uses pattern matching to specify how (sequences of) integer operations
should be simplified and optimized. The rules are then compiled to
RPython code that then becomes part of the JIT's optimization passes.&lt;/p&gt;
&lt;p&gt;To make it less likely to introduce incorrect optimizations into the JIT, the
rules are automatically proven correct with Z3 as part of the build process (for
a more hands-on intro to how that works you can look at the &lt;a class="reference external" href="https://pypy.org/posts/2024/08/toy-knownbits.html#proving-correctness-of-the-transfer-functions-with-z3"&gt;knownbits&lt;/a&gt; post).
In this blog post I want to motivate why I introduced the DSL and give an
introduction to how it works.&lt;/p&gt;
&lt;section id="motivation"&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;This summer, after I wrote my &lt;a class="reference external" href="https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html"&gt;scripts to mine JIT traces for missed optimization&lt;/a&gt;
opportunities, I started implementing a few of the integer peephole rewrite that
the script identified. Unfortunately, doing so led to the problem that the way
we express these rewrites up to now is very imperative and verbose. Here's a
snippet of RPython code that shows some rewrites for integer multiplication
(look at the comments to see what the different parts actually do). You don't
need to understand the code in detail, but basically it's in very imperative
style and there's quite a lot of boilerplate.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-1" name="rest_code_c97fcd9e298e43d28ec28d228f345007-1" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;optimize_INT_MUL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-2" name="rest_code_c97fcd9e298e43d28ec28d228f345007-2" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-2"&gt;&lt;/a&gt;    &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_box_replacement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-3" name="rest_code_c97fcd9e298e43d28ec28d228f345007-3" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-3"&gt;&lt;/a&gt;    &lt;span class="n"&gt;b0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getintbound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-4" name="rest_code_c97fcd9e298e43d28ec28d228f345007-4" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_box_replacement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-5" name="rest_code_c97fcd9e298e43d28ec28d228f345007-5" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-5"&gt;&lt;/a&gt;    &lt;span class="n"&gt;b1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getintbound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-6" name="rest_code_c97fcd9e298e43d28ec28d228f345007-6" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-6"&gt;&lt;/a&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-7" name="rest_code_c97fcd9e298e43d28ec28d228f345007-7" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-7"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;known_eq_const&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-8" name="rest_code_c97fcd9e298e43d28ec28d228f345007-8" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-8"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# 1 * x == x&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-9" name="rest_code_c97fcd9e298e43d28ec28d228f345007-9" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-9"&gt;&lt;/a&gt;        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_equal_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-10" name="rest_code_c97fcd9e298e43d28ec28d228f345007-10" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-10"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;known_eq_const&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-11" name="rest_code_c97fcd9e298e43d28ec28d228f345007-11" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-11"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# x * 1 == x&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-12" name="rest_code_c97fcd9e298e43d28ec28d228f345007-12" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-12"&gt;&lt;/a&gt;        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_equal_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-13" name="rest_code_c97fcd9e298e43d28ec28d228f345007-13" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-13"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;known_eq_const&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;known_eq_const&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-14" name="rest_code_c97fcd9e298e43d28ec28d228f345007-14" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-14"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# 0 * x == x * 0 == 0&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-15" name="rest_code_c97fcd9e298e43d28ec28d228f345007-15" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-15"&gt;&lt;/a&gt;        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_constant_int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-16" name="rest_code_c97fcd9e298e43d28ec28d228f345007-16" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-16"&gt;&lt;/a&gt;    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-17" name="rest_code_c97fcd9e298e43d28ec28d228f345007-17" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-17"&gt;&lt;/a&gt;        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)]:&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-18" name="rest_code_c97fcd9e298e43d28ec28d228f345007-18" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-18"&gt;&lt;/a&gt;            &lt;span class="n"&gt;lh_info&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getintbound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-19" name="rest_code_c97fcd9e298e43d28ec28d228f345007-19" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-19"&gt;&lt;/a&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;lh_info&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_constant&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-20" name="rest_code_c97fcd9e298e43d28ec28d228f345007-20" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-20"&gt;&lt;/a&gt;                &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lh_info&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_constant_int&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-21" name="rest_code_c97fcd9e298e43d28ec28d228f345007-21" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-21"&gt;&lt;/a&gt;                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-22" name="rest_code_c97fcd9e298e43d28ec28d228f345007-22" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-22"&gt;&lt;/a&gt;                    &lt;span class="c1"&gt;# x * (2 ** c) == x &amp;lt;&amp;lt; c&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-23" name="rest_code_c97fcd9e298e43d28ec28d228f345007-23" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-23"&gt;&lt;/a&gt;                    &lt;span class="n"&gt;new_rhs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ConstInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;highest_bit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lh_info&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_constant_int&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-24" name="rest_code_c97fcd9e298e43d28ec28d228f345007-24" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-24"&gt;&lt;/a&gt;                    &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace_op_with&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INT_LSHIFT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_rhs&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-25" name="rest_code_c97fcd9e298e43d28ec28d228f345007-25" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-25"&gt;&lt;/a&gt;                    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;optimizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_extra_operation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-26" name="rest_code_c97fcd9e298e43d28ec28d228f345007-26" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-26"&gt;&lt;/a&gt;                    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-27" name="rest_code_c97fcd9e298e43d28ec28d228f345007-27" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-27"&gt;&lt;/a&gt;                &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-28" name="rest_code_c97fcd9e298e43d28ec28d228f345007-28" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-28"&gt;&lt;/a&gt;                    &lt;span class="c1"&gt;# x * -1 == -x&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-29" name="rest_code_c97fcd9e298e43d28ec28d228f345007-29" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-29"&gt;&lt;/a&gt;                    &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace_op_with&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INT_NEG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-30" name="rest_code_c97fcd9e298e43d28ec28d228f345007-30" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-30"&gt;&lt;/a&gt;                    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;optimizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_extra_operation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-31" name="rest_code_c97fcd9e298e43d28ec28d228f345007-31" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-31"&gt;&lt;/a&gt;                    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-32" name="rest_code_c97fcd9e298e43d28ec28d228f345007-32" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-32"&gt;&lt;/a&gt;            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-33" name="rest_code_c97fcd9e298e43d28ec28d228f345007-33" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-33"&gt;&lt;/a&gt;                &lt;span class="c1"&gt;# x * (1 &amp;lt;&amp;lt; y) == x &amp;lt;&amp;lt; y&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-34" name="rest_code_c97fcd9e298e43d28ec28d228f345007-34" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-34"&gt;&lt;/a&gt;                &lt;span class="n"&gt;shiftop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;optimizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_operation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;get_box_replacement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;rop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INT_LSHIFT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-35" name="rest_code_c97fcd9e298e43d28ec28d228f345007-35" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-35"&gt;&lt;/a&gt;                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;shiftop&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-36" name="rest_code_c97fcd9e298e43d28ec28d228f345007-36" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-36"&gt;&lt;/a&gt;                    &lt;span class="k"&gt;continue&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-37" name="rest_code_c97fcd9e298e43d28ec28d228f345007-37" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-37"&gt;&lt;/a&gt;                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;shiftop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_constant&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;shiftop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getint&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-38" name="rest_code_c97fcd9e298e43d28ec28d228f345007-38" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-38"&gt;&lt;/a&gt;                    &lt;span class="k"&gt;continue&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-39" name="rest_code_c97fcd9e298e43d28ec28d228f345007-39" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-39"&gt;&lt;/a&gt;                &lt;span class="n"&gt;shiftvar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_box_replacement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shiftop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-40" name="rest_code_c97fcd9e298e43d28ec28d228f345007-40" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-40"&gt;&lt;/a&gt;                &lt;span class="n"&gt;shiftbound&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getintbound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shiftvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-41" name="rest_code_c97fcd9e298e43d28ec28d228f345007-41" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-41"&gt;&lt;/a&gt;                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;shiftbound&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;known_nonnegative&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;shiftbound&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;known_lt_const&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-42" name="rest_code_c97fcd9e298e43d28ec28d228f345007-42" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-42"&gt;&lt;/a&gt;                    &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace_op_with&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-43" name="rest_code_c97fcd9e298e43d28ec28d228f345007-43" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-43"&gt;&lt;/a&gt;                            &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INT_LSHIFT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shiftvar&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-44" name="rest_code_c97fcd9e298e43d28ec28d228f345007-44" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-44"&gt;&lt;/a&gt;                    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;optimizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_extra_operation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-45" name="rest_code_c97fcd9e298e43d28ec28d228f345007-45" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-45"&gt;&lt;/a&gt;                    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;a id="rest_code_c97fcd9e298e43d28ec28d228f345007-46" name="rest_code_c97fcd9e298e43d28ec28d228f345007-46" href="https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_c97fcd9e298e43d28ec28d228f345007-46"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Adding more rules to these functions is very tedious and gets super confusing
when the functions get bigger. In addition I am always worried about making
mistakes when writing this kind of code, and there is no feedback at all about
which of these rules are actually applied a lot in real programs.&lt;/p&gt;
&lt;p&gt;Therefore I decided to write a small domain specific language with the goal of
expressing these rules in a more declarative way. In the rest of the post I'll
describe the DSL (most of that description is adapted from the &lt;a class="reference external" href="https://rpython.readthedocs.io/en/latest/jit/ruleopt.html"&gt;documentation&lt;/a&gt;
about it that I wrote).&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-peephole-rule-dsl"&gt;
&lt;h2&gt;The Peephole Rule DSL&lt;/h2&gt;
&lt;section id="simple-transformation-rules"&gt;
&lt;h3&gt;Simple transformation rules&lt;/h3&gt;
&lt;p&gt;The rules in the DSL specify how integer operation can be transformed into
cheaper other integer operations. A rule always consists of a name, a pattern,
and a target. Here's a simple rule:&lt;/p&gt;
&lt;pre class="literal-block"&gt;add_zero: int_add(x, 0)
    =&amp;gt; x&lt;/pre&gt;
&lt;p&gt;The name of the rule is &lt;code class="docutils literal"&gt;add_zero&lt;/code&gt;. It matches operations in the trace of the
form &lt;code class="docutils literal"&gt;int_add(x, 0)&lt;/code&gt;, where &lt;code class="docutils literal"&gt;x&lt;/code&gt; will match anything and &lt;code class="docutils literal"&gt;0&lt;/code&gt; will match only the
constant zero. After the &lt;code class="docutils literal"&gt;=&amp;gt;&lt;/code&gt; arrow is the target of the rewrite, i.e. what the
operation is rewritten to, in this case &lt;code class="docutils literal"&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The rule language has a list of which of the operations are commutative, so &lt;code class="docutils literal"&gt;add_zero&lt;/code&gt;
will also optimize &lt;code class="docutils literal"&gt;int_add(0, x)&lt;/code&gt; to &lt;code class="docutils literal"&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Variables in the pattern can repeat:&lt;/p&gt;
&lt;pre class="literal-block"&gt;sub_x_x: int_sub(x, x)
    =&amp;gt; 0&lt;/pre&gt;
&lt;p&gt;This rule matches against &lt;code class="docutils literal"&gt;int_sub&lt;/code&gt; operations where the two arguments are the
same (either the same box, or the same constant).&lt;/p&gt;
&lt;p&gt;Here's a rule with a more complicated pattern:&lt;/p&gt;
&lt;pre class="literal-block"&gt;sub_add: int_sub(int_add(x, y), y)
    =&amp;gt; x&lt;/pre&gt;
&lt;p&gt;This pattern matches &lt;code class="docutils literal"&gt;int_sub&lt;/code&gt; operations, where the first argument was
produced by an &lt;code class="docutils literal"&gt;int_add&lt;/code&gt; operation. In addition, one of the arguments of the
addition has to be the same as the second argument of the subtraction.&lt;/p&gt;
&lt;p&gt;The constants &lt;code class="docutils literal"&gt;MININT&lt;/code&gt;, &lt;code class="docutils literal"&gt;MAXINT&lt;/code&gt; and &lt;code class="docutils literal"&gt;LONG_BIT&lt;/code&gt; (which is either 32 or 64,
depending on which platform the JIT is built for) can be used in rules, they
behave like writing numbers but allow bit-width-independent formulations:&lt;/p&gt;
&lt;pre class="literal-block"&gt;is_true_and_minint: int_is_true(int_and(x, MININT))
    =&amp;gt; int_lt(x, 0)&lt;/pre&gt;
&lt;p&gt;It is also possible to have a pattern where some arguments needs to be a
constant, without specifying which constant. Those patterns look like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;sub_add_consts: int_sub(int_add(x, C1), C2) # incomplete
    # more goes here
    =&amp;gt; int_sub(x, C)&lt;/pre&gt;
&lt;p&gt;Variables in the pattern that start with a &lt;code class="docutils literal"&gt;C&lt;/code&gt; match against constants only.
However, in this current form the rule is incomplete, because the variable &lt;code class="docutils literal"&gt;C&lt;/code&gt;
that is being used in the target operation is not defined anywhere. We will see
how to compute it in the next section.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="computing-constants-and-other-intermediate-results"&gt;
&lt;h3&gt;Computing constants and other intermediate results&lt;/h3&gt;
&lt;p&gt;Sometimes it is necessary to compute intermediate results that are used in the
target operation. To do that, there can be extra assignments between the rule head
and the rule target.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;sub_add_consts: int_sub(int_add(x, C1), C2) # incomplete
    C = C1 + C2
    =&amp;gt; int_sub(x, C)&lt;/pre&gt;
&lt;p&gt;The right hand side of such an assignment is a subset of Python syntax,
supporting arithmetic using &lt;code class="docutils literal"&gt;+&lt;/code&gt;, &lt;code class="docutils literal"&gt;-&lt;/code&gt;, &lt;code class="docutils literal"&gt;*&lt;/code&gt;, and certain helper functions.
However, the syntax allows you to be explicit about unsignedness for some
operations. E.g. &lt;code class="docutils literal"&gt;&amp;gt;&amp;gt;u&lt;/code&gt; exists for unsigned right shifts (and I plan to add
&lt;code class="docutils literal"&gt;&amp;gt;u&lt;/code&gt;, &lt;code class="docutils literal"&gt;&amp;gt;=u&lt;/code&gt;, &lt;code class="docutils literal"&gt;&amp;lt;u&lt;/code&gt;, &lt;code class="docutils literal"&gt;&amp;lt;=u&lt;/code&gt; for comparisons).&lt;/p&gt;
&lt;p&gt;Here's an example of a rule that uses &lt;code class="docutils literal"&gt;&amp;gt;&amp;gt;u&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;urshift_lshift_x_c_c: uint_rshift(int_lshift(x, C), C)
    mask = (-1 &amp;lt;&amp;lt; C) &amp;gt;&amp;gt;u C
    =&amp;gt; int_and(x, mask)&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="checks"&gt;
&lt;h3&gt;Checks&lt;/h3&gt;
&lt;p&gt;Some rewrites are only true under certain conditions. For example,
&lt;code class="docutils literal"&gt;int_eq(x, 1)&lt;/code&gt; can be rewritten to &lt;code class="docutils literal"&gt;x&lt;/code&gt;, if &lt;code class="docutils literal"&gt;x&lt;/code&gt; is known to store a boolean value. This can
be expressed with &lt;em&gt;checks&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;eq_one: int_eq(x, 1)
    check x.is_bool()
    =&amp;gt; x&lt;/pre&gt;
&lt;p&gt;A check is followed by a boolean expression. The variables from the pattern can
be used as &lt;code class="docutils literal"&gt;IntBound&lt;/code&gt; instances in checks (and also in assignments) to find out
what the abstract interpretation of the JIT knows about the value of a trace variable
(&lt;code class="docutils literal"&gt;IntBound&lt;/code&gt; is the name of the abstract domain that the JIT uses for integers,
despite the fact that it also stores &lt;a class="reference external" href="https://www.pypy.org/posts/2024/08/toy-knownbits.html"&gt;knownbits&lt;/a&gt; information nowadays).&lt;/p&gt;
&lt;p&gt;Here's another example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;mul_lshift: int_mul(x, int_lshift(1, y))
    check y.known_ge_const(0) and y.known_le_const(LONG_BIT)
    =&amp;gt; int_lshift(x, y)&lt;/pre&gt;
&lt;p&gt;It expresses that &lt;code class="docutils literal"&gt;x * (1 &amp;lt;&amp;lt; y)&lt;/code&gt; can be rewritten to &lt;code class="docutils literal"&gt;x &amp;lt;&amp;lt; y&lt;/code&gt; but checks that
&lt;code class="docutils literal"&gt;y&lt;/code&gt; is known to be between &lt;code class="docutils literal"&gt;0&lt;/code&gt; and &lt;code class="docutils literal"&gt;LONG_BIT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Checks and assignments can be repeated and combined with each other:&lt;/p&gt;
&lt;pre class="literal-block"&gt;mul_pow2_const: int_mul(x, C)
    check C &amp;gt; 0 and C &amp;amp; (C - 1) == 0
    shift = highest_bit(C)
    =&amp;gt; int_lshift(x, shift)&lt;/pre&gt;
&lt;p&gt;In addition to calling methods on &lt;code class="docutils literal"&gt;IntBound&lt;/code&gt; instances, it's also possible to
access their attributes, like in this rule:&lt;/p&gt;
&lt;pre class="literal-block"&gt;and_x_c_in_range: int_and(x, C)
    check x.lower &amp;gt;= 0 and x.upper &amp;lt;= C &amp;amp; ~(C + 1)
    =&amp;gt; x&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="rule-ordering-and-liveness"&gt;
&lt;h3&gt;Rule Ordering and Liveness&lt;/h3&gt;
&lt;p&gt;The generated optimizer code will give preference to applying rules that
produce a constant or a variable as a rewrite result. Only if none of those
match do rules that produce new result operations get applied. For example, the
rules &lt;code class="docutils literal"&gt;sub_x_x&lt;/code&gt; and &lt;code class="docutils literal"&gt;sub_add&lt;/code&gt; are tried before trying &lt;code class="docutils literal"&gt;sub_add_consts&lt;/code&gt;,
because the former two rules optimize to a constant and a variable
respectively, while the latter produces a new operation as the result.&lt;/p&gt;
&lt;p&gt;The rule &lt;code class="docutils literal"&gt;sub_add_consts&lt;/code&gt; has a possible problem, which is that if the
intermediate result of the &lt;code class="docutils literal"&gt;int_add&lt;/code&gt; operation in the rule head is used by
some other operations, then the &lt;code class="docutils literal"&gt;sub_add_consts&lt;/code&gt; rule does not actually
reduce the number of operations (and might actually make things slightly worse
due to increased register pressure). However, currently it would be extremely
hard to take that kind of information into account in the optimization pass of
the JIT, so we optimistically apply the rules anyway.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="checking-rule-coverage"&gt;
&lt;h3&gt;Checking rule coverage&lt;/h3&gt;
&lt;p&gt;Every rewrite rule should have at least one unit test where it triggers. To
ensure this, the &lt;a class="reference external" href="https://github.com/pypy/pypy/blob/d92d0bfd38318ede1cbaadadafd77da69d431fad/rpython/jit/metainterp/optimizeopt/test/test_optimizeintbound.py"&gt;unit test file that mainly checks integer optimizations&lt;/a&gt; in the
JIT has an assert at the end of a test run, that every rule fired at least once.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="printing-rule-statistics"&gt;
&lt;h3&gt;Printing rule statistics&lt;/h3&gt;
&lt;p&gt;The JIT can print statistics about which rule fired how often in the
&lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;jit-intbounds-stats&lt;/span&gt;&lt;/code&gt; logging category, using the &lt;a class="reference external" href="https://rpython.readthedocs.io/en/latest/logging.html"&gt;PYPYLOG&lt;/a&gt; mechanism. For
example, to print the category to stdout at the end of program execution, run
PyPy like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;PYPYLOG=jit-intbounds-stats:- pypy ...&lt;/pre&gt;
&lt;p&gt;The output of that will look something like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;int_add
    add_reassoc_consts 2514
    add_zero 107008
int_sub
    sub_zero 31519
    sub_from_zero 523
    sub_x_x 3153
    sub_add_consts 159
    sub_add 55
    sub_sub_x_c_c 1752
    sub_sub_c_x_c 0
    sub_xor_x_y_y 0
    sub_or_x_y_y 0
int_mul
    mul_zero 0
    mul_one 110
    mul_minus_one 0
    mul_pow2_const 1456
    mul_lshift 0
...&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="termination-and-confluence"&gt;
&lt;h3&gt;Termination and Confluence&lt;/h3&gt;
&lt;p&gt;Right now there are unfortunately no checks that the rules actually rewrite
operations towards "simpler" forms. There is no cost model, and also nothing
that prevents you from writing a rule like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;neg_complication: int_neg(x) # leads to infinite rewrites
    =&amp;gt; int_mul(-1, x)&lt;/pre&gt;
&lt;p&gt;Doing this would lead to endless rewrites if there is also another rule that
turns multiplication with -1 into negation.&lt;/p&gt;
&lt;p&gt;There is also no checking for &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)"&gt;confluence&lt;/a&gt; (yet?), i.e. the property that all
rewrites starting from the same input trace always lead to the same output
trace, no matter in which order the rules are applied.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="proofs"&gt;
&lt;h3&gt;Proofs&lt;/h3&gt;
&lt;p&gt;It is very easy to write a peephole rule that is not correct in all corner
cases. Therefore all the rules are proven correct with Z3 before compiled into
actual JIT code, by default. When the proof fails, a (hopefully minimal)
counterexample is printed. The counterexample consists of values for all the
inputs that fulfil the checks, values for the intermediate expressions, and
then two &lt;em&gt;different&lt;/em&gt; values for the source and the target operations.&lt;/p&gt;
&lt;p&gt;E.g. if we try to add the incorrect rule:&lt;/p&gt;
&lt;pre class="literal-block"&gt;mul_is_add: int_mul(a, b)
    =&amp;gt; int_add(a, b)&lt;/pre&gt;
&lt;p&gt;We get the following counterexample as output:&lt;/p&gt;
&lt;pre class="literal-block"&gt;Could not prove correctness of rule 'mul_is_add'
in line 1
counterexample given by Z3:
counterexample values:
a: 0
b: 1
operation int_mul(a, b) with Z3 formula a*b
has counterexample result vale: 0
BUT
target expression: int_add(a, b) with Z3 formula a + b
has counterexample value: 1&lt;/pre&gt;
&lt;p&gt;If we add conditions, they are taken into account and the counterexample will
fulfil the conditions:&lt;/p&gt;
&lt;pre class="literal-block"&gt;mul_is_add: int_mul(a, b)
    check a.known_gt_const(1) and b.known_gt_const(2)
    =&amp;gt; int_add(a, b)&lt;/pre&gt;
&lt;p&gt;This leads to the following counterexample:&lt;/p&gt;
&lt;pre class="literal-block"&gt;Could not prove correctness of rule 'mul_is_add'
in line 46
counterexample given by Z3:
counterexample values:
a: 2
b: 3
operation int_mul(a, b) with Z3 formula a*b
has counterexample result vale: 6
BUT
target expression: int_add(a, b) with Z3 formula a + b
has counterexample value: 5&lt;/pre&gt;
&lt;p&gt;Some &lt;code class="docutils literal"&gt;IntBound&lt;/code&gt; methods cannot be used in Z3 proofs because their &lt;a class="reference external" href="https://www.pypy.org/posts/2024/08/toy-knownbits.html#cases-where-this-style-of-z3-proof-doesnt-work)."&gt;control
flow is too complex&lt;/a&gt;. If that is the case, they can have Z3-equivalent
formulations defined (in every case this is done, it's a potential proof hole if
the Z3 friendly reformulation and the real implementation differ from each
other, therefore extra care is required to make very sure they are equivalent).&lt;/p&gt;
&lt;p&gt;It's possible to skip the proof of individual rules entirely by adding
&lt;code class="docutils literal"&gt;SORRY_Z3&lt;/code&gt; to its body (but we should try not to do that too often):&lt;/p&gt;
&lt;pre class="literal-block"&gt;eq_different_knownbits: int_eq(x, y)
    SORRY_Z3
    check x.known_ne(y)
    =&amp;gt; 0&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="checking-for-satisfiability"&gt;
&lt;h3&gt;Checking for satisfiability&lt;/h3&gt;
&lt;p&gt;In addition to checking whether the rule yields a correct optimization, we also
check whether the rule can ever apply. This ensures that there are &lt;em&gt;some&lt;/em&gt;
runtime values that would fulfil all the checks in a rule. Here's an example of
a rule violating this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;never_applies: int_is_true(x)
    check x.known_lt_const(0) and x.known_gt_const(0) # impossible condition, always False
    =&amp;gt; x&lt;/pre&gt;
&lt;p&gt;Right now the error messages if this goes wrong are not completely easy to
understand. I hope to be able to improve this later:&lt;/p&gt;
&lt;pre class="literal-block"&gt;Rule 'never_applies' cannot ever apply
in line 1
Z3 did not manage to find values for variables x such that the following condition becomes True:
And(x &amp;lt;= x_upper,
    x_lower &amp;lt;= x,
    If(x_upper &amp;lt; 0, x_lower &amp;gt; 0, x_upper &amp;lt; 0))&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="implementation-notes"&gt;
&lt;h3&gt;Implementation Notes&lt;/h3&gt;
&lt;p&gt;The implementation of the DSL is done in a relatively ad-hoc manner. It is
parsed using &lt;a class="reference external" href="https://rply.readthedocs.io/"&gt;rply&lt;/a&gt;, there's a small type checker that tries to find common
problems in how the rules are written. Z3 is used via the Python API, like in
the previous blog posts that are using it. The
pattern matching RPython code is generated using an approach inspired by Luc
Maranget's paper &lt;a class="reference external" href="http://moscova.inria.fr/~maranget/papers/ml05e-maranget.pdf"&gt;Compiling Pattern Matching to Good Decision Trees&lt;/a&gt;. See
&lt;a class="reference external" href="https://compiler.club/compiling-pattern-matching/"&gt;this blog post&lt;/a&gt; for an approachable introduction.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Now that I've described the DSL, here are the rules that are equivalent to the
imperative code in the motivation section:&lt;/p&gt;
&lt;pre class="literal-block"&gt;mul_zero: int_mul(x, 0)
    =&amp;gt; 0

mul_one: int_mul(x, 1)
    =&amp;gt; x

mul_minus_one: int_mul(x, -1)
    =&amp;gt; int_neg(x)

mul_pow2_const: int_mul(x, C)
    check C &amp;gt; 0 and C &amp;amp; (C - 1) == 0
    shift = highest_bit(C)
    =&amp;gt; int_lshift(x, shift)

mul_lshift: int_mul(x, int_lshift(1, y))
    check y.known_ge_const(0) and y.known_le_const(LONG_BIT)
    =&amp;gt; int_lshift(x, y)&lt;/pre&gt;
&lt;p&gt;The current status of the DSL is that it got merged to PyPy's main branch. I
rewrote a part of the integer rewrites &lt;a class="reference external" href="https://github.com/pypy/pypy/blob/d92d0bfd38318ede1cbaadadafd77da69d431fad/rpython/jit/metainterp/ruleopt/real.rules"&gt;into the DSL&lt;/a&gt;, but some are still in the
old imperative style (mostly for complicated reasons, the easily ported ones are
all done). Since I've only been porting optimizations that had existed prior to
the existence of the DSL, performance numbers of benchmarks didn't change.&lt;/p&gt;
&lt;p&gt;There are a number of features that are still missing and some possible
extensions that I plan to work on in the future:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;All the integer operations that the DSL handles so far are the variants that
do not check for overflow (or where overflow was proven to be impossible to
happen). In regular Python code the overflow-checking variants &lt;cite&gt;int_add_ovf&lt;/cite&gt;
etc are much more common, but the DSL doesn't support them yet. I plan to fix
this, but don't completely understand how the correctness proofs for them
should be done correctly.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A related problem is that I don't understand what it means for a rewrite to be
correct if some of the operations are only defined for a subset of the input
values. E.g. division isn't defined if the divisor is zero. In theory, a
division operation in the trace should always be preceded by a check that the
divisor isn't zero. But sometimes other optimization move the check around and
the connection to the division gets lost or muddled. What optimizations can we
still safely perform on the division? There's lots of prior work on this
question, but I still don't understand what the correct approach in our
context would be.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ordering comparisons like &lt;code class="docutils literal"&gt;int_lt&lt;/code&gt;, &lt;code class="docutils literal"&gt;int_le&lt;/code&gt; and their unsigned variants are
not ported to the DSL yet. Comparisons are an area where the JIT is not super
good yet at optimizing away operations. This is a pretty big topic and I've
started a project with Nico Rittinghaus to try to improve the situation a bit
more generally.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A more advanced direction of work would be to implement a simplified form of
&lt;a class="reference external" href="https://egraphs-good.github.io/"&gt;e-graphs&lt;/a&gt; (or &lt;a class="reference external" href="https://vimeo.com/843540328"&gt;ae-graphs&lt;/a&gt;). The JIT has like half of an e-graph data
structure already, and we probably can't afford a full one in terms of compile
time costs, but maybe we can have two thirds or something?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="acknowledgements"&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thank you to &lt;a class="reference external" href="https://bernsteinbear.com/"&gt;Max Bernstein&lt;/a&gt; and &lt;a class="reference external" href="https://martinfriedrichberger.net/"&gt;Martin Berger&lt;/a&gt; for super helpful feedback on
drafts of the post!&lt;/p&gt;
&lt;/section&gt;</description><category>jit</category><category>z3</category><guid>https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html</guid><pubDate>Wed, 23 Oct 2024 15:00:00 GMT</pubDate></item><item><title>Mining JIT traces for missing optimizations with Z3</title><link>https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html</link><dc:creator>CF Bolz-Tereick</dc:creator><description>&lt;p&gt;In my last post I've described &lt;a href="https://www.pypy.org/posts/2024/07/finding-simple-rewrite-rules-jit-z3.html"&gt;how to use Z3 to find simple local peephole
optimization patterns&lt;/a&gt;
for the integer operations in PyPy's JIT. An example is &lt;code&gt;int_and(x, 0) -&amp;gt;
0&lt;/code&gt;. In this post I want to scale up the problem of identifying possible
optimizations to much bigger instruction sequences, also using Z3. For that, I
am starting with the JIT traces of &lt;strong&gt;real benchmarks&lt;/strong&gt;, after they have been
optimized by the optimizer of PyPy's JIT. Then we can ask Z3 to find
inefficient integer operations in those traces.&lt;/p&gt;
&lt;p&gt;Starting from the optimized traces of real programs has some big
advantages over the "classical" superoptimization approach of generating and
then trying all possible sequences of instructions. It avoids the
combinatorial explosion that happens with the latter approach. Also, starting
from the traces of benchmarks or (even better) actual programs makes sure that
we actually care about the missing optimizations
that are found in this way. And because the traces are analyzed after they have
been optimized by PyPy's optimizer, we only get reports for &lt;em&gt;missing&lt;/em&gt;
optimizations, that the JIT isn't able to do (yet).&lt;/p&gt;
&lt;p&gt;The techniques and experiments I describe in this post are again the result of
a bunch of discussions with John Regehr at a conference a few weeks ago, as
well as reading his blog posts and papers. Thanks John! Also thanks to &lt;a href="https://bernsteinbear.com/"&gt;Max
Bernstein&lt;/a&gt; for super helpful feedback on the drafts
of this blog post (and for poking me to write things in general).&lt;/p&gt;
&lt;h3 id="high-level-approach"&gt;High-Level Approach&lt;/h3&gt;
&lt;p&gt;The approach that I took works as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Run benchmarks or other interesting programs and then dump the IR of the JIT
  traces into a file. The traces have at that point been already optimized by
  the PyPy JIT's optimizer.&lt;/li&gt;
&lt;li&gt;For every trace, ignore all the operations on non-integer variables.&lt;/li&gt;
&lt;li&gt;Translate every integer operation into a Z3 formula.&lt;/li&gt;
&lt;li&gt;For every operation, use Z3 to find out whether the operation is redundant
  (how that is done is described below).&lt;/li&gt;
&lt;li&gt;If the operation is redundant, the trace is less efficient than it could have
  been, because the optimizer could also have removed the operation. Report the
  inefficiency.&lt;/li&gt;
&lt;li&gt;Minimize the inefficient programs by removing as many operations as possible
  to make the problem easier to understand.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the post I will describe the details and show some pseudocode of the
approach. I'll also make the proper code public eventually (but it needs a
healthy dose of cleanups first).&lt;/p&gt;
&lt;h3 id="dumping-pypy-traces"&gt;Dumping PyPy Traces&lt;/h3&gt;
&lt;p&gt;PyPy will write its JIT traces into the file &lt;code&gt;out&lt;/code&gt; if the environment variable
&lt;a href="https://doc.pypy.org/en/latest/man/pypy.1.html"&gt;&lt;code&gt;PYPYLOG&lt;/code&gt;&lt;/a&gt; is set as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;PYPYLOG=jit-log-opt:out pypy &amp;lt;program.py&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This environment variable works for PyPy, but also for other virtual machines
built with RPython.&lt;/p&gt;
&lt;p&gt;(This is really a side point for the rest of the blog post, but since the
question came up I wanted to clarify it: Operations on integers in the Python
program that the JIT is running don't all correspond 1-to-1 with the &lt;code&gt;int_...&lt;/code&gt;
operations in the traces. The &lt;code&gt;int_...&lt;/code&gt; trace operations always operate on
machine words. The Python &lt;code&gt;int&lt;/code&gt; type supports arbitrarily large integers. PyPy
will optimistically try to lower the operations on Python integers into machine
word operations, but adds the necessary guards into the trace to make sure that
overflow outside of the range of machine words is caught. In case one of these
guards fails the interpreter switches to a big integer heap-allocated
representation.)&lt;/p&gt;
&lt;h3 id="encoding-traces-as-z3-formulas"&gt;Encoding Traces as Z3 formulas&lt;/h3&gt;
&lt;p&gt;The last blog post already contained the code to encode the results of
individual trace operations into Z3 formulas, so we don't need to repeat that
here. To encode traces of operations we introduce a Z3 variable for every
operation in the trace and then call the &lt;code&gt;z3_expression&lt;/code&gt; function for every
single one of the operations in the trace.&lt;/p&gt;
&lt;p&gt;For example, for the following trace:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;[i1]&lt;/span&gt;
&lt;span class="na"&gt;i2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;uint_rshift(i1, 32)&lt;/span&gt;
&lt;span class="na"&gt;i3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;int_and(i2, 65535)&lt;/span&gt;
&lt;span class="na"&gt;i4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;uint_rshift(i1, 48)&lt;/span&gt;
&lt;span class="na"&gt;i5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;int_lshift(i4, 16)&lt;/span&gt;
&lt;span class="na"&gt;i6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;int_or(i5, i3)&lt;/span&gt;
&lt;span class="na"&gt;jump(i6, i2) # equal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We would get the Z3 formula:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;z3.And(i2 == LShR(i1, 32),
       i3 == i2 &amp;amp; 65535,
       i4 == LShR(i1, 48),
       i5 == i4 &amp;lt;&amp;lt; 16)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Usually we won't ask for the formula of the whole trace at once. Instead we go
through the trace operation by operation and try to find inefficiencies in the
current one we are looking at. Roughly like this (pseudo-)code:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;newvar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;find_inefficiencies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;solver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Solver&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;var_to_z3var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;input_argument&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inputargs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;var_to_z3var&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;input_argument&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newz3var&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_argument&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;var_to_z3var&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3resultvar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newz3var&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resultvarname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;z3arg0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;var_to_z3var&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;z3arg1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;var_to_z3var&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;z3arg1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# checking for inefficiencies, see the next sections&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;"inefficient"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;

        &lt;span class="c1"&gt;# not inefficient, assert op into the solver and continue with the next op&lt;/span&gt;
        &lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3resultvar&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt; &lt;span class="c1"&gt;# no inefficiency found&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="identifying-constant-booleans-with-z3"&gt;Identifying constant booleans with Z3&lt;/h3&gt;
&lt;p&gt;To get started finding inefficiencies in a trace, we can
first focus on boolean variables. For every operation in the trace that
returns a bool we can ask Z3 to prove that this variable must be always True or
always False. Most of the time, neither of these proofs will succeed. But if Z3
manages to prove one of them, we know have found an ineffiency: instead of
computing the boolean result (eg by executing a comparison) the JIT's optimizer
could have replaced the operation with the corresponding boolean constant.&lt;/p&gt;
&lt;p&gt;Here's an example of an inefficiency found that way: if &lt;code&gt;x &amp;lt; y&lt;/code&gt; and &lt;code&gt;y &amp;lt; z&lt;/code&gt; are
both true, PyPy's JIT could conclude that &lt;code&gt;x &amp;lt; z&lt;/code&gt; must also
be true. However, currently the JIT cannot make that conclusion because it
only reasons about the concrete ranges (lower and upper bounds) for every
integer variable, but it has no way to remember anything about relationships
between different variables. This kind of reasoning would quite often be useful
to remove list/string bounds checks. Here's a &lt;a href="https://www.youtube.com/watch?app=desktop&amp;amp;v=1hm5ZVmBEvo"&gt;talk about how LLVM does
this&lt;/a&gt; (but it might be
too heavyweight for a JIT setting).&lt;/p&gt;
&lt;p&gt;Here are some more examples found that way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x - 1 == x&lt;/code&gt; is always False&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x - (x == -1) == -1&lt;/code&gt; is always False. The pattern &lt;code&gt;x - (x == -1)&lt;/code&gt; happens a
  lot in PyPy's hash computations: To be compatible with the CPython hashes we
  need to make sure that no object's hash is -1 (CPython uses -1 as an error
  value on the C level).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here's pseudo-code for how to implement checking boolean operations for
inefficiencies:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;find_inefficiencies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# check for boolean constant result&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_boolean_result&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;prove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;"inefficient"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;prove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;"inefficient"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="c1"&gt;# checking for other inefficiencies, see the next sections&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;

        &lt;span class="c1"&gt;# not inefficient, add op to the solver and continue with the next op&lt;/span&gt;
        &lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3resultvar&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt; &lt;span class="c1"&gt;# no inefficiency found&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="identifying-redundant-operations"&gt;Identifying redundant operations&lt;/h3&gt;
&lt;p&gt;A more interesting class of redundancy is to try to find two operations in a
trace that compute the same result. We can do that by asking Z3 to prove for
each pair of different operations in the trace to prove that the result is
always the same. If a previous operation returns the same result, the JIT could
have reused that result instead of re-computing it, saving time. Doing this
search for equivalent operations with Z3 is quadratic in the number of
operations, but since traces have a maximum length it is not too bad in
practice.&lt;/p&gt;
&lt;p&gt;This is the real workhorse of my script so far, it's what finds most of the
inefficiencies. Here's a few examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The very first and super useful example the script found is &lt;code&gt;int_eq(b, 1) ==
  b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is known to be a boolean (ie and integer 0 or 1). I have already
  implemented this optimization in the JIT.&lt;/li&gt;
&lt;li&gt;Similarly, &lt;code&gt;int_and(b, 1) == b&lt;/code&gt; for booleans.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(x &amp;lt;&amp;lt; 4) &amp;amp; -0xf == x &amp;lt;&amp;lt; 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;((x &amp;gt;&amp;gt; 63) &amp;lt;&amp;lt; 1) &amp;lt;&amp;lt; 2) &amp;gt;&amp;gt; 3 == x &amp;gt;&amp;gt; 63&lt;/code&gt;. In general the JIT is quite bad at
  optimizing repeated shifts (the infrastructure for doing better with that is
  already in place, so this will be a relatively easy fix).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(x &amp;amp; 0xffffffff) | ((x &amp;gt;&amp;gt; 32) &amp;lt;&amp;lt; 32) == x&lt;/code&gt;. Having the JIT optimize this
  would maybe require first recognizing that &lt;code&gt;(x &amp;gt;&amp;gt; 32) &amp;lt;&amp;lt; 32&lt;/code&gt; can be expressed
  as a mask: &lt;code&gt;(x &amp;amp; 0xffffffff00000000)&lt;/code&gt;, and then using &lt;code&gt;(x &amp;amp; c1) | (x &amp;amp; c2) ==
  x &amp;amp; (c1 | c2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A commonly occurring pattern is variations of this one:
  &lt;code&gt;((x &amp;amp; 1345) ^ 2048) - 2048 == x &amp;amp; 1345&lt;/code&gt; (with different constants, of
  course). xor is add without carry, and &lt;code&gt;x &amp;amp; 1345&lt;/code&gt; does not have the bit
  &lt;code&gt;2048&lt;/code&gt; set. Therefore the &lt;code&gt;^ 2048&lt;/code&gt; is equivalent to &lt;code&gt;+ 2048&lt;/code&gt;, which the &lt;code&gt;-
  2048&lt;/code&gt; cancels. More generally, if &lt;code&gt;a &amp;amp; b == 0&lt;/code&gt;, then &lt;code&gt;a + b == a | b == a ^ b&lt;/code&gt;.
  I don't understand at all why this appears so often in the traces, but I
  see variations of it a lot. LLVM can optimize this, but &lt;a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=115829"&gt;GCC
  can't&lt;/a&gt;, thanks to
  &lt;a href="https://hachyderm.io/@pinskia/112752641328799157"&gt;Andrew Pinski for filing the
  bug&lt;/a&gt;!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here's some implementation pseudo-code again:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;find_inefficiencies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# check for boolean constant result&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="c1"&gt;# searching for redundant operations&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;previous_op&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;previous_op&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="c1"&gt;# done, reached the current op&lt;/span&gt;
            &lt;span class="n"&gt;previous_op_z3var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;var_to_z3var&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;previous_op&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;prove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;previous_op_z3var&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;"inefficient"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;previous_op&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="c1"&gt;# more code here later&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;

        &lt;span class="c1"&gt;# not inefficient, add op to the solver and continue with the next op&lt;/span&gt;
        &lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3resultvar&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt; &lt;span class="c1"&gt;# no inefficiency found&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="synthesizing-more-complicated-constants-with-exists-forall"&gt;Synthesizing more complicated constants with exists-forall&lt;/h3&gt;
&lt;p&gt;To find out whether some integer operations always return a constant result, we
can't simply use the same trick as for those operations that return boolean
results, because enumerating 2â¶â´ possible constants and checking them all
would take too long. Like in the last post, we can use &lt;code&gt;z3.ForAll&lt;/code&gt; to find out
whether Z3 can synthesize a constant for the result of an operation for us.
If such a constant exists, the JIT could have removed the operation,
and replaced it with the constant that Z3 provides.&lt;/p&gt;
&lt;p&gt;Here a few examples of inefficiencies found this way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(x ^ 1) ^ x == 1&lt;/code&gt; (or, more generally: &lt;code&gt;(x ^ y) ^ x == y&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;if &lt;code&gt;x | y == 0&lt;/code&gt;, it follows that &lt;code&gt;x == 0&lt;/code&gt; and &lt;code&gt;y == 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;if &lt;code&gt;x != MAXINT&lt;/code&gt;, then &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Implementing this is actually slightly annoying. The &lt;code&gt;solver.add&lt;/code&gt; calls for
non-inefficient ops add assertions to the solver, which are now confusing the
&lt;code&gt;z3.ForAll&lt;/code&gt; query. We could remove all assertion from the solver, then do the
&lt;code&gt;ForAll&lt;/code&gt; query, then add the assertions back. What I ended doing instead was
instantiating a second solver object that I'm using for the &lt;code&gt;ForAll&lt;/code&gt; queries,
that remains empty the whole time.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;find_inefficiencies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;solver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Solver&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;empty_solver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Solver&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;var_to_z3var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# check for boolean constant result&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="c1"&gt;# searching for redundant operations&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="c1"&gt;# checking for constant results&lt;/span&gt;
        &lt;span class="n"&gt;constvar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'find_const'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ForAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;var_to_z3var&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
            &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Implies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assertions&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
                &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;empty_solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;empty_solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_signed_long&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;"inefficient"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;

        &lt;span class="c1"&gt;# not inefficient, add op to the solver and continue with the next op&lt;/span&gt;
        &lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3resultvar&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt; &lt;span class="c1"&gt;# no inefficiency found&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="minimization"&gt;Minimization&lt;/h3&gt;
&lt;p&gt;Analyzing an inefficiency by hand in the context of a larger trace is quite
tedious. Therefore I've implemented a (super inefficient) script to try to make
the examples smaller. Here's how that works:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First throw out all the operations that occur &lt;em&gt;after&lt;/em&gt; the inefficient operation
  in the trace.&lt;/li&gt;
&lt;li&gt;Then we remove all "dead" operations, ie operations that don't have their
  results used (all the operations that we can analyze with Z3 are without side
  effects).&lt;/li&gt;
&lt;li&gt;Now we try to remove every guard in the trace one by one and check
  afterwards, whether the resulting trace still has an inefficiency.&lt;/li&gt;
&lt;li&gt;We also try to replace every single operation with a new argument to the
  trace, to see whether the inefficiency is still present.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The minimization process is sort of inefficient and I should probably be using
 &lt;a href="https://github.com/DRMacIver/shrinkray"&gt;shrinkray&lt;/a&gt; or
 &lt;a href="https://github.com/csmith-project/creduce"&gt;C-Reduce&lt;/a&gt; instead. However, it
 seems to work well in practice and the runtime isn't too bad.&lt;/p&gt;
&lt;h3 id="results"&gt;Results&lt;/h3&gt;
&lt;p&gt;So far I am using the JIT traces of three programs: 1) Booting Linux on the
&lt;a href="https://docs.pydrofoil.org"&gt;Pydrofoil&lt;/a&gt; RISC-V emulator, 2) booting Linux on the Pydrofoil ARM emulator, and 3)
running the PyPy bootstrap process on top of PyPy.&lt;/p&gt;
&lt;p&gt;I picked these programs because most Python programs don't contain interesting
amounts of integer operations, and the traces of the emulators
contain a lot of them. I also used the bootstrap process because I still wanted
to try a big Python program and personally care about the runtime of this
program a lot.&lt;/p&gt;
&lt;p&gt;The script identifies 94
inefficiencies in the traces, a lot of them come from repeating
patterns. My next steps will be to manually inspect them all, categorize them, and
implement easy optimizations identified that way. I also want a way to sort the
examples by execution count in the benchmarks, to get a feeling for which of
them are most important.&lt;/p&gt;
&lt;p&gt;I didn't investigate the full set of &lt;a href="https://speed.pypy.org"&gt;Python
benchmarks&lt;/a&gt; that PyPy uses yet, because I don't expect
them to contain interesting amounts of integer operations, but maybe I am wrong
about that? Will have to try eventually.&lt;/p&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;This was again much easier to do than I would have expected! Given that I had
the translation of trace ops to Z3 already in place, it was a matter of about a
day's of programming to use this infrastructure to find the first problems and
minimizing them.&lt;/p&gt;
&lt;p&gt;Reusing the results of existing operations or replacing operations by constants
can be seen as "zero-instruction superoptimization". I'll probably be rather
busy for a while to add the missing optimizations identified by my simple
script. But later extensions to actually synthesize one or several operations
in the attempt to optimize the traces more and find more opportunities should
be possible.&lt;/p&gt;
&lt;p&gt;Finding inefficiencies in traces with Z3 is significantly less
annoying and also less error-prone than just manually inspecting traces and
trying to spot optimization opportunities.&lt;/p&gt;
&lt;h3 id="random-notes-and-sources"&gt;Random Notes and Sources&lt;/h3&gt;
&lt;p&gt;Again, John's blog posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.regehr.org/archives/1109"&gt;Letâs Work on an LLVM Superoptimizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.regehr.org/archives/1146"&gt;Early Superoptimizer Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.regehr.org/archives/1252"&gt;A Few Synthesizing Superoptimizer Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.regehr.org/archives/1636"&gt;Synthesizing Constants&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and papers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://arxiv.org/pdf/1711.04422"&gt;A Synthesizing Superoptimizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dl.acm.org/doi/pdf/10.1145/3649837"&gt;Hydra: Generalizing Peephole Optimizations with Program Synthesis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I remembered recently that I had seen the approach of optimizing the traces of
a tracing JIT with Z3 a long time ago, as part of the (now long dead, I think)
&lt;a href="https://web.archive.org/web/20160304055149/http://research.microsoft.com/en-us/projects/spur/"&gt;SPUR
project&lt;/a&gt;.
There's a &lt;a href="https://web.archive.org/web/20161029162737/http://csl.stanford.edu/~christos/pldi2010.fit/tillmann.provers4jit.pdf"&gt;workshop
paper&lt;/a&gt;
from 2010 about this. SPUR was trying to use Z3 built into the actual JIT (as
opposed to using Z3 only to find places where the regular optimizers could be
improved). In addition to bitvectors, SPUR also used the Z3 support for arrays
to model the C# heap and remove redundant stores. This is still another future
extension for all the Z3 work I've been doing in the context of the PyPy JIT.&lt;/p&gt;</description><category>jit</category><category>z3</category><guid>https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html</guid><pubDate>Fri, 19 Jul 2024 17:01:09 GMT</pubDate></item><item><title>Finding Simple Rewrite Rules for the JIT with Z3</title><link>https://www.pypy.org/posts/2024/07/finding-simple-rewrite-rules-jit-z3.html</link><dc:creator>CF Bolz-Tereick</dc:creator><description>&lt;p&gt;In June I was at the &lt;a href="https://pldi24.sigplan.org/"&gt;PLDI conference&lt;/a&gt; in
Copenhagen to present a &lt;a href="https://dl.acm.org/doi/10.1145/3652588.3663316"&gt;paper&lt;/a&gt;
I co-authored with &lt;a href="https://bernsteinbear.com/"&gt;Max Bernstein&lt;/a&gt;. I also finally
met &lt;a href="https://blog.regehr.org/"&gt;John Regehr&lt;/a&gt;, who I'd been talking on social
media for ages but had never met. John has been working on compiler correctness
and better techniques for building compilers and optimizers since a very long
time. The blog post &lt;a href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html"&gt;Finding JIT Optimizer Bugs using SMT Solvers and
Fuzzing&lt;/a&gt;
was heavily inspired by this work. We talked a lot about his and his groups
work on using Z3 for
&lt;a href="https://en.wikipedia.org/wiki/Superoptimization"&gt;superoptimization&lt;/a&gt; and for
finding missing optimizations. I have applied some of the things John told me
about to the traces of PyPy's JIT, and wanted to blog about that. However, my
draft felt quite hard to understand. Therefore I have now written this current
post, to at least try to provide a somewhat gentler on-ramp to the topic.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;this&lt;/em&gt; post we will use the Python-API to Z3 to find local peephole rewrite
rules for the operations in the intermediate representation of PyPy's tracing
JIT. The code for this is simple enough that we can go through all of it.&lt;/p&gt;
&lt;p&gt;The PyPy JIT produces traces of machine level instructions, which are optimized
and then turned into machine code. The optimizer uses a number of approaches to
make the traces more efficient. For integer operations it applies a number of
arithmetic simplification rules rules, for example &lt;code&gt;int_add(x, 0) -&amp;gt; x&lt;/code&gt;. When
implementing these rules in the JIT there are &lt;strong&gt;two problems&lt;/strong&gt;: How do we know
that the rules are correct? And how do we know that we haven't forgotten any
rules? We'll try to answer both of these, but the first one in particular.&lt;/p&gt;
&lt;p&gt;We'll be using Z3, a satisfiability module theories (SMT) solver which has good
bitvector support and most importantly an excellent Python API. We can use the
solver to reason about bitvectors, which are how we will model machine
integers.&lt;/p&gt;
&lt;p&gt;To find rewrite rules, we will consider the binary operations (i.e. those
taking two arguments) in PyPy traces that take and produce integers. The
completely general form &lt;code&gt;op(x, y)&lt;/code&gt; is not simplifiable on its own. But if
either &lt;code&gt;x == y&lt;/code&gt;
or if one of the arguments is a constant, we can potentially simplify the
operation into a simpler form. The results are either the variable &lt;code&gt;x&lt;/code&gt;, or a
(potentially different) constant. We'll ignore constant-folding where both
arguments of the binary operation are constants. The possible results for a
simplifiable binary operation are the variable &lt;code&gt;x&lt;/code&gt; or another constant. This
leaves the following patterns as possibilities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;op(x, x) == x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;op(x, x) == c1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;op(x, c1) == x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;op(c1, x) == x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;op(x, c1) == c2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;op(c1, x) == c2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our approach will be to take every single supported binary integer operation,
instantiate all of these patterns, and try to ask Z3 whether the resulting
simplification is valid for all values of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="quick-intro-to-the-z3-python-api"&gt;Quick intro to the Z3 Python-API&lt;/h3&gt;
&lt;p&gt;Here's a terminal session showing the use of the Z3 Python API:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; import z3&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; # construct a Z3 bitvector variable of width 8, with name x:&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; x = z3.BitVec('x', 8)&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; # construct a more complicated formula by using operator overloading:&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; x + x&lt;/span&gt;
&lt;span class="go"&gt;x + x&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; x + 1&lt;/span&gt;
&lt;span class="go"&gt;x + 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Z3 checks the "satisfiability" of a formula. This means that it tries to find
an example set of concrete values for the variables that occur in a formula,
such that the formula becomes true. Examples:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; solver = z3.Solver()&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; solver.check(x * x == 3)&lt;/span&gt;
&lt;span class="go"&gt;unsat&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; # meaning no x fulfils this property&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; solver.check(x * x == 9)&lt;/span&gt;
&lt;span class="go"&gt;sat&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; model = solver.model()&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; model&lt;/span&gt;
&lt;span class="go"&gt;[x = 253]&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; model[x].as_signed_long()&lt;/span&gt;
&lt;span class="go"&gt;-3&lt;/span&gt;
&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; # 253 is the same as -3 in two's complement arithmetic with 8 bits&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In order to use Z3 to prove something, we can ask Z3 to find counterexamples
for the statement, meaning concrete values that would make the negation of the
statement true:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; solver.check(z3.Not(x ^ -1 == ~x))&lt;/span&gt;
&lt;span class="go"&gt;unsat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The result &lt;code&gt;unsat&lt;/code&gt; means that we just proved that &lt;code&gt;x ^ -1 == ~x&lt;/code&gt; is true for
all &lt;code&gt;x&lt;/code&gt;, because there is no value for &lt;code&gt;x&lt;/code&gt; that makes &lt;code&gt;not (x ^ -1 == ~x)&lt;/code&gt;
true (this works because -1 has all the bits set).&lt;/p&gt;
&lt;p&gt;If we try to prove something incorrect in this way, the following happens:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; solver.check(z3.Not(x ^ -1 == x))&lt;/span&gt;
&lt;span class="go"&gt;sat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;sat&lt;/code&gt; shows that &lt;code&gt;x ^ -1 == x&lt;/code&gt; is (unsurprisingly) not always true, and we can
ask for a counterexample:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; solver.model()&lt;/span&gt;
&lt;span class="go"&gt;[x = 0]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This way of proving this works because the &lt;code&gt;check&lt;/code&gt; calls try to solve an
(implicit) "exists" quantifier, over all the Z3 variables used in the formula.
&lt;code&gt;check&lt;/code&gt; will either return &lt;code&gt;z3.unsat&lt;/code&gt;, which means that no concrete values make
the formula true; or &lt;code&gt;z3.sat&lt;/code&gt;, which means that you can get some concrete
values that make the formula true by calling &lt;code&gt;solver.model()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In math terms we prove things using &lt;code&gt;check&lt;/code&gt; by de-Morgan's rules for quantifiers:&lt;/p&gt;
&lt;p&gt;$$ \lnot \exists x: \lnot f(x) \implies \forall x: f(x) $$&lt;/p&gt;
&lt;p&gt;Now that we've seen the basics of using the Z3 API on a few small examples,
we'll use it in a bigger program.&lt;/p&gt;
&lt;h3 id="encoding-the-integer-operations-of-rpythons-jit-into-z3-formulas"&gt;Encoding the integer operations of RPython's JIT into Z3 formulas&lt;/h3&gt;
&lt;p&gt;Now we'll use the API to reason about the integer operations of the PyPy JIT
intermediate representation (IR). The binary integer operations are:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;opnames2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;span class="s2"&gt;"int_add"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_sub"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_mul"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_and"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_or"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_xor"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_eq"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_ne"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_lt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_le"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_gt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_ge"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"uint_lt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"uint_le"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"uint_gt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"uint_ge"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_lshift"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_rshift"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"uint_rshift"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"uint_mul_high"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_pydiv"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_pymod"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There's not much special about the integer operations. Like in LLVM, most of
them are signedness-independent: &lt;code&gt;int_add&lt;/code&gt;, &lt;code&gt;int_sub&lt;/code&gt;, &lt;code&gt;int_mul&lt;/code&gt;, ... work
correctly for unsigned integers but also for
&lt;a href="https://en.wikipedia.org/wiki/Two%27s_complement"&gt;two's-complement&lt;/a&gt; signed
integers. Exceptions for that are order comparisons like &lt;code&gt;int_lt&lt;/code&gt; etc. for
which we have unsigned variants &lt;code&gt;uint_lt&lt;/code&gt; etc. All operations that produce a
boolean result return a full-width integer &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; (the PyPy JIT supports
only word-sized integers in its intermediate representation)&lt;/p&gt;
&lt;p&gt;In order to reason about the IR operations, some ground work:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;z3&lt;/span&gt;

&lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;
&lt;span class="n"&gt;solver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Solver&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"timeout"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# milliseconds, ie 10s&lt;/span&gt;
&lt;span class="n"&gt;xvar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'x'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;constvar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'const'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;constvar2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'const2'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;TRUEBV&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVecVal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;FALSEBV&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVecVal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And here's the a function to turn an integer IR operation of PyPy's JIT into Z3
formulas:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;""" computes a tuple of (result, valid_if) of Z3 formulas. `result` is the&lt;/span&gt;
&lt;span class="sd"&gt;    formula representing the result of the operation, given argument formulas&lt;/span&gt;
&lt;span class="sd"&gt;    arg0 and arg1. `valid_if` is a pre-condition that must be true for the&lt;/span&gt;
&lt;span class="sd"&gt;    result to be meaningful. """&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
    &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt; &lt;span class="c1"&gt;# the precondition is mostly True, with few exceptions&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_add"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_sub"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_mul"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_and"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_or"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_xor"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_eq"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_ne"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_lt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_le"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_gt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_ge"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_lt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ULT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_le"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ULE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_gt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UGT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_ge"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UGE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_lshift"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
        &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_rshift"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
        &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_rshift"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LShR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_mul_high"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c1"&gt;# zero-extend args to 2*INTEGER_WIDTH bit, then multiply and extract&lt;/span&gt;
        &lt;span class="c1"&gt;# highest INTEGER_WIDTH bits&lt;/span&gt;
        &lt;span class="n"&gt;zarg0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ZeroExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;zarg1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ZeroExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Extract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;zarg0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;zarg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_pydiv"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
        &lt;span class="n"&gt;psubx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;If&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;psubx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;psubx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_pymod"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;If&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INTEGER_WIDTH&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_is_true"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_is_zero"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_neg"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_invert"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"unknown operation "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3expr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;""" helper function to turn a Z3 boolean result z3expr into a 1 or 0&lt;/span&gt;
&lt;span class="sd"&gt;    bitvector, using z3.If """&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;If&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TRUEBV&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We map the semantics of a PyPy JIT operation to Z3 with the &lt;code&gt;z3_expression&lt;/code&gt;
function. It takes the name of a JIT operation and its two (or one) arguments
into a pair of Z3 formulas, &lt;code&gt;result&lt;/code&gt; and &lt;code&gt;valid_if&lt;/code&gt;. The resulting formulas are
constructed with the operator overloading of Z3 variables/formulas.&lt;/p&gt;
&lt;p&gt;The first element &lt;code&gt;result&lt;/code&gt; of the result of &lt;code&gt;z3_expression&lt;/code&gt; represents the result
of performing the operation. &lt;code&gt;valid_if&lt;/code&gt; is a bool that represents a condition that
needs to be &lt;code&gt;True&lt;/code&gt; in order for the result of the operation to be defined. E.g.
&lt;code&gt;int_pydiv(a, b)&lt;/code&gt; is only valid if &lt;code&gt;b != 0&lt;/code&gt;. Most operations are always valid,
so they return &lt;code&gt;True&lt;/code&gt; as that condition (we'll ignore &lt;code&gt;valid_if&lt;/code&gt; for a bit, but it
will become more relevant further down in the post).&lt;/p&gt;
&lt;p&gt;We can define a helper function to prove things by finding counterexamples:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;prove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;""" Try to prove a condition cond by searching for counterexamples of its negation. """&lt;/span&gt;
    &lt;span class="n"&gt;z3res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Not&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;z3res&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unsat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;z3res&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unknown&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# eg on timeout&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;z3res&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"should be unreachable"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="finding-rewrite-rules"&gt;Finding rewrite rules&lt;/h3&gt;
&lt;p&gt;Now we can start finding our first rewrite rules, following the first pattern
&lt;code&gt;op(x, x) -&amp;gt; x&lt;/code&gt;. We do this by iterating over all the supported binary
operation names, getting the z3 expression for &lt;code&gt;op(x, x)&lt;/code&gt; and then asking Z3 to
prove &lt;code&gt;op(x, x) == x&lt;/code&gt;.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;opnames2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;prove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(x, x) -&amp;gt; x, &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This yields the simplifications:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;int_and&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_or&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="synthesizing-constants"&gt;Synthesizing constants&lt;/h3&gt;
&lt;p&gt;Supporting the next patterns is harder: &lt;code&gt;op(x, x) == c1&lt;/code&gt;, &lt;code&gt;op(x, c1) == x&lt;/code&gt;, and
&lt;code&gt;op(c1, x) == x&lt;/code&gt;. We don't know which constants to pick to try to get Z3 to
prove the equality. We could iterate over common constants like &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;,
&lt;code&gt;MAXINT&lt;/code&gt;, etc, or even over all the 256 values for a bitvector of length 8.
However, we will instead ask Z3 to find the constants for us too.&lt;/p&gt;
&lt;p&gt;This can be done by using quantifiers, in this case &lt;code&gt;z3.ForAll&lt;/code&gt;. The query we
pose to Z3 is "does there exist a constant &lt;code&gt;c1&lt;/code&gt; such that for all &lt;code&gt;x&lt;/code&gt; the
following is true: &lt;code&gt;op(x, c1) == x&lt;/code&gt;? Note that the constant &lt;code&gt;c1&lt;/code&gt; is not
necessarily unique, there could be many of them. We generate several matching
constant, and add that they must be different to the condition of the second
and further queries.&lt;/p&gt;
&lt;p&gt;We can express this in a helper function:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;find_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number_of_results&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ForAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
        &lt;span class="n"&gt;z3expr&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number_of_results&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;checkres&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;checkres&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# if a solver check succeeds, we can ask for a model, which is&lt;/span&gt;
            &lt;span class="c1"&gt;# concrete values for the variables constvar&lt;/span&gt;
            &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_signed_long&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;
            &lt;span class="c1"&gt;# make sure we don't generate the same constant again on the&lt;/span&gt;
            &lt;span class="c1"&gt;# next call&lt;/span&gt;
            &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;constvar&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# no (more) constants found&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can use this new function for the three mentioned patterns:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# try to find constants for op(x, x) == c&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;opnames2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;find_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(x, x) -&amp;gt; &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# try to find constants for op(x, c) == x and op(c, x) == x&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;opnames2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;find_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(x, &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;) -&amp;gt; x"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;find_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;, x) -&amp;gt; x"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# this code is not quite correct, we'll correct it later&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Together this yields the following new simplifications:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="cp"&gt;# careful, these are not all correct!&lt;/span&gt;
&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_xor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_eq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_ne&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;uint_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;uint_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;uint_rshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_pymod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_and&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_and&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_or&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_or&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_xor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_xor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_lshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_rshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;uint_rshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_pydiv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_pymod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Most of these look good at first glance, but the last one reveals a problem:
we've been ignoring the &lt;code&gt;valid_if&lt;/code&gt; expression up to now. We can stop doing that by
changing the code like this, which adds &lt;code&gt;z3.And(valid_if, ...)&lt;/code&gt; to the argument of
the calls to &lt;code&gt;find_constant&lt;/code&gt;:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# try to find constants for op(x, x) == c, op(x, c) == x and op(c, x) == x&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;opnames2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;find_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid_if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(x, x) -&amp;gt; &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# try to find constants for op(x, c) == x and op(c, x) == x&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;opnames2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;find_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(x, &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;) -&amp;gt; x"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;find_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;, x) -&amp;gt; x"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And we get this list instead:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_xor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_eq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_ne&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;uint_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;uint_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_and&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_and&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_or&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_or&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_xor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_xor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_lshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_rshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;uint_rshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;int_pydiv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="synthesizing-two-constants"&gt;Synthesizing two constants&lt;/h3&gt;
&lt;p&gt;For the patterns &lt;code&gt;op(x, c1) == c2&lt;/code&gt; and &lt;code&gt;op(c1, x) == c2&lt;/code&gt; we need to synthesize
two constants. We can again write a helper method for that:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;find_2consts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number_of_results&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ForAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
        &lt;span class="n"&gt;z3expr&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number_of_results&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;checkres&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;checkres&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_signed_long&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;const2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;constvar2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_signed_long&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const2&lt;/span&gt;
            &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Or&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;constvar&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constvar2&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;const2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And then use it like this:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;opnames2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# try to find constants c1, c2 such that op(c1, x) -&amp;gt; c2&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;consts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_2consts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid_if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;constvar2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const2&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;, x) -&amp;gt; &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const2&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# try to find constants c1, c2 such that op(x, c1) -&amp;gt; c2&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;consts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_2consts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid_if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;constvar2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const2&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;(x, &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;) -&amp;gt; &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Which yields some straightforward simplifications:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;int_mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_and&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_and&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;uint_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_lshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_rshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_rshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_mul_high&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_mul_high&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_mul_high&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_mul_high&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_pymod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_pymod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A few require a bit more thinking:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;int_or&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_or&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The are true because in two's complement, &lt;code&gt;-1&lt;/code&gt; has all bits set.&lt;/p&gt;
&lt;p&gt;The following ones require recognizing that &lt;code&gt;-9223372036854775808 == -2**63&lt;/code&gt; is
the most negative signed 64-bit integer, and &lt;code&gt;9223372036854775807 == 2 ** 63 -
1&lt;/code&gt; is the most positive one:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9223372036854775807&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9223372036854775808&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9223372036854775808&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9223372036854775807&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9223372036854775808&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9223372036854775807&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;int_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9223372036854775807&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;int_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9223372036854775808&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The following ones are true because the bitpattern for &lt;code&gt;-1&lt;/code&gt; is the largest
unsigned number:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;uint_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;uint_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;uint_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="strength-reductions"&gt;Strength Reductions&lt;/h3&gt;
&lt;p&gt;All the patterns so far only had a variable or a constant on the target of the
rewrite. We can also use the machinery to do strengh-reductions where we
generate a single-argument operation &lt;code&gt;op1(x)&lt;/code&gt; for input operations &lt;code&gt;op(x, c1)&lt;/code&gt;
or &lt;code&gt;op(c1, x)&lt;/code&gt;. To achieve this, we try all combinations of binary and unary
operations. (We won't consider strength reductions where a binary operation
gets turned into a "cheaper" other binary operation here.)&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;opnames1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;span class="s2"&gt;"int_is_true"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_is_zero"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_neg"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="s2"&gt;"int_invert"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;opnames2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;opname1&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;opnames1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# try to find a constant op(x, c) == g(x)&lt;/span&gt;
        &lt;span class="n"&gt;result1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;consts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid_if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;result1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(x, &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;) -&amp;gt; &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname1&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(x)"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# try to find a constant op(c, x) == g(x)&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;result1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3_expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opname1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xvar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;consts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;And&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid_if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valid_if1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;result1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;, x) -&amp;gt; &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;opname1&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;(x)"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Which yields the following new simplifications:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_neg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_invert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_neg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_neg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_xor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_invert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_xor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_invert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_eq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_zero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_eq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_zero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_ne&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_ne&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uint_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uint_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_zero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uint_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uint_le&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_zero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uint_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uint_gt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_zero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uint_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uint_ge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_is_zero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;int_pydiv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_neg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="conclusions"&gt;Conclusions&lt;/h3&gt;
&lt;p&gt;With not very little code we managed to generate a whole lot of local
simplifications for integer operations in the IR of PyPy's JIT. The rules
discovered that way are "simple", in the sense that they only require looking
at a single instruction, and not where the arguments of that instruction came
from. They also don't require any knowledge about the properties of the
arguments of the instructions (e.g. that they are positive).&lt;/p&gt;
&lt;p&gt;The rewrites in this post have mostly been in PyPy's JIT already. But now we
mechanically confirmed that they are correct. I've also added the remaining
useful looking ones, in particular &lt;code&gt;int_eq(x, 0) -&amp;gt; int_is_zero(x)&lt;/code&gt; etc.&lt;/p&gt;
&lt;p&gt;If we wanted to scale this approach up, we would have to work much harder!
There are a bunch of problems that come with generalizing the approach to
looking at sequences of instructions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Combinatorial explosion: if we look at sequences of instructions, we very
  quickly get a combinatorial explosion and it becomes untractable to try all
  combinations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finding non-minimal patterns: Some complicated simplifications can be
  instances of simpler ones. For example, because &lt;code&gt;int_add(x, 0) -&amp;gt; x&lt;/code&gt;, it's
  also true that &lt;code&gt;int_add(int_sub(x, y), 0) -&amp;gt; int_sub(x, y)&lt;/code&gt;. If we simply
  generate all possible sequences, we will find the latter simplification rule,
  which we would usually not care about.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Unclear usefulness: if we simply generate all rewrites up to a certain number
  of instructions, we will get a lot of patterns that are useless in the sense
  that they typically aren't found in realistic programs. It would be much
  better to somehow focus on the patterns that real benchmarks are using.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the &lt;a href="https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html"&gt;next blog post&lt;/a&gt; I'll discuss an alternative approach to simply generating
all possible sequences of instructions, that tries to address these problems.
This works by analyzing the real traces of benchmarks and mining those for
inefficiencies, which only shows problems that occur in actual programs.&lt;/p&gt;
&lt;h3 id="sources"&gt;Sources&lt;/h3&gt;
&lt;p&gt;I've been re-reading a lot of blog posts from John's blog:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.regehr.org/archives/1109"&gt;Letâs Work on an LLVM Superoptimizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.regehr.org/archives/1146"&gt;Early Superoptimizer Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.regehr.org/archives/1252"&gt;A Few Synthesizing Superoptimizer Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.regehr.org/archives/1636"&gt;Synthesizing Constants&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;but also papers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://arxiv.org/pdf/1711.04422"&gt;A Synthesizing Superoptimizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dl.acm.org/doi/pdf/10.1145/3649837"&gt;Hydra: Generalizing Peephole Optimizations with Program Synthesis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another of my favorite blogs has been &lt;a href="https://www.philipzucker.com/"&gt;Philipp Zucker's
blog&lt;/a&gt; in the last year or two, lots of excellent
posts about/using Z3 on there.&lt;/p&gt;</description><category>jit</category><category>z3</category><guid>https://www.pypy.org/posts/2024/07/finding-simple-rewrite-rules-jit-z3.html</guid><pubDate>Fri, 12 Jul 2024 19:14:09 GMT</pubDate></item><item><title>Finding JIT Optimizer Bugs using SMT Solvers and Fuzzing</title><link>https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html</link><dc:creator>CF Bolz-Tereick</dc:creator><description>&lt;p&gt;In this blog post I want to describe a recent bug finding technique that I've
added to the PyPy JIT testing infrastructure. This technique uses the Z3
theorem prover to find bugs in the optimizer of PyPy's JIT, in particular its
integer operation optimizations. The approach is
based on things I have learned from &lt;a class="reference external" href="https://www.cs.utah.edu/~regehr/"&gt;John Regehr's&lt;/a&gt; &lt;a class="reference external" href="https://blog.regehr.org/"&gt;blog&lt;/a&gt; (&lt;a class="reference external" href="https://blog.regehr.org/archives/1122"&gt;this post&lt;/a&gt; is a
good first one to read), &lt;a class="reference external" href="https://twitter.com/johnregehr/"&gt;Twitter&lt;/a&gt;, and on
his (et al) paper &lt;a class="reference external" href="https://www.cs.utah.edu/~regehr/alive2-pldi21.pdf"&gt;Alive2: Bounded Translation Validation for LLVM&lt;/a&gt;. The work
was triggered by a recent miscompilation bug my current bachelor student Nico
Rittinghaus found.&lt;/p&gt;
&lt;section id="background-python-integers-in-the-pypy-jit"&gt;
&lt;h2&gt;Background: Python Integers in the PyPy JIT&lt;/h2&gt;
&lt;p&gt;The optimizer of PyPy's JITs operates on traces, which are linear sequences of
instructions with guards. The instructions in the traces operate on different
machine-level data types, machine integers, doubles, pointers, bools, etc. In
this post we'll be mostly concerned with machine integers.&lt;/p&gt;
&lt;p&gt;To given some wider context I'll explain a bit how Python ints in the user code
relate to the types that are used in traces when the PyPy Python implementation
is used.
When PyPy turns a regular Python 3 function into a trace, there is a lot of work
happening in the JIT frontend to try to observe and infer the types that the
Python function concretely uses at runtime. The traces are generated under these
typing assumptions. Therefore, code that uses &lt;code class="docutils literal"&gt;ints&lt;/code&gt; in the Python code can
typically be translated into traces that operate on machine integers. In order
to make sure that the Python integer semantics are upheld, many of the
operations in the traces need to check that the integer results of some
operations still fit into a machine integer. If that is not the case (a rare
situation for most programs), the trace is left via a guard, execution falls
back to the interpreter, and there a big integer representation is chosen for
the too big value (the big integer representation is done via a pointer and
some storage on the heap).&lt;/p&gt;
&lt;p&gt;All of this machinery is not going to be too relevant for the rest of the
post. For the post it's important to know that trace instructions operate on
machine integers and other low-level types, and some of the operations can
optionally check whether the
results still fit into a machine integer. These trace operations are improved by
the optimizer, which tries to transform the trace into one that behaves the
same, but is less costly to execute.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="background-bounds-analysis-in-pypy-s-jit"&gt;
&lt;h2&gt;Background: Bounds Analysis in PyPy's JIT&lt;/h2&gt;
&lt;p&gt;The optimizer of PyPy's JIT has an analysis based on &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Abstract_interpretation"&gt;abstract interpretation&lt;/a&gt;
that tries to find out whether the integer values stored in a variable are
actually not using the full 64 bit (or 32 bit) range, but instead fit into some
smaller range. This means that for every integer variable &lt;code class="docutils literal"&gt;x&lt;/code&gt; in a trace, the
JIT compiler tracks upper and lower bounds of the runtime value of that
variable: a range &lt;code class="docutils literal"&gt;[a, b]&lt;/code&gt; such that for every concrete runtime value &lt;code class="docutils literal"&gt;v&lt;/code&gt;
that gets stored in variable &lt;code class="docutils literal"&gt;x&lt;/code&gt;, &lt;code class="docutils literal"&gt;a &amp;lt;= v &amp;lt;= b&lt;/code&gt; must be true.
&lt;code class="docutils literal"&gt;a&lt;/code&gt; and &lt;code class="docutils literal"&gt;b&lt;/code&gt; start out
as the most general &lt;code class="docutils literal"&gt;MININT&lt;/code&gt; and &lt;code class="docutils literal"&gt;MAXINT&lt;/code&gt;, but sometimes there is extra
information that makes it possible to improve these known bounds, and that is
often useful to optimize the code.&lt;/p&gt;
&lt;p&gt;A typical example is that the JIT knows that the length of a string is
non-negative, so for this kind of code: &lt;code class="docutils literal"&gt;x = len(s)&lt;/code&gt; where &lt;code class="docutils literal"&gt;s&lt;/code&gt; is a string,
&lt;code class="docutils literal"&gt;x&lt;/code&gt; gets a range &lt;code class="docutils literal"&gt;[0, MAXINT]&lt;/code&gt; assigned. With this information we could for
example remove a check &lt;code class="docutils literal"&gt;x + 10 &amp;lt; 0&lt;/code&gt; completely, because it can never be true.&lt;/p&gt;
&lt;p&gt;The bounds information is useful for optimization, but the analysis of the
bounds is also a source of bugs in the JIT, because the reasoning is often
subtle and easy to get wrong in corner cases. We already use a number of testing
techniques to try to make sure that it is correct. A simple one is
&lt;a class="reference external" href="https://hypothesis.works/articles/what-is-property-based-testing/"&gt;property-based testing&lt;/a&gt; using &lt;a class="reference external" href="https://github.com/HypothesisWorks/hypothesis"&gt;Hypothesis&lt;/a&gt; on the operations on bounds. Even
though Hypothesis is fantastic, it unfortunately does not catch
absolutely all the bugs even if we'd like it too, as we'll see in the next
section.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="motivation-a-jit-miscompilation"&gt;
&lt;h2&gt;Motivation: A JIT Miscompilation&lt;/h2&gt;
&lt;p&gt;I am currently supervising a Bachelor thesis by Nico Rittinghaus, who is
extending the integer analysis in the JIT. He'll probably write a separate blog
post about that soon. In the process of his work, the current bounds analysis
code got a lot of scrutiny, and we found out that one of the unit tests of the
bounds analysis was actually incorrect, and the example code in that unit test
was optimized incorrectly. This case of incorrect optimization is not a big deal
for regular Python code, because it involved a "wrapping integer addition
operation", i.e. one where overflowing results just wrap around to negative
values. All the additions and other arithmetic operations that the PyPy Python
frontend generates actually have
overflow checks (to be able to switch to a big integer representation if
needed).
However, it's still possible to trigger the problem with the
&lt;code class="docutils literal"&gt;__pypy__.intop.int_add&lt;/code&gt; API which is a function that exposes wraparound
arithmetic on Python ints.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/issues/3832"&gt;Here's the miscompilation&lt;/a&gt;. The JIT optimizes the following function:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_29f8eb416bae4a36aee4dd76be4884e0-1" name="rest_code_29f8eb416bae4a36aee4dd76be4884e0-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_29f8eb416bae4a36aee4dd76be4884e0-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;__pypy__&lt;/span&gt;
&lt;a id="rest_code_29f8eb416bae4a36aee4dd76be4884e0-2" name="rest_code_29f8eb416bae4a36aee4dd76be4884e0-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_29f8eb416bae4a36aee4dd76be4884e0-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_29f8eb416bae4a36aee4dd76be4884e0-3" name="rest_code_29f8eb416bae4a36aee4dd76be4884e0-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_29f8eb416bae4a36aee4dd76be4884e0-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;wrong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_29f8eb416bae4a36aee4dd76be4884e0-4" name="rest_code_29f8eb416bae4a36aee4dd76be4884e0-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_29f8eb416bae4a36aee4dd76be4884e0-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__pypy__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;intop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_29f8eb416bae4a36aee4dd76be4884e0-5" name="rest_code_29f8eb416bae4a36aee4dd76be4884e0-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_29f8eb416bae4a36aee4dd76be4884e0-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_29f8eb416bae4a36aee4dd76be4884e0-6" name="rest_code_29f8eb416bae4a36aee4dd76be4884e0-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_29f8eb416bae4a36aee4dd76be4884e0-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_29f8eb416bae4a36aee4dd76be4884e0-7" name="rest_code_29f8eb416bae4a36aee4dd76be4884e0-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_29f8eb416bae4a36aee4dd76be4884e0-7"&gt;&lt;/a&gt;            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;a id="rest_code_29f8eb416bae4a36aee4dd76be4884e0-8" name="rest_code_29f8eb416bae4a36aee4dd76be4884e0-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_29f8eb416bae4a36aee4dd76be4884e0-8"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;a id="rest_code_29f8eb416bae4a36aee4dd76be4884e0-9" name="rest_code_29f8eb416bae4a36aee4dd76be4884e0-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_29f8eb416bae4a36aee4dd76be4884e0-9"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Into the following code:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-1" name="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;__pypy__&lt;/span&gt;
&lt;a id="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-2" name="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-3" name="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;wrong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-4" name="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__pypy__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;intop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-5" name="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-6" name="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;a id="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-7" name="rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_b4a9a1b9a9f04f6482d26c3ceef4457b-7"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically the faulty reasoning of the JIT looks like this: if &lt;code class="docutils literal"&gt;int_add(x, 10) &amp;lt; 15&lt;/code&gt;
then it must follow that &lt;code class="docutils literal"&gt;x &amp;lt; 5&lt;/code&gt;, which is stronger than &lt;code class="docutils literal"&gt;x &amp;lt; 6&lt;/code&gt;, so the
second &lt;code class="docutils literal"&gt;if&lt;/code&gt; is always true. This sounds good, but is actually wrong
if the addition &lt;code class="docutils literal"&gt;+ 10&lt;/code&gt; wrapped around. So if &lt;code class="docutils literal"&gt;x == MAXINT&lt;/code&gt;, then
&lt;code class="docutils literal"&gt;int_add(x, 10) == MININT + 9 &amp;lt; 15&lt;/code&gt;. But &lt;code class="docutils literal"&gt;MAXINT &amp;lt; 5&lt;/code&gt; is not
correct.&lt;/p&gt;
&lt;p&gt;Note how the same reasoning with overflow-checking addition is correct! If &lt;code class="docutils literal"&gt;x +
10 &amp;lt; 15&lt;/code&gt; and the &lt;code class="docutils literal"&gt;+&lt;/code&gt; didn't overflow, then indeed &lt;code class="docutils literal"&gt;x &amp;lt; 6&lt;/code&gt;. And if your
mind bends starting to think about all this, you understand some of the
difficulty of getting the JIT correct in this area.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="how-could-we-have-avoided-this-bug"&gt;
&lt;h2&gt;How could we have avoided this bug?&lt;/h2&gt;
&lt;p&gt;One &lt;a class="reference external" href="https://twitter.com/cfbolz/status/1482649144099586051"&gt;exercise I try to do after finding bugs&lt;/a&gt; is to reflect on ways that the
bug could have been avoided. I think this is particularly important in the JIT,
where bugs are potentially really annoying to find and can cause very strange
behaviour in basically arbitrary Python code.&lt;/p&gt;
&lt;p&gt;It's easy to always answer this question with "try to think more carefully
when working", but that approach cannot be relied on in complicated situations,
because humans don't concentrate perfectly for long stretches of time.&lt;/p&gt;
&lt;p&gt;A situation-specific problem I identified was the bad design of the range analysis API.
A range is not just represented by two numbers, instead it's two numbers
and two bools that are supposed to represent that some operation did or did not
underflow/overflow. The meaning of these bools was quite hard to grasp and easy
to get wrong, so probably they should never have been introduced in the first
place (and my bugfix indeed removed them).&lt;/p&gt;
&lt;p&gt;But in the rest of this blog post I want to talk about another, systematic
approach that can be applied to the problem of mis-optimizations of integer
operations, and that is done by applying an SMT solver to the problem.&lt;/p&gt;
&lt;p&gt;An SMT solver (&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories"&gt;Satisfyability Modulo Theories&lt;/a&gt;) is a tool that can be used to
find out whether mathematical formulas are "satisfiable", i.e. whether
some chosen set of inputs exists that will make the formulas evaluate to true. SMT solvers are
commonly used in a wide range of CS applications including program correctness
proofs, program synthesis, etc. The most widely known one is probably &lt;a class="reference external" href="https://github.com/Z3Prover"&gt;Z3&lt;/a&gt; by
Microsoft Research which has the nice advantage of coming with an easy-to-use
Python binding.&lt;/p&gt;
&lt;p&gt;Going into this I basically knew next to nothing about SMT solvers (despite
having been embedded in a formal methods research group for years!) so it was an
interesting new world to learn about.&lt;/p&gt;
&lt;p&gt;As briefly mentioned in the introduction, the approach I took followed a similar
(but &lt;em&gt;much&lt;/em&gt; more properly executed) one applied to LLVM operations, called
&lt;a class="reference external" href="https://github.com/AliveToolkit/alive2/"&gt;Alive2&lt;/a&gt;. Krister Waldfridsson has done &lt;a class="reference external" href="https://kristerw.github.io/2022/09/13/translation-validation/"&gt;similar work for GCC recently&lt;/a&gt;,
described on his blog.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="z3-proof-of-concept"&gt;
&lt;h2&gt;Z3 Proof of Concept&lt;/h2&gt;
&lt;p&gt;The first thing I did was to try to get Z3 find the above bug, by encoding the
input program into an SMT formula by hand and trying to get Z3 to prove the condition
that the JIT thinks is always true. The Z3 code for this looks as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_616dea2502084c74b21c58a390b9c633-1" name="rest_code_616dea2502084c74b21c58a390b9c633-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_616dea2502084c74b21c58a390b9c633-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;z3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Implies&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prove&lt;/span&gt;
&lt;a id="rest_code_616dea2502084c74b21c58a390b9c633-2" name="rest_code_616dea2502084c74b21c58a390b9c633-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_616dea2502084c74b21c58a390b9c633-2"&gt;&lt;/a&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'x'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_616dea2502084c74b21c58a390b9c633-3" name="rest_code_616dea2502084c74b21c58a390b9c633-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_616dea2502084c74b21c58a390b9c633-3"&gt;&lt;/a&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;a id="rest_code_616dea2502084c74b21c58a390b9c633-4" name="rest_code_616dea2502084c74b21c58a390b9c633-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_616dea2502084c74b21c58a390b9c633-4"&gt;&lt;/a&gt;&lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;a id="rest_code_616dea2502084c74b21c58a390b9c633-5" name="rest_code_616dea2502084c74b21c58a390b9c633-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_616dea2502084c74b21c58a390b9c633-5"&gt;&lt;/a&gt;&lt;span class="n"&gt;cond2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;a id="rest_code_616dea2502084c74b21c58a390b9c633-6" name="rest_code_616dea2502084c74b21c58a390b9c633-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_616dea2502084c74b21c58a390b9c633-6"&gt;&lt;/a&gt;&lt;span class="n"&gt;prove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Implies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cond2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code class="docutils literal"&gt;x&lt;/code&gt; is defined to be a bit vector variable of width 64, which is a
datatype that can be used to represent bounded machine integers. Addition on
bit vectors performs wraparound arithmetic, like the &lt;code class="docutils literal"&gt;__pypy__.intop.int_add&lt;/code&gt;
call in the original code. The JIT optimized the second condition away, so
essentially it was convinced that the first condition implies the second one.
The above snippet tries to get Z3 to confirm this.&lt;/p&gt;
&lt;p&gt;When run, the above program prints:&lt;/p&gt;
&lt;pre class="literal-block"&gt;counterexample
[x = 9223372036854775803]&lt;/pre&gt;
&lt;p&gt;Which shows the bug. As a small side-note, I thought it was cool that the
process of "proving" something in Z3 basically means trying to find an example
for the negation of the formula. If no counterexample can be found for the
negation, the original formula is true. If the original formula turns out to be
false (like here) we get a nice example that shows the problem to go with it.&lt;/p&gt;
&lt;p&gt;It's not realistic to hand-translate all the hundreds of
unit-tests into Z3 formulas and then ask Z3 to prove the optimizations. Instead,
we want to have a program that does this for us.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="smt-checking-of-the-jit-optimizer"&gt;
&lt;h2&gt;SMT Checking of the JIT Optimizer&lt;/h2&gt;
&lt;p&gt;What we want from this program is the following: given an unoptimized trace and
its optimized version, we want to use Z3 to check whether the optimized trace
behaves identically to the unoptimized one. One question is what "behaves
identically" means. What we care about is the outputs of the trace being the
same values, no matter how they are computed. Also, for every guard we want to
make sure that it fails in identical ways in the optimized and unoptimized
versions. A guard is only allowed to be optimized away if it can never fail.
The code that comes after a guard can assume that the guard has not failed,
because otherwise execution would have left the trace. All of this should be
true regardless for the values of the input variables of the trace.&lt;/p&gt;
&lt;p&gt;So in order to check that the two traces are behaving identically, we do the
following:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;We create Z3 variables for every input variable. We use the same input
variables both for the unoptimized as well as the optimized trace.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We align the two traces at the corresponding guards. Thankfully the optimizer
keeps track of which optimized guard corresponds to which unoptimized input
guard.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All the operations before a guard are translated into Z3 formulas, for both
versions of the trace.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For two corresponding guards, we ask Z3 to prove that the guard conditions are
identical.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For a guard that was optimized away we ask Z3 to prove that the condition is
always true.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After a guard, we tell Z3 that from now on it can assume that the guard
condition is true.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We repeat this, guard for guard, until we reach the end of the trace. There,
we ask Z3 to prove that the output variables in the unoptimized trace and the
optimized trace are identical (every trace can return one or many values).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I implemented this, it's &lt;a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/blob/branch/default/rpython/jit/metainterp/optimizeopt/test/test_z3checktests.py"&gt;not a lot of code&lt;/a&gt;, basically a couple of hundred lines
of (somewhat hacky) Python code. So far I only support integer
operations. Here are some parts of the code to give you a flavor of what this
looks like.&lt;/p&gt;
&lt;p&gt;This is the code that translates operations into Z3 formulas:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-1" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;add_to_solver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-2" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-2"&gt;&lt;/a&gt;    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-3" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-3"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s1"&gt;'v'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# is it an operation with a result&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-4" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-4"&gt;&lt;/a&gt;            &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newvar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-5" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-5"&gt;&lt;/a&gt;        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# or does it return void&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-6" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-6"&gt;&lt;/a&gt;            &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-7" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-7"&gt;&lt;/a&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-8" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-8"&gt;&lt;/a&gt;       &lt;span class="c1"&gt;# ...&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-9" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-9"&gt;&lt;/a&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-10" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-10"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# convert arguments&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-11" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-11" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-11"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;numargs&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-12" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-12" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-12"&gt;&lt;/a&gt;            &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-13" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-13" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-13"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;numargs&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-14" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-14" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-14"&gt;&lt;/a&gt;            &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-15" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-15" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-15"&gt;&lt;/a&gt;            &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-16" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-16" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-16"&gt;&lt;/a&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-17" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-17" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-17"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# compute results&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-18" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-18" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-18"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_add"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-19" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-19" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-19"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-20" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-20" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-20"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_sub"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-21" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-21" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-21"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-22" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-22" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-22"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_mul"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-23" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-23" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-23"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-24" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-24" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-24"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_and"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-25" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-25" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-25"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-26" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-26" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-26"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_or"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-27" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-27" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-27"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-28" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-28" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-28"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_xor"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-29" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-29" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-29"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-30" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-30" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-30"&gt;&lt;/a&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-31" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-31" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-31"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ...  more operations, some shown below&lt;/span&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-32" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-32" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-32"&gt;&lt;/a&gt;
&lt;a id="rest_code_bea79ccd747344a7a8770596ee6ac94a-33" name="rest_code_bea79ccd747344a7a8770596ee6ac94a-33" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bea79ccd747344a7a8770596ee6ac94a-33"&gt;&lt;/a&gt;        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;New Z3 variables are defined by the helper function &lt;code class="docutils literal"&gt;newvar&lt;/code&gt;, which adds the
operation to a dictionary &lt;code class="docutils literal"&gt;box_to_z3&lt;/code&gt; mapping boxes (=variables) to Z3
variables. Due to the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Static_single-assignment_form"&gt;SSA&lt;/a&gt; property that traces have, a variable must be defined
before its first use.&lt;/p&gt;
&lt;p&gt;Here's what &lt;code class="docutils literal"&gt;newvar&lt;/code&gt; looks like (&lt;code class="docutils literal"&gt;LONG_BIT&lt;/code&gt; is a constant that is either
&lt;code class="docutils literal"&gt;64&lt;/code&gt; or &lt;code class="docutils literal"&gt;32&lt;/code&gt;, depending on the target architecture):&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_875d01eebb084b78943abfc8320eaf47-1" name="rest_code_875d01eebb084b78943abfc8320eaf47-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_875d01eebb084b78943abfc8320eaf47-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;newvar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_875d01eebb084b78943abfc8320eaf47-2" name="rest_code_875d01eebb084b78943abfc8320eaf47-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_875d01eebb084b78943abfc8320eaf47-2"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# ... some logic around making the string representation&lt;/span&gt;
&lt;a id="rest_code_875d01eebb084b78943abfc8320eaf47-3" name="rest_code_875d01eebb084b78943abfc8320eaf47-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_875d01eebb084b78943abfc8320eaf47-3"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# somewhat nicer omitted&lt;/span&gt;
&lt;a id="rest_code_875d01eebb084b78943abfc8320eaf47-4" name="rest_code_875d01eebb084b78943abfc8320eaf47-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_875d01eebb084b78943abfc8320eaf47-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_875d01eebb084b78943abfc8320eaf47-5" name="rest_code_875d01eebb084b78943abfc8320eaf47-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_875d01eebb084b78943abfc8320eaf47-5"&gt;&lt;/a&gt;    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box_to_z3&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;a id="rest_code_875d01eebb084b78943abfc8320eaf47-6" name="rest_code_875d01eebb084b78943abfc8320eaf47-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_875d01eebb084b78943abfc8320eaf47-6"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code class="docutils literal"&gt;convert&lt;/code&gt; method turns an operation argument (either a constant or a
variable) into a Z3 formula (either a constant bit vector or an already defined
Z3 variable). &lt;code class="docutils literal"&gt;convertarg&lt;/code&gt; is a helper function that takes an operation, reads
its nth argument and converts it.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_272d31315aa546b9a5728320a823fdcc-1" name="rest_code_272d31315aa546b9a5728320a823fdcc-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_272d31315aa546b9a5728320a823fdcc-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;convert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_272d31315aa546b9a5728320a823fdcc-2" name="rest_code_272d31315aa546b9a5728320a823fdcc-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_272d31315aa546b9a5728320a823fdcc-2"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ConstInt&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_272d31315aa546b9a5728320a823fdcc-3" name="rest_code_272d31315aa546b9a5728320a823fdcc-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_272d31315aa546b9a5728320a823fdcc-3"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVecVal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getint&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_272d31315aa546b9a5728320a823fdcc-4" name="rest_code_272d31315aa546b9a5728320a823fdcc-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_272d31315aa546b9a5728320a823fdcc-4"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box_to_z3&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;a id="rest_code_272d31315aa546b9a5728320a823fdcc-5" name="rest_code_272d31315aa546b9a5728320a823fdcc-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_272d31315aa546b9a5728320a823fdcc-5"&gt;&lt;/a&gt;
&lt;a id="rest_code_272d31315aa546b9a5728320a823fdcc-6" name="rest_code_272d31315aa546b9a5728320a823fdcc-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_272d31315aa546b9a5728320a823fdcc-6"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_272d31315aa546b9a5728320a823fdcc-7" name="rest_code_272d31315aa546b9a5728320a823fdcc-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_272d31315aa546b9a5728320a823fdcc-7"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The lookup of variables in &lt;code class="docutils literal"&gt;box_to_z3&lt;/code&gt; that &lt;code class="docutils literal"&gt;convert&lt;/code&gt; does cannot fail,
because the variable must have been defined before use.&lt;/p&gt;
&lt;p&gt;Comparisons return the bit vector 0 or bit vector 1, we use a helper function
&lt;code class="docutils literal"&gt;cond&lt;/code&gt; to turn the Z3 truth value of the comparison into a bit vector:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_676c648407af48678ad25229cd872af4-1" name="rest_code_676c648407af48678ad25229cd872af4-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3expr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-2" name="rest_code_676c648407af48678ad25229cd872af4-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-2"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;If&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TRUEBV&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-3" name="rest_code_676c648407af48678ad25229cd872af4-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-3"&gt;&lt;/a&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-4" name="rest_code_676c648407af48678ad25229cd872af4-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-4"&gt;&lt;/a&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-5" name="rest_code_676c648407af48678ad25229cd872af4-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-5"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;add_to_solver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-6" name="rest_code_676c648407af48678ad25229cd872af4-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-6"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ... start as above&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-7" name="rest_code_676c648407af48678ad25229cd872af4-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-7"&gt;&lt;/a&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-8" name="rest_code_676c648407af48678ad25229cd872af4-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-8"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# more cases&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-9" name="rest_code_676c648407af48678ad25229cd872af4-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-9"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_eq"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-10" name="rest_code_676c648407af48678ad25229cd872af4-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-10"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-11" name="rest_code_676c648407af48678ad25229cd872af4-11" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-11"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_ne"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-12" name="rest_code_676c648407af48678ad25229cd872af4-12" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-12"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-13" name="rest_code_676c648407af48678ad25229cd872af4-13" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-13"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_lt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-14" name="rest_code_676c648407af48678ad25229cd872af4-14" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-14"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-15" name="rest_code_676c648407af48678ad25229cd872af4-15" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-15"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_le"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-16" name="rest_code_676c648407af48678ad25229cd872af4-16" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-16"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-17" name="rest_code_676c648407af48678ad25229cd872af4-17" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-17"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_gt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-18" name="rest_code_676c648407af48678ad25229cd872af4-18" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-18"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-19" name="rest_code_676c648407af48678ad25229cd872af4-19" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-19"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_ge"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-20" name="rest_code_676c648407af48678ad25229cd872af4-20" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-20"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-21" name="rest_code_676c648407af48678ad25229cd872af4-21" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-21"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_is_true"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-22" name="rest_code_676c648407af48678ad25229cd872af4-22" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-22"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-23" name="rest_code_676c648407af48678ad25229cd872af4-23" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-23"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_lt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-24" name="rest_code_676c648407af48678ad25229cd872af4-24" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-24"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ULT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-25" name="rest_code_676c648407af48678ad25229cd872af4-25" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-25"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_le"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-26" name="rest_code_676c648407af48678ad25229cd872af4-26" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-26"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ULE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-27" name="rest_code_676c648407af48678ad25229cd872af4-27" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-27"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_gt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-28" name="rest_code_676c648407af48678ad25229cd872af4-28" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-28"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UGT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-29" name="rest_code_676c648407af48678ad25229cd872af4-29" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-29"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_ge"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-30" name="rest_code_676c648407af48678ad25229cd872af4-30" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-30"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UGE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-31" name="rest_code_676c648407af48678ad25229cd872af4-31" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-31"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_is_zero"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-32" name="rest_code_676c648407af48678ad25229cd872af4-32" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-32"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-33" name="rest_code_676c648407af48678ad25229cd872af4-33" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-33"&gt;&lt;/a&gt;
&lt;a id="rest_code_676c648407af48678ad25229cd872af4-34" name="rest_code_676c648407af48678ad25229cd872af4-34" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_676c648407af48678ad25229cd872af4-34"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ... rest as above&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So basically for every trace operation that operates on integers I had to give a
translation into Z3 formulas, which is mostly straightforward.&lt;/p&gt;
&lt;p&gt;Guard operations get converted into a Z3 boolean by their own helper function,
which looks like this:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-1" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;guard_to_condition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-2" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-2"&gt;&lt;/a&gt;    &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getopname&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-3" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-3"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_true"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-4" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-4"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;TRUEBV&lt;/span&gt;
&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-5" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_false"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-6" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;
&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-7" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-7"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_value"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-8" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-8"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-9" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-9"&gt;&lt;/a&gt;
&lt;a id="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-10" name="rest_code_66f9855ed0ac4a2b8fb858e7164c7889-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_66f9855ed0ac4a2b8fb858e7164c7889-10"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# ... some more exist, shown below&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some operations are a bit trickier. An important example in the context of
this blog post are integer operations that check for overflow. The overflow
operations return a result, but also a boolean whether the operation overflowed
or not.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-1" name="rest_code_c5323f60e59a431e8f89ad282c710109-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;add_to_solver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-2" name="rest_code_c5323f60e59a431e8f89ad282c710109-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-3" name="rest_code_c5323f60e59a431e8f89ad282c710109-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-3"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ... more cases&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-4" name="rest_code_c5323f60e59a431e8f89ad282c710109-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-4"&gt;&lt;/a&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-5" name="rest_code_c5323f60e59a431e8f89ad282c710109-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-5"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_add_ovf"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-6" name="rest_code_c5323f60e59a431e8f89ad282c710109-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-6"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-7" name="rest_code_c5323f60e59a431e8f89ad282c710109-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-7"&gt;&lt;/a&gt;            &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-8" name="rest_code_c5323f60e59a431e8f89ad282c710109-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-8"&gt;&lt;/a&gt;            &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-9" name="rest_code_c5323f60e59a431e8f89ad282c710109-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-9"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_sub_ovf"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-10" name="rest_code_c5323f60e59a431e8f89ad282c710109-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-10"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-11" name="rest_code_c5323f60e59a431e8f89ad282c710109-11" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-11"&gt;&lt;/a&gt;            &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-12" name="rest_code_c5323f60e59a431e8f89ad282c710109-12" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-12"&gt;&lt;/a&gt;            &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-13" name="rest_code_c5323f60e59a431e8f89ad282c710109-13" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-13"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_mul_ovf"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-14" name="rest_code_c5323f60e59a431e8f89ad282c710109-14" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-14"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-15" name="rest_code_c5323f60e59a431e8f89ad282c710109-15" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-15"&gt;&lt;/a&gt;            &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-16" name="rest_code_c5323f60e59a431e8f89ad282c710109-16" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-16"&gt;&lt;/a&gt;            &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-17" name="rest_code_c5323f60e59a431e8f89ad282c710109-17" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-17"&gt;&lt;/a&gt;
&lt;a id="rest_code_c5323f60e59a431e8f89ad282c710109-18" name="rest_code_c5323f60e59a431e8f89ad282c710109-18" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c5323f60e59a431e8f89ad282c710109-18"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The boolean is computed by comparing the result of the bit vector operation with
the result of converting the input bit vectors into an abstract (arbitrary
precision) integer and the result back to bit vectors. Let's go through the
addition case step by step, the other cases work analogously.&lt;/p&gt;
&lt;p&gt;The addition in the first &lt;code class="docutils literal"&gt;elif&lt;/code&gt; that computes &lt;code class="docutils literal"&gt;expr&lt;/code&gt; is an addition on bit
vectors, therefore it is performing wraparound arithmetic.
&lt;code class="docutils literal"&gt;z3.SignExt(LONG_BIT, arg0)&lt;/code&gt; sign-extends &lt;code class="docutils literal"&gt;arg0&lt;/code&gt; from a bit vector of
&lt;code class="docutils literal"&gt;LONG_BIT&lt;/code&gt; bits to an abstract, arbitrary precision integer. The addition in
the second line is therefore an addition between abstract integers, so it will
never overflow and just compute the correct result as an integer.&lt;/p&gt;
&lt;p&gt;The condition to check for overflow is now: if the results of the two different
ways to do the addition are the same, then overflow did not occur. So in order
to compute &lt;code class="docutils literal"&gt;state.no_ovf&lt;/code&gt; in the addition case the
code converts the result of the bit vector wraparound addition to
an abstract integer (using &lt;code class="docutils literal"&gt;SignExt&lt;/code&gt; again), and then compares that to the integer
result.&lt;/p&gt;
&lt;p&gt;This boolean can then be checked by the guard operations &lt;code class="docutils literal"&gt;guard_no_overflow&lt;/code&gt;
and &lt;code class="docutils literal"&gt;guard_overflow&lt;/code&gt;.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-1" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;guard_to_condition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-2" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-3" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-3"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# ... more cases&lt;/span&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-4" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-4"&gt;&lt;/a&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-5" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_no_overflow"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-6" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-7" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-7"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-8" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-8"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_overflow"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-9" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-9"&gt;&lt;/a&gt;        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-10" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-10"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Not&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-11" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-11" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-11"&gt;&lt;/a&gt;
&lt;a id="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-12" name="rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-12" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4b5c20a9d1c746c5a145d6b19f649fc9-12"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# ... more cases&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id="finding-the-bug-again"&gt;
&lt;h2&gt;Finding the Bug, Again&lt;/h2&gt;
&lt;p&gt;Let's actually make all of this more concrete by applying it to the trace of our
original bug. The input trace and the incorrectly optimized trace for that look
like this (differences highlighted):&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_132d80d677594d12bfb5381f226abaf5-1" name="rest_code_132d80d677594d12bfb5381f226abaf5-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_132d80d677594d12bfb5381f226abaf5-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# input                       # optimized&lt;/span&gt;
&lt;a id="rest_code_132d80d677594d12bfb5381f226abaf5-2" name="rest_code_132d80d677594d12bfb5381f226abaf5-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_132d80d677594d12bfb5381f226abaf5-2"&gt;&lt;/a&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;                          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;a id="rest_code_132d80d677594d12bfb5381f226abaf5-3" name="rest_code_132d80d677594d12bfb5381f226abaf5-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_132d80d677594d12bfb5381f226abaf5-3"&gt;&lt;/a&gt;&lt;span class="n"&gt;i1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="n"&gt;i1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_132d80d677594d12bfb5381f226abaf5-4" name="rest_code_132d80d677594d12bfb5381f226abaf5-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_132d80d677594d12bfb5381f226abaf5-4"&gt;&lt;/a&gt;&lt;span class="n"&gt;i2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;           &lt;span class="n"&gt;i2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_132d80d677594d12bfb5381f226abaf5-5" name="rest_code_132d80d677594d12bfb5381f226abaf5-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_132d80d677594d12bfb5381f226abaf5-5"&gt;&lt;/a&gt;&lt;span class="n"&gt;guard_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="n"&gt;guard_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_132d80d677594d12bfb5381f226abaf5-6" name="rest_code_132d80d677594d12bfb5381f226abaf5-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_132d80d677594d12bfb5381f226abaf5-6"&gt;&lt;/a&gt;&lt;span class="hll"&gt;&lt;span class="n"&gt;i3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;            &lt;span class="n"&gt;jump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;a id="rest_code_132d80d677594d12bfb5381f226abaf5-7" name="rest_code_132d80d677594d12bfb5381f226abaf5-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_132d80d677594d12bfb5381f226abaf5-7"&gt;&lt;/a&gt;&lt;span class="hll"&gt;&lt;span class="n"&gt;guard_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;a id="rest_code_132d80d677594d12bfb5381f226abaf5-8" name="rest_code_132d80d677594d12bfb5381f226abaf5-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_132d80d677594d12bfb5381f226abaf5-8"&gt;&lt;/a&gt;&lt;span class="hll"&gt;&lt;span class="n"&gt;jump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the trace represents just one of the paths through the control flow
graph of the original function, which is typical for tracing JITs (the other
paths could incrementally get added later).&lt;/p&gt;
&lt;p&gt;The first guards in both these traces correspond to each other, so the first
chunks to check are the first three operations (lines 1-4). Those operations
don't get changed by the optimizer at all.&lt;/p&gt;
&lt;p&gt;These two identical traces get translated to the following Z3 formulas:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_108f3ba320934eed86892c2b938d8ad1-1" name="rest_code_108f3ba320934eed86892c2b938d8ad1-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_108f3ba320934eed86892c2b938d8ad1-1"&gt;&lt;/a&gt;i1unoptimized == input_i0 + 10
&lt;a id="rest_code_108f3ba320934eed86892c2b938d8ad1-2" name="rest_code_108f3ba320934eed86892c2b938d8ad1-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_108f3ba320934eed86892c2b938d8ad1-2"&gt;&lt;/a&gt;i2unoptimized == If(i1unoptimized &amp;lt; 15, 1, 0)
&lt;a id="rest_code_108f3ba320934eed86892c2b938d8ad1-3" name="rest_code_108f3ba320934eed86892c2b938d8ad1-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_108f3ba320934eed86892c2b938d8ad1-3"&gt;&lt;/a&gt;i1optimized == input_i0 + 10
&lt;a id="rest_code_108f3ba320934eed86892c2b938d8ad1-4" name="rest_code_108f3ba320934eed86892c2b938d8ad1-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_108f3ba320934eed86892c2b938d8ad1-4"&gt;&lt;/a&gt;i2optimized == If(i1optimized &amp;lt; 15, 1, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To check that the two corresponding guards are the same, the solver is asked to
prove that &lt;code class="docutils literal"&gt;(i2unoptimized == 1) == (i2optimized == 1)&lt;/code&gt;. This is
correct, because the formulas for &lt;code class="docutils literal"&gt;i2unoptimized&lt;/code&gt; and &lt;code class="docutils literal"&gt;i2optimized&lt;/code&gt; are
completely identical.&lt;/p&gt;
&lt;p&gt;After checking that the guards behave the same, we add the knowledge to the
solver that the guards passed. So the Z3 formulas become:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-1" name="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4df4cf1627914b0c9cec4a15cf17a44f-1"&gt;&lt;/a&gt;i1unoptimized == input_i0 + 10
&lt;a id="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-2" name="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4df4cf1627914b0c9cec4a15cf17a44f-2"&gt;&lt;/a&gt;i2unoptimized == If(i1unoptimized &amp;lt; 15, 1, 0)
&lt;a id="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-3" name="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4df4cf1627914b0c9cec4a15cf17a44f-3"&gt;&lt;/a&gt;i1optimized == input_i0 + 10
&lt;a id="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-4" name="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4df4cf1627914b0c9cec4a15cf17a44f-4"&gt;&lt;/a&gt;i2optimized == If(i1optimized &amp;lt; 15, 1, 0)
&lt;a id="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-5" name="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4df4cf1627914b0c9cec4a15cf17a44f-5"&gt;&lt;/a&gt;i1optimized == 1
&lt;a id="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-6" name="rest_code_4df4cf1627914b0c9cec4a15cf17a44f-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_4df4cf1627914b0c9cec4a15cf17a44f-6"&gt;&lt;/a&gt;i2optimized == 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we continue with the remaining operations of the two traces (lines 6-8).&lt;/p&gt;
&lt;p&gt;We start by adding the &lt;code class="docutils literal"&gt;int_lt&lt;/code&gt; operation in the unoptimized trace to the Z3
formulas:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_1a5d291704664955b4d156b4713013cd-1" name="rest_code_1a5d291704664955b4d156b4713013cd-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_1a5d291704664955b4d156b4713013cd-1"&gt;&lt;/a&gt;...
&lt;a id="rest_code_1a5d291704664955b4d156b4713013cd-2" name="rest_code_1a5d291704664955b4d156b4713013cd-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_1a5d291704664955b4d156b4713013cd-2"&gt;&lt;/a&gt;i3unoptimized == If(input_i0 &amp;lt; 6, 1, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because the second guard was optimized away, we need to ask Z3 to prove that
&lt;code class="docutils literal"&gt;i3unoptimized == 1&lt;/code&gt; is always true, which fails and gives the following
counterexample:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_3c48e350f13e424a8807bcbeb85af93a-1" name="rest_code_3c48e350f13e424a8807bcbeb85af93a-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3c48e350f13e424a8807bcbeb85af93a-1"&gt;&lt;/a&gt;input_i0 = 9223372036854775800
&lt;a id="rest_code_3c48e350f13e424a8807bcbeb85af93a-2" name="rest_code_3c48e350f13e424a8807bcbeb85af93a-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3c48e350f13e424a8807bcbeb85af93a-2"&gt;&lt;/a&gt;i1unoptimized = 9223372036854775810
&lt;a id="rest_code_3c48e350f13e424a8807bcbeb85af93a-3" name="rest_code_3c48e350f13e424a8807bcbeb85af93a-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3c48e350f13e424a8807bcbeb85af93a-3"&gt;&lt;/a&gt;i2unoptimized = 0
&lt;a id="rest_code_3c48e350f13e424a8807bcbeb85af93a-4" name="rest_code_3c48e350f13e424a8807bcbeb85af93a-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3c48e350f13e424a8807bcbeb85af93a-4"&gt;&lt;/a&gt;i1optimized = 9223372036854775810
&lt;a id="rest_code_3c48e350f13e424a8807bcbeb85af93a-5" name="rest_code_3c48e350f13e424a8807bcbeb85af93a-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3c48e350f13e424a8807bcbeb85af93a-5"&gt;&lt;/a&gt;i2optimized = 1
&lt;a id="rest_code_3c48e350f13e424a8807bcbeb85af93a-6" name="rest_code_3c48e350f13e424a8807bcbeb85af93a-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3c48e350f13e424a8807bcbeb85af93a-6"&gt;&lt;/a&gt;i3unoptimized = 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thus demonstrating the bug. The fact that the Z3-based equivalence check also
managed to find the original motivating bug without manually translating it to
a formula is a good confirmation that the approach works.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="second-bug"&gt;
&lt;h2&gt;Second bug&lt;/h2&gt;
&lt;p&gt;So with this code I applied the Z3-based equivalence check to all our optimizer
unit tests. In addition to the bug we've been discussing the whole post, it also
found another buggy test! I had found it too by hand by staring at all the tests
in the process of writing all the Z3 infrastructure, but it was still a good
confirmation that the process worked. This bug was in the range analysis for
&lt;code class="docutils literal"&gt;int_neg&lt;/code&gt;, integer negation. It failed to account that &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;-MININT&lt;/span&gt; == MININT&lt;/code&gt;
and therefore did a mis-optimization along the following lines:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_78e1ac416d7a4f5a9d5657d013f77198-1" name="rest_code_78e1ac416d7a4f5a9d5657d013f77198-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_78e1ac416d7a4f5a9d5657d013f77198-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;__pypy__&lt;/span&gt;
&lt;a id="rest_code_78e1ac416d7a4f5a9d5657d013f77198-2" name="rest_code_78e1ac416d7a4f5a9d5657d013f77198-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_78e1ac416d7a4f5a9d5657d013f77198-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_78e1ac416d7a4f5a9d5657d013f77198-3" name="rest_code_78e1ac416d7a4f5a9d5657d013f77198-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_78e1ac416d7a4f5a9d5657d013f77198-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;wrong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_78e1ac416d7a4f5a9d5657d013f77198-4" name="rest_code_78e1ac416d7a4f5a9d5657d013f77198-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_78e1ac416d7a4f5a9d5657d013f77198-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__pypy__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;intop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_78e1ac416d7a4f5a9d5657d013f77198-5" name="rest_code_78e1ac416d7a4f5a9d5657d013f77198-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_78e1ac416d7a4f5a9d5657d013f77198-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_78e1ac416d7a4f5a9d5657d013f77198-6" name="rest_code_78e1ac416d7a4f5a9d5657d013f77198-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_78e1ac416d7a4f5a9d5657d013f77198-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_78e1ac416d7a4f5a9d5657d013f77198-7" name="rest_code_78e1ac416d7a4f5a9d5657d013f77198-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_78e1ac416d7a4f5a9d5657d013f77198-7"&gt;&lt;/a&gt;            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;a id="rest_code_78e1ac416d7a4f5a9d5657d013f77198-8" name="rest_code_78e1ac416d7a4f5a9d5657d013f77198-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_78e1ac416d7a4f5a9d5657d013f77198-8"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;a id="rest_code_78e1ac416d7a4f5a9d5657d013f77198-9" name="rest_code_78e1ac416d7a4f5a9d5657d013f77198-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_78e1ac416d7a4f5a9d5657d013f77198-9"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which was wrongly optimized into:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-1" name="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bd49eff9f1b4482fa22c2fff95d6a600-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;__pypy__&lt;/span&gt;
&lt;a id="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-2" name="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bd49eff9f1b4482fa22c2fff95d6a600-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-3" name="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bd49eff9f1b4482fa22c2fff95d6a600-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;wrong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-4" name="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bd49eff9f1b4482fa22c2fff95d6a600-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__pypy__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;intop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-5" name="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bd49eff9f1b4482fa22c2fff95d6a600-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-6" name="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bd49eff9f1b4482fa22c2fff95d6a600-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;a id="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-7" name="rest_code_bd49eff9f1b4482fa22c2fff95d6a600-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_bd49eff9f1b4482fa22c2fff95d6a600-7"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is wrong precisely for &lt;code class="docutils literal"&gt;x == MININT&lt;/code&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="generating-random-traces"&gt;
&lt;h2&gt;Generating Random Traces&lt;/h2&gt;
&lt;p&gt;These two bugs were the only two that the Z3 checker found for existing unit
tests. To try to find some more bugs I combined PyPy's existing random trace
generator with the Z3 optimization checker. The random trace generator has so
far been mostly used to find bugs in the machine code backends, particularly
also in the register allocator. So far we haven't used it with our optimizer,
but my experiments show that we should have!&lt;/p&gt;
&lt;p&gt;I'm going to describe a little bit how the random trace generator works. It's
actually not that complicated, but there's one neat trick to it.&lt;/p&gt;
&lt;p&gt;The basic idea is straightforward, it starts out with an empty trace with a
random number of input variables. Then it adds some number of operations to the
trace, either regular operations or guards. Every operation takes already
existing variables as input.&lt;/p&gt;
&lt;p&gt;The neat trick is that our random trace generator keeps a concrete random
example value for every one of the input variables, and an example result for
every operation. In this way, it is possible to generate guards that are
consistent with the example values to ensure that running the trace to its end
is possible with at least one set of values.&lt;/p&gt;
&lt;p&gt;Here's an example random trace that is generated, together with the random
example inputs and the results of every operation at the end of every line:&lt;/p&gt;
&lt;pre class="literal-block"&gt;[i0, i1, i2, i3, i4, i5] # example values: 9, 11, -8, -95, 46, 57
i6 = int_add_ovf(i3, i0) # -86
guard_no_overflow()
i7 = int_sub(i2, -35/ci) # 27
i8 = uint_ge(i3, i5) # 1
guard_true(i8)
i9 = int_lt(i7, i8) # 0
i10 = int_mul_ovf(34/ci, i7) # 918
guard_no_overflow()
i11 = int_and(i10, 63/ci) # 22
i12 = int_rshift(i3, i11) # -1
i13 = int_is_zero(i7) # 0
i14 = int_is_true(i13) # 0
guard_false(i13)
i15 = int_lt(i8, i4) # 1
i16 = int_and(i6, i0) # 8
i17 = uint_ge(i6, -6/ci) # 0
finish()&lt;/pre&gt;
&lt;p&gt;Note how every guard generated is true for the example values.&lt;/p&gt;
&lt;p&gt;I have been running this combination of random trace generation and Z3 checking
for many nights and it has found some bugs, which I'll describe in the next
section. It should probably be run for a lot longer, but still a useful
exercise already.&lt;/p&gt;
&lt;p&gt;In this mode, I'm giving every Z3 call a time limit to make sure that the random
tests don't just take arbitrarily long. This means that asking Z3 to prove
something can have three outcomes, either it's proved, or Z3 finds a
counterexample, or Z3 times out.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="bugs-found"&gt;
&lt;h2&gt;Bugs Found&lt;/h2&gt;
&lt;p&gt;In addition to the two bugs I've already described, I'll briefly list the
additional bugs that were found by optimizing random traces and then trying to
prove the equivalence with Z3.&lt;/p&gt;
&lt;p&gt;Most of the bugs were actually identified by optimizing random traces alone, not
by the Z3 component. They manifested as assert failures in the JIT compiler.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The JIT concluded after &lt;code class="docutils literal"&gt;12 == int_mul(x, 12)&lt;/code&gt; that &lt;code class="docutils literal"&gt;x == 1&lt;/code&gt;, which is
incorrect if overflow occurred (a counterexample is &lt;code class="docutils literal"&gt;0x8000000000000001&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An amusing bug, where from &lt;code class="docutils literal"&gt;0 == int_lshift(0x1000000000000000, x)&lt;/code&gt; with
&lt;code class="docutils literal"&gt;x &amp;lt;= 0 &amp;lt;= 15&lt;/code&gt;, the JIT concluded that &lt;code class="docutils literal"&gt;0x1000000000000000 == 0&lt;/code&gt;,
triggering an assert. This wrong conclusion was again caused by not taking the
possibility of overflow into account.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A corner case in an optimization for chained integer additions with a
constant, where in complex enough expressions, the wrong IR API was used
(which works correctly in simple cases). Again, this triggered an assert.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This shows that we should have been fuzzing our JIT optimizer already (not a
surprising  observation in hindsight, fuzz all the things!).&lt;/p&gt;
&lt;p&gt;Thankfully, there was also one further bug that really failed in the Z3
verifier. It's a bug in common subexpression elimination / arithmetic
simplification, which again does not take overflow correctly into account.&lt;/p&gt;
&lt;p&gt;The buggy trace looks like this (unfortunately it's not easily possible to show
this bug in Python code).&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_a4a03005288345019fd1e939b7fe65f4-1" name="rest_code_a4a03005288345019fd1e939b7fe65f4-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a4a03005288345019fd1e939b7fe65f4-1"&gt;&lt;/a&gt;[a, b]
&lt;a id="rest_code_a4a03005288345019fd1e939b7fe65f4-2" name="rest_code_a4a03005288345019fd1e939b7fe65f4-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a4a03005288345019fd1e939b7fe65f4-2"&gt;&lt;/a&gt;c = int_add(a, b)
&lt;a id="rest_code_a4a03005288345019fd1e939b7fe65f4-3" name="rest_code_a4a03005288345019fd1e939b7fe65f4-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a4a03005288345019fd1e939b7fe65f4-3"&gt;&lt;/a&gt;r = int_sub_ovf(c, b)
&lt;a id="rest_code_a4a03005288345019fd1e939b7fe65f4-4" name="rest_code_a4a03005288345019fd1e939b7fe65f4-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a4a03005288345019fd1e939b7fe65f4-4"&gt;&lt;/a&gt;guard_no_ovf()
&lt;a id="rest_code_a4a03005288345019fd1e939b7fe65f4-5" name="rest_code_a4a03005288345019fd1e939b7fe65f4-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a4a03005288345019fd1e939b7fe65f4-5"&gt;&lt;/a&gt;finish(r)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This was optimized to:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_aa4b6424ae14468285c03934609d3d3b-1" name="rest_code_aa4b6424ae14468285c03934609d3d3b-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_aa4b6424ae14468285c03934609d3d3b-1"&gt;&lt;/a&gt;[a, b]
&lt;a id="rest_code_aa4b6424ae14468285c03934609d3d3b-2" name="rest_code_aa4b6424ae14468285c03934609d3d3b-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_aa4b6424ae14468285c03934609d3d3b-2"&gt;&lt;/a&gt;finish(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is incorrect, because the guard can fail given the right inputs.
But the optimizer concluded that the subtraction is safe, because its the
inverse of an earlier addition, not taking into account that this earlier
addition can have overflowed.&lt;/p&gt;
&lt;p&gt;Note that a related optimization is actually correct. Given this code:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-1" name="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_94a607bbebbb4a9fa6d1c192f5765eba-1"&gt;&lt;/a&gt;[a, b]
&lt;a id="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-2" name="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_94a607bbebbb4a9fa6d1c192f5765eba-2"&gt;&lt;/a&gt;c = int_add_ovf(a, b)
&lt;a id="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-3" name="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_94a607bbebbb4a9fa6d1c192f5765eba-3"&gt;&lt;/a&gt;guard_no_ovf()
&lt;a id="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-4" name="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_94a607bbebbb4a9fa6d1c192f5765eba-4"&gt;&lt;/a&gt;r = int_sub(c, b)
&lt;a id="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-5" name="rest_code_94a607bbebbb4a9fa6d1c192f5765eba-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_94a607bbebbb4a9fa6d1c192f5765eba-5"&gt;&lt;/a&gt;finish(r)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It can be optimized to:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_d9630ea451954148858f40977d486939-1" name="rest_code_d9630ea451954148858f40977d486939-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d9630ea451954148858f40977d486939-1"&gt;&lt;/a&gt;[a, b]
&lt;a id="rest_code_d9630ea451954148858f40977d486939-2" name="rest_code_d9630ea451954148858f40977d486939-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d9630ea451954148858f40977d486939-2"&gt;&lt;/a&gt;c = int_add_ovf(a, b)
&lt;a id="rest_code_d9630ea451954148858f40977d486939-3" name="rest_code_d9630ea451954148858f40977d486939-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d9630ea451954148858f40977d486939-3"&gt;&lt;/a&gt;guard_no_ovf()
&lt;a id="rest_code_d9630ea451954148858f40977d486939-4" name="rest_code_d9630ea451954148858f40977d486939-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d9630ea451954148858f40977d486939-4"&gt;&lt;/a&gt;finish(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id="future-work-and-conclusion"&gt;
&lt;h2&gt;Future Work and Conclusion&lt;/h2&gt;
&lt;p&gt;In the current form the Z3 checker is only a start, even though it has already
been concretely useful. There are various directions into which we could extend
it. In addition to generate random tests completely from scratch, we could also
start from the existing manually written unit-tests and randomly mutate those.&lt;/p&gt;
&lt;p&gt;I also want to extend the Z3 checker with support more operations, heap
operations in particular (but it's not quite clear to me how to model garbage
collection).&lt;/p&gt;
&lt;p&gt;I also want to try to switch the code away from the Z3 API and use the more
general &lt;a class="reference external" href="https://smtlib.cs.uiowa.edu/"&gt;smtlib&lt;/a&gt; interface directly, in order to be able to use other SMT
checkers than Z3, eg &lt;a class="reference external" href="https://cvc4.github.io/"&gt;CVC4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But all in all this was a fun and not too hard way to find a bunch of bugs in
our optimizer! And the infrastructure is now in place, which means that we run
some random test cases every time we execute our tests. This is going to be
particularly useful when we do further work on the integer reasoning of the JIT
(like Nico is doing, for example). As of time of writing of this post, all the
bugs mentioned have been fixed and the Z3 code has landed on the default branch
and runs as part of PyPy's CI infrastructure.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="acknowledgements"&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to &lt;a class="reference external" href="http://saambarati.org/"&gt;Saam Barati&lt;/a&gt;, &lt;a class="reference external" href="https://bernsteinbear.com"&gt;Max Bernstein&lt;/a&gt;, &lt;a class="reference external" href="https://www.cs.hhu.de/lehrstuehle-und-arbeitsgruppen/softwaretechnik-und-programmiersprachen/unser-team/team/schmidt"&gt;Joshua Schmidt&lt;/a&gt; and &lt;a class="reference external" href="https://martinfriedrichberger.net/"&gt;Martin
Berger&lt;/a&gt;, for great feedback on drafts of this post!&lt;/p&gt;
&lt;/section&gt;</description><category>jit</category><category>testing</category><category>z3</category><guid>https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html</guid><pubDate>Sun, 11 Dec 2022 18:00:00 GMT</pubDate></item><item><title>How to make your code 80 times faster</title><link>https://www.pypy.org/posts/2017/10/how-to-make-your-code-80-times-faster-1424098117108093942.html</link><dc:creator>Antonio Cuni</dc:creator><description>&lt;div class="document" id="how-to-make-your-code-80-times-faster"&gt;
I often hear people who are happy because PyPy makes their code 2 times faster
or so. Here is a short personal story which shows PyPy can go well beyond
that.&lt;br&gt;
&lt;br&gt;
&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: this is not a silver bullet or a general recipe: it worked in
this particular case, it might not work so well in other cases. But I think it
is still an interesting technique. Moreover, the various steps and
implementations are showed in the same order as I tried them during the
development, so it is a real-life example of how to proceed when optimizing
for PyPy.&lt;br&gt;
&lt;br&gt;
Some months ago I &lt;a class="reference external" href="https://github.com/antocuni/evolvingcopter"&gt;played a bit&lt;/a&gt; with evolutionary algorithms: the ambitious
plan was to automatically evolve a logic which could control a (simulated)
quadcopter, i.e. a &lt;a class="reference external" href="https://en.wikipedia.org/wiki/PID_controller"&gt;PID controller&lt;/a&gt; (&lt;strong&gt;spoiler&lt;/strong&gt;: it doesn't fly).&lt;br&gt;
&lt;br&gt;
The idea is to have an initial population of random creatures: at each
generation, the ones with the best fitness survive and reproduce with small,
random variations.&lt;br&gt;
&lt;br&gt;
However, for the scope of this post, the actual task at hand is not so
important, so let's jump straight to the code. To drive the quadcopter, a
&lt;tt class="docutils literal"&gt;Creature&lt;/tt&gt; has a &lt;tt class="docutils literal"&gt;run_step&lt;/tt&gt; method which runs at each &lt;tt class="docutils literal"&gt;delta_t&lt;/tt&gt; (&lt;a class="reference external" href="https://github.com/antocuni/evolvingcopter/blob/master/ev/creature.py"&gt;full
code&lt;/a&gt;):&lt;br&gt;
&lt;pre class="code python literal-block"&gt;&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="name class"&gt;Creature&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name builtin"&gt;object&lt;/span&gt;&lt;span class="punctuation"&gt;):&lt;/span&gt;
    &lt;span class="name"&gt;INPUTS&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="literal number integer"&gt;2&lt;/span&gt;  &lt;span class="comment single"&gt;# z_setpoint, current z position&lt;/span&gt;
    &lt;span class="name"&gt;OUTPUTS&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="literal number integer"&gt;1&lt;/span&gt; &lt;span class="comment single"&gt;# PWM for all 4 motors&lt;/span&gt;
    &lt;span class="name"&gt;STATE_VARS&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="literal number integer"&gt;1&lt;/span&gt;
    &lt;span class="operator"&gt;...&lt;/span&gt;

    &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="name function"&gt;run_step&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;inputs&lt;/span&gt;&lt;span class="punctuation"&gt;):&lt;/span&gt;
        &lt;span class="comment single"&gt;# state: [state_vars ... inputs]&lt;/span&gt;
        &lt;span class="comment single"&gt;# out_values: [state_vars, ... outputs]&lt;/span&gt;
        &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;state&lt;/span&gt;&lt;span class="punctuation"&gt;[&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;STATE_VARS&lt;/span&gt;&lt;span class="punctuation"&gt;:]&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name"&gt;inputs&lt;/span&gt;
        &lt;span class="name"&gt;out_values&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name"&gt;np&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;dot&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;matrix&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;state&lt;/span&gt;&lt;span class="punctuation"&gt;)&lt;/span&gt; &lt;span class="operator"&gt;+&lt;/span&gt; &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;constant&lt;/span&gt;
        &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;state&lt;/span&gt;&lt;span class="punctuation"&gt;[:&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;STATE_VARS&lt;/span&gt;&lt;span class="punctuation"&gt;]&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name"&gt;out_values&lt;/span&gt;&lt;span class="punctuation"&gt;[:&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;STATE_VARS&lt;/span&gt;&lt;span class="punctuation"&gt;]&lt;/span&gt;
        &lt;span class="name"&gt;outputs&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name"&gt;out_values&lt;/span&gt;&lt;span class="punctuation"&gt;[&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;STATE_VARS&lt;/span&gt;&lt;span class="punctuation"&gt;:]&lt;/span&gt;
        &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="name"&gt;outputs&lt;/span&gt;
&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;inputs&lt;/tt&gt; is a numpy array containing the desired setpoint and the current
position on the Z axis;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;outputs&lt;/tt&gt; is a numpy array containing the thrust to give to the motors. To
start easy, all the 4 motors are constrained to have the same thrust, so
that the quadcopter only travels up and down the Z axis;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;self.state&lt;/tt&gt; contains arbitrary values of unknown size which are passed from
one step to the next;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;self.matrix&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;self.constant&lt;/tt&gt; contains the actual logic. By putting
the "right" values there, in theory we could get a perfectly tuned PID
controller. These are randomly mutated between generations.&lt;/li&gt;
&lt;/ul&gt;
&lt;tt class="docutils literal"&gt;run_step&lt;/tt&gt; is called at 100Hz (in the virtual time frame of the simulation). At each
generation, we test 500 creatures for a total of 12 virtual seconds each. So,
we have a total of 600,000 executions of &lt;tt class="docutils literal"&gt;run_step&lt;/tt&gt; at each generation.&lt;br&gt;
&lt;br&gt;
At first, I simply tried to run this code on CPython; here is the result:&lt;br&gt;
&lt;pre class="code literal-block"&gt;$ python -m ev.main
Generation   1: ... [population = 500]  [12.06 secs]
Generation   2: ... [population = 500]  [6.13 secs]
Generation   3: ... [population = 500]  [6.11 secs]
Generation   4: ... [population = 500]  [6.09 secs]
Generation   5: ... [population = 500]  [6.18 secs]
Generation   6: ... [population = 500]  [6.26 secs]
&lt;/pre&gt;
Which means ~6.15 seconds/generation, excluding the first.&lt;br&gt;
&lt;br&gt;
Then I tried with PyPy 5.9:&lt;br&gt;
&lt;pre class="code literal-block"&gt;$ pypy -m ev.main
Generation   1: ... [population = 500]  [63.90 secs]
Generation   2: ... [population = 500]  [33.92 secs]
Generation   3: ... [population = 500]  [34.21 secs]
Generation   4: ... [population = 500]  [33.75 secs]
&lt;/pre&gt;
Ouch! We are ~5.5x slower than CPython. This was kind of expected: numpy is
based on cpyext, which is infamously slow.  (Actually, &lt;a class="reference external" href="https://pypy.org/posts/2017/10/cape-of-good-hope-for-pypy-hello-from-3656631725712879033.html"&gt;we are working on
that&lt;/a&gt; and on the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;cpyext-avoid-roundtrip&lt;/span&gt;&lt;/tt&gt; branch we are already faster than
CPython, but this will be the subject of another blog post.)&lt;br&gt;
&lt;br&gt;
So, let's try to avoid cpyext. The first obvious step is to use &lt;a class="reference external" href="https://doc.pypy.org/en/latest/faq.html#what-about-numpy-numpypy-micronumpy"&gt;numpypy&lt;/a&gt;
instead of numpy (actually, there is a &lt;a class="reference external" href="https://github.com/antocuni/evolvingcopter/blob/master/ev/pypycompat.py"&gt;hack&lt;/a&gt; to use just the micronumpy
part). Let's see if the speed improves:&lt;br&gt;
&lt;pre class="code literal-block"&gt;$ pypy -m ev.main   # using numpypy
Generation   1: ... [population = 500]  [5.60 secs]
Generation   2: ... [population = 500]  [2.90 secs]
Generation   3: ... [population = 500]  [2.78 secs]
Generation   4: ... [population = 500]  [2.69 secs]
Generation   5: ... [population = 500]  [2.72 secs]
Generation   6: ... [population = 500]  [2.73 secs]
&lt;/pre&gt;
So, ~2.7 seconds on average: this is 12x faster than PyPy+numpy, and more than
2x faster than the original CPython. At this point, most people would be happy
and go tweeting how PyPy is great.&lt;br&gt;
&lt;br&gt;
In general, when talking of CPython vs PyPy, I am rarely satisfied with a 2x
speedup: I know that PyPy can do much better than this, especially if you
write code which is specifically optimized for the JIT. For a real-life
example, have a look at &lt;a class="reference external" href="https://capnpy.readthedocs.io/en/latest/benchmarks.html"&gt;capnpy benchmarks&lt;/a&gt;, in which the PyPy version is
~15x faster than the heavily optimized CPython+Cython version (both have been
written by me, and I tried hard to write the fastest code for both
implementations).&lt;br&gt;
&lt;br&gt;
So, let's try to do better. As usual, the first thing to do is to profile and
see where we spend most of the time. Here is the &lt;a class="reference external" href="https://vmprof.com/#/449ca8ee-3ab2-49d4-b6f0-9099987e9000"&gt;vmprof profile&lt;/a&gt;. We spend a
lot of time inside the internals of numpypy, and allocating tons of temporary
arrays to store the results of the various operations.&lt;br&gt;
&lt;br&gt;
Also, let's look at the &lt;a class="reference external" href="https://vmprof.com/#/28fd6e8f-f103-4bf4-a76a-4b65dbd637f4/traces"&gt;jit traces&lt;/a&gt; and search for the function &lt;tt class="docutils literal"&gt;run&lt;/tt&gt;:
this is loop in which we spend most of the time, and it is composed of 1796
operations.  The operations emitted for the line &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;np.dot(...)&lt;/span&gt; +
self.constant&lt;/tt&gt; are listed between lines 1217 and 1456. Here is the excerpt
which calls &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;np.dot(...)&lt;/span&gt;&lt;/tt&gt;; most of the ops are cheap, but at line 1232 we
see a call to the RPython function &lt;a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/blob/release-pypy3.5-v5.10.0/pypy/module/micronumpy/ndarray.py#L1160"&gt;descr_dot&lt;/a&gt;; by looking at the
implementation we see that it creates a new &lt;tt class="docutils literal"&gt;W_NDimArray&lt;/tt&gt; to store the
result, which means it has to do a &lt;tt class="docutils literal"&gt;malloc()&lt;/tt&gt;:&lt;br&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="https://4.bp.blogspot.com/-_h6BuLTtEO8/Wfb6BXDg93I/AAAAAAAABNY/BY2XBg4ZtwokB9f1mWSmzI9gn_qanb81QCLcBGAs/s1600/2017-10-trace1.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="450" src="https://4.bp.blogspot.com/-_h6BuLTtEO8/Wfb6BXDg93I/AAAAAAAABNY/BY2XBg4ZtwokB9f1mWSmzI9gn_qanb81QCLcBGAs/s640/2017-10-trace1.png" width="640"&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br&gt;
The implementation of the &lt;tt class="docutils literal"&gt;+ self.constant&lt;/tt&gt; part is also interesting:
contrary the former, the call to &lt;tt class="docutils literal"&gt;W_NDimArray.descr_add&lt;/tt&gt; has been inlined by
the JIT, so we have a better picture of what's happening; in particular, we
can see the call to &lt;tt class="docutils literal"&gt;__0_alloc_with_del____&lt;/tt&gt; which allocates the
&lt;tt class="docutils literal"&gt;W_NDimArray&lt;/tt&gt; for the result, and the &lt;tt class="docutils literal"&gt;raw_malloc&lt;/tt&gt; which allocates the
actual array. Then we have a long list of 149 simple operations which set the
fields of the resulting array, construct an iterator, and finally do a
&lt;tt class="docutils literal"&gt;call_assembler&lt;/tt&gt;: this is the actual logic to do the addition, which was
JITtted independently; &lt;tt class="docutils literal"&gt;call_assembler&lt;/tt&gt; is one of the operations to do
JIT-to-JIT calls:&lt;br&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="https://1.bp.blogspot.com/-vmo0pWharIU/Wfb3VfwHjxI/AAAAAAAABNE/a6Em09qZizwGiWJeTbGzKfHQH70dB7RKgCEwYBhgL/s1600/2017-10-trace2.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="640" src="https://1.bp.blogspot.com/-vmo0pWharIU/Wfb3VfwHjxI/AAAAAAAABNE/a6Em09qZizwGiWJeTbGzKfHQH70dB7RKgCEwYBhgL/s640/2017-10-trace2.png" width="625"&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br&gt;
All of this is very suboptimal: in this particular case, we know that the
shape of &lt;tt class="docutils literal"&gt;self.matrix&lt;/tt&gt; is always &lt;tt class="docutils literal"&gt;(3, 2)&lt;/tt&gt;: so, we are doing an incredible
amount of work, including callingÂ &lt;tt class="docutils literal"&gt;malloc()&lt;/tt&gt; twice for the temporary arrays, just to
call two functions which ultimately do a total of 6 multiplications
and 6 additions.  Note also that this is not a fault of the JIT: CPython+numpy
has to do the same amount of work, just hidden inside C calls.&lt;br&gt;
&lt;br&gt;
One possible solution to this nonsense is a well known compiler optimization:
loop unrolling.  From the compiler point of view, unrolling the loop is always
risky because if the matrix is too big you might end up emitting a huge blob
of code, possibly uselss if the shape of the matrices change frequently: this
is the main reason why the PyPy JIT does not even try to do it in this case.&lt;br&gt;
&lt;br&gt;
However, we &lt;strong&gt;know&lt;/strong&gt; that the matrix is small, and always of the same
shape. So, let's unroll the loop manually:&lt;br&gt;
&lt;pre class="code python literal-block"&gt;&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="name class"&gt;SpecializedCreature&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name"&gt;Creature&lt;/span&gt;&lt;span class="punctuation"&gt;):&lt;/span&gt;

    &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="name function magic"&gt;__init__&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="operator"&gt;*&lt;/span&gt;&lt;span class="name"&gt;args&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="operator"&gt;**&lt;/span&gt;&lt;span class="name"&gt;kwargs&lt;/span&gt;&lt;span class="punctuation"&gt;):&lt;/span&gt;
        &lt;span class="name"&gt;Creature&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name function magic"&gt;__init__&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="operator"&gt;*&lt;/span&gt;&lt;span class="name"&gt;args&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="operator"&gt;**&lt;/span&gt;&lt;span class="name"&gt;kwargs&lt;/span&gt;&lt;span class="punctuation"&gt;)&lt;/span&gt;
        &lt;span class="comment single"&gt;# store the data in a plain Python list&lt;/span&gt;
        &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;data&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name builtin"&gt;list&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;matrix&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;ravel&lt;/span&gt;&lt;span class="punctuation"&gt;())&lt;/span&gt; &lt;span class="operator"&gt;+&lt;/span&gt; &lt;span class="name builtin"&gt;list&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;constant&lt;/span&gt;&lt;span class="punctuation"&gt;)&lt;/span&gt;
        &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;data_state&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="punctuation"&gt;[&lt;/span&gt;&lt;span class="literal number float"&gt;0.0&lt;/span&gt;&lt;span class="punctuation"&gt;]&lt;/span&gt;
        &lt;span class="keyword"&gt;assert&lt;/span&gt; &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;matrix&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;shape&lt;/span&gt; &lt;span class="operator"&gt;==&lt;/span&gt; &lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="literal number integer"&gt;2&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="literal number integer"&gt;3&lt;/span&gt;&lt;span class="punctuation"&gt;)&lt;/span&gt;
        &lt;span class="keyword"&gt;assert&lt;/span&gt; &lt;span class="name builtin"&gt;len&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;data&lt;/span&gt;&lt;span class="punctuation"&gt;)&lt;/span&gt; &lt;span class="operator"&gt;==&lt;/span&gt; &lt;span class="literal number integer"&gt;8&lt;/span&gt;

    &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="name function"&gt;run_step&lt;/span&gt;&lt;span class="punctuation"&gt;(&lt;/span&gt;&lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;inputs&lt;/span&gt;&lt;span class="punctuation"&gt;):&lt;/span&gt;
        &lt;span class="comment single"&gt;# state: [state_vars ... inputs]&lt;/span&gt;
        &lt;span class="comment single"&gt;# out_values: [state_vars, ... outputs]&lt;/span&gt;
        &lt;span class="name"&gt;k0&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;k1&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;k2&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;q0&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;q1&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;q2&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;c0&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;c1&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;data&lt;/span&gt;
        &lt;span class="name"&gt;s0&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;data_state&lt;/span&gt;&lt;span class="punctuation"&gt;[&lt;/span&gt;&lt;span class="literal number integer"&gt;0&lt;/span&gt;&lt;span class="punctuation"&gt;]&lt;/span&gt;
        &lt;span class="name"&gt;z_sp&lt;/span&gt;&lt;span class="punctuation"&gt;,&lt;/span&gt; &lt;span class="name"&gt;z&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name"&gt;inputs&lt;/span&gt;
        &lt;span class="comment single"&gt;#&lt;/span&gt;
        &lt;span class="comment single"&gt;# compute the output&lt;/span&gt;
        &lt;span class="name"&gt;out0&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name"&gt;s0&lt;/span&gt;&lt;span class="operator"&gt;*&lt;/span&gt;&lt;span class="name"&gt;k0&lt;/span&gt; &lt;span class="operator"&gt;+&lt;/span&gt; &lt;span class="name"&gt;z_sp&lt;/span&gt;&lt;span class="operator"&gt;*&lt;/span&gt;&lt;span class="name"&gt;k1&lt;/span&gt; &lt;span class="operator"&gt;+&lt;/span&gt; &lt;span class="name"&gt;z&lt;/span&gt;&lt;span class="operator"&gt;*&lt;/span&gt;&lt;span class="name"&gt;k2&lt;/span&gt; &lt;span class="operator"&gt;+&lt;/span&gt; &lt;span class="name"&gt;c0&lt;/span&gt;
        &lt;span class="name"&gt;out1&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name"&gt;s0&lt;/span&gt;&lt;span class="operator"&gt;*&lt;/span&gt;&lt;span class="name"&gt;q0&lt;/span&gt; &lt;span class="operator"&gt;+&lt;/span&gt; &lt;span class="name"&gt;z_sp&lt;/span&gt;&lt;span class="operator"&gt;*&lt;/span&gt;&lt;span class="name"&gt;q1&lt;/span&gt; &lt;span class="operator"&gt;+&lt;/span&gt; &lt;span class="name"&gt;z&lt;/span&gt;&lt;span class="operator"&gt;*&lt;/span&gt;&lt;span class="name"&gt;q2&lt;/span&gt; &lt;span class="operator"&gt;+&lt;/span&gt; &lt;span class="name"&gt;c1&lt;/span&gt;
        &lt;span class="comment single"&gt;#&lt;/span&gt;
        &lt;span class="name builtin pseudo"&gt;self&lt;/span&gt;&lt;span class="operator"&gt;.&lt;/span&gt;&lt;span class="name"&gt;data_state&lt;/span&gt;&lt;span class="punctuation"&gt;[&lt;/span&gt;&lt;span class="literal number integer"&gt;0&lt;/span&gt;&lt;span class="punctuation"&gt;]&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="name"&gt;out0&lt;/span&gt;
        &lt;span class="name"&gt;outputs&lt;/span&gt; &lt;span class="operator"&gt;=&lt;/span&gt; &lt;span class="punctuation"&gt;[&lt;/span&gt;&lt;span class="name"&gt;out1&lt;/span&gt;&lt;span class="punctuation"&gt;]&lt;/span&gt;
        &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="name"&gt;outputs&lt;/span&gt;
&lt;/pre&gt;
In the &lt;a class="reference external" href="https://github.com/antocuni/evolvingcopter/blob/master/ev/creature.py#L100"&gt;actual code&lt;/a&gt; there is also a sanity check which asserts that the
computed output is the very same as the one returned by &lt;tt class="docutils literal"&gt;Creature.run_step&lt;/tt&gt;.&lt;br&gt;
&lt;br&gt;
So, let's try to see how it performs. First, with CPython:&lt;br&gt;
&lt;pre class="code literal-block"&gt;$ python -m ev.main
Generation   1: ... [population = 500]  [7.61 secs]
Generation   2: ... [population = 500]  [3.96 secs]
Generation   3: ... [population = 500]  [3.79 secs]
Generation   4: ... [population = 500]  [3.74 secs]
Generation   5: ... [population = 500]  [3.84 secs]
Generation   6: ... [population = 500]  [3.69 secs]
&lt;/pre&gt;
This looks good: 60% faster than the original CPython+numpy
implementation. Let's try on PyPy:&lt;br&gt;
&lt;pre class="code literal-block"&gt;Generation   1: ... [population = 500]  [0.39 secs]
Generation   2: ... [population = 500]  [0.10 secs]
Generation   3: ... [population = 500]  [0.11 secs]
Generation   4: ... [population = 500]  [0.09 secs]
Generation   5: ... [population = 500]  [0.08 secs]
Generation   6: ... [population = 500]  [0.12 secs]
Generation   7: ... [population = 500]  [0.09 secs]
Generation   8: ... [population = 500]  [0.08 secs]
Generation   9: ... [population = 500]  [0.08 secs]
Generation  10: ... [population = 500]  [0.08 secs]
Generation  11: ... [population = 500]  [0.08 secs]
Generation  12: ... [population = 500]  [0.07 secs]
Generation  13: ... [population = 500]  [0.07 secs]
Generation  14: ... [population = 500]  [0.08 secs]
Generation  15: ... [population = 500]  [0.07 secs]
&lt;/pre&gt;
Yes, it's not an error. After a couple of generations, it stabilizes at around
~0.07-0.08 seconds per generation. This is around &lt;strong&gt;80 (eighty) times faster&lt;/strong&gt;
than the original CPython+numpy implementation, and around 35-40x faster than
the naive PyPy+numpypy one.&lt;br&gt;
&lt;br&gt;
Let's look at the &lt;a class="reference external" href="https://vmprof.com/#/402af746-2966-4403-a61d-93015abac033/traces"&gt;trace&lt;/a&gt; again: it no longer contains expensive calls, and
certainly no more temporary &lt;tt class="docutils literal"&gt;malloc()&lt;/tt&gt; s. The core of the logic is between
lines 386-416, where we can see that it does fast C-level multiplications and
additions: &lt;tt class="docutils literal"&gt;float_mul&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;float_add&lt;/tt&gt; are translated straight into
&lt;tt class="docutils literal"&gt;mulsd&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;addsd&lt;/tt&gt; x86 instructions.&lt;br&gt;
&lt;br&gt;
As I said before, this is a very particular example, and the techniques
described here do not always apply: it is not realistic to expect an 80x
speedup on arbitrary code, unfortunately. However, it clearly shows the potential of PyPy when
it comes to high-speed computing. And most importantly, it's not a toy
benchmark which was designed specifically to have good performance on PyPy:
it's a real world example, albeit small.&lt;br&gt;
&lt;br&gt;
You might be also interested in the talk I gave at last EuroPython, in which I
talk about a similar topic: "The Joy of PyPy JIT: abstractions for free"
(&lt;a class="reference external" href="https://ep2017.europython.eu/conference/talks/the-joy-of-pypy-jit-abstractions-for-free"&gt;abstract&lt;/a&gt;, &lt;a class="reference external" href="https://speakerdeck.com/antocuni/the-joy-of-pypy-jit-abstractions-for-free"&gt;slides&lt;/a&gt; and &lt;a class="reference external" href="https://www.youtube.com/watch?v=NQfpHQII2cU"&gt;video&lt;/a&gt;).&lt;br&gt;
&lt;br&gt;
&lt;div class="section" id="how-to-reproduce-the-results"&gt;
&lt;h3&gt;
How to reproduce the results&lt;/h3&gt;
&lt;pre class="code literal-block"&gt;$ git clone https://github.com/antocuni/evolvingcopter
$ cd evolvingcopter
$ {python,pypy} -m ev.main --no-specialized --no-numpypy
$ {python,pypy} -m ev.main --no-specialized
$ {python,pypy} -m ev.main
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>jit</category><category>profiling</category><category>speed</category><guid>https://www.pypy.org/posts/2017/10/how-to-make-your-code-80-times-faster-1424098117108093942.html</guid><pubDate>Mon, 30 Oct 2017 10:15:00 GMT</pubDate></item><item><title>Almost There - PyPy's ARM Backend</title><link>https://www.pypy.org/posts/2012/02/almost-there-pypys-arm-backend_01-3216759488618774525.html</link><dc:creator>David Schneider</dc:creator><description>&lt;div style="text-align: left;"&gt;
In this post I want to give an update on the status of the ARM backend for PyPy's JIT and describe some of the issues and details of the backend.&lt;/div&gt;
&lt;div class="section" id="current-status"&gt;
&lt;br&gt;
&lt;h2&gt;




Current Status&lt;/h2&gt;
It has been a more than a year that I have been working on the ARM backend. Now it is in a shape, that we can measure meaningful numbers and also ask for some feedback.Â Since the &lt;a class="reference external" href="https://www.pypy.org/posts/2011/01/jit-backend-for-arm-processors-5994810755839586463.html"&gt;last post about the backend&lt;/a&gt; we have added support floating point operations as well as for PyPy's framework GC's. Another area of work was to keep up with the constant improvements done in the main development branch, such as out-of-line guards, labels, etc.Â It has been possible for about a year to cross-translate the PyPy Python interpreter and other interpreters such as &lt;a class="reference external" href="https://bitbucket.org/cfbolz/pyrolog/"&gt;Pyrolog&lt;/a&gt;, with a JIT, to run benchmarks on ARM. Up until now there remained some hard to track bugs that would cause the interpreter to crash with a segmentation fault in certain cases when running with the JIT on ARM. Lately it was possible to run all benchmarks without problems, but when running the translation toolchain itself it would crash.Â During the last PyPy sprint in &lt;a class="reference external" href="https://www.pypy.org/posts/2011/12/leysin-winter-sprint-6862532189897876336.html"&gt;Leysin&lt;/a&gt; Armin and I managed to fix several of these hard to track bugs in the ARM backend with the result that, it is now possible to run the PyPy translator on ARM itself (at least unless until it runs out of memory), which is a kind of litmus test for the backend itself and used to crash before. Just to point it out, we are not able to complete a PyPy translation on ARM, because on the hardware we have currently available there is not enough memory. But up to the point we run out of memory the JIT does not hit any issues.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="implementation-details"&gt;
&lt;h2&gt;




Implementation Details&lt;/h2&gt;
The hardware requirements to run the JIT on ARM follow those for Ubuntu on ARM which targets ARMv7 with a VFP unit running in little endian mode. The JIT can be translated without floating point support, but there might be a few places that need to be fixed to fully work in this setting.Â We are targeting the ARM instruction set, because at least at the time we decided to use it seemed to be the best choice in terms of speed while having some size overhead compared to the Thumb2 instruction set. It appears that the Thumb2 instruction set should give comparable speed with better code density but has a few restriction on the number of registers available and the use of conditional execution. Also the implementation is a bit easier using a fixed width instruction set and we can use the full set of registers in the generated code when using the ARM instruction set.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="the-calling-convention-on-arm"&gt;
&lt;h2&gt;




The calling convention on ARM&lt;/h2&gt;
The calling convention on ARM uses 4 of the general purpose registers to pass arguments to functions, further arguments are passed on the stack. The presence of a floating point unit is not required for ARM cores, for this reason there are different ways of handling floats with relation to the calling convention. There is a so called soft-float calling convention that is independent of the presence of a floating point unit. For this calling convention floating point arguments to functions are stored in the general purpose registers and on the stack. Passing floats around this way works with software and hardware floating point implementations. But in presence of a floating point unit it produces some overhead, because floating point numbers need to be moved from the floating point unit to the core registers to do a call and moved back to the floating point registers by the callee. The alternative calling convention is the so-called hard-float calling convention which requires the presence of a floating point unit but has the advantage of getting rid of the overhead of moving floating point values around when performing a call. Although it would be better in the long term to support the hard-float calling convention, we need to be able to interoperate with external code compiled for the operating system we are running on. For this reason at the moment we only support the soft-float to interoperate with external code.Â We implemented and tested the backend on a &lt;a class="reference external" href="https://beagleboard.org/hardware-xM/"&gt;BeagleBoard-xM&lt;/a&gt; with a &lt;a class="reference external" href="https://www.arm.com/products/processors/cortex-a/cortex-a8.php"&gt;Cortex-A8&lt;/a&gt; processor running &lt;a class="reference external" href="https://wiki.ubuntu.com/ARM"&gt;Ubuntu 11.04 for ARM&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="translating-for-arm"&gt;
&lt;h2&gt;




Translating for ARM&lt;/h2&gt;
The toolchain used to translate PyPy currently is based on a &lt;a class="reference external" href="https://maemo.gitorious.org/scratchbox2/pages/Home"&gt;Scratchbox2&lt;/a&gt;. Scratchbox2 is a cross-compiling environment. Development had stopped for a while, but it seems to have revived again. We run a 32-bit Python interpreter on the host system and perform all calls to the compiler using a Scratchbox2 based environment. A description on how to setup the cross translation toolchain can be found &lt;a class="reference external" href="https://bitbucket.org/pypy/pypy/src/1f07ea8076c9/pypy/doc/arm.rst"&gt;here&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="results"&gt;
&lt;h2&gt;




Results&lt;/h2&gt;
The current results on ARM, as shown in the graph below, show that the JIT currently gives a speedup of about 3.5 times compared to CPython on ARM. The benchmarks were run on the before mentioned BeagleBoard-xM with a 1GHz ARM Cortex-A8 processor and 512MB of memory. The operating system on the board is Ubuntu 11.04 for ARM. We measured the PyPy interpreter with the JIT enabled and disabled comparing each to CPython Python 2.7.1+ (r271:86832) for ARM. The graph shows the speedup or slowdown of both PyPy versions for the different benchmarks from our benchmark suite normalized to the runtime of CPython. The data used for the graph can be seen below.&lt;br&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="https://2.bp.blogspot.com/-uckc9tOWgnM/TykHMuuGT9I/AAAAAAAAAKg/J8_fC6RS-QA/s1600/graph.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="258" src="https://2.bp.blogspot.com/-uckc9tOWgnM/TykHMuuGT9I/AAAAAAAAAKg/J8_fC6RS-QA/s400/graph.png" width="400"&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br&gt;
The speedup is less than the speedup of 5.2 times we currently  get on x86 on our own benchmark suite (see &lt;a class="reference external" href="https://speed.pypy.org/"&gt;https://speed.pypy.org&lt;/a&gt; for details). There are several possible reasons for this. Comparing the results for the interpreter without the JIT on ARM and x86 suggests that the interpreter generated by PyPy, without the JIT, has a worse performance when compared to CPython that it does on x86. Also it is quite possible that the code we are generating with the JIT is not yet optimal. Also there are some architectural constraints produce some overhead. One of these differences is the handling of constants, most ARM instructions only support 8 bit (that can be shifted) immediate values, larger constants need to be loaded into a register, something that is not necessary on x86.&lt;br&gt;
&lt;br&gt;
&lt;table border="1" class="docutils"&gt;&lt;colgroup&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="40%"&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="32%"&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="28%"&gt;&lt;/colgroup&gt;&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Benchmark&lt;/td&gt;&lt;td&gt;PyPy JIT&lt;/td&gt;&lt;td&gt;PyPy no JIT&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ai&lt;/td&gt;&lt;td&gt;0.484439780047&lt;/td&gt;&lt;td&gt;3.72756749625&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;chaos&lt;/td&gt;&lt;td&gt;0.0807291691934&lt;/td&gt;&lt;td&gt;2.2908692212&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;crypto_pyaes&lt;/td&gt;&lt;td&gt;0.0711114832245&lt;/td&gt;&lt;td&gt;3.30112318509&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;django&lt;/td&gt;&lt;td&gt;0.0977743245519&lt;/td&gt;&lt;td&gt;2.56779947601&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;fannkuch&lt;/td&gt;&lt;td&gt;0.210423735698&lt;/td&gt;&lt;td&gt;2.49163632938&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;float&lt;/td&gt;&lt;td&gt;0.154275334675&lt;/td&gt;&lt;td&gt;2.12053281495&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;go&lt;/td&gt;&lt;td&gt;0.330483034202&lt;/td&gt;&lt;td&gt;5.84628320479&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;html5lib&lt;/td&gt;&lt;td&gt;0.629264389862&lt;/td&gt;&lt;td&gt;3.60333138526&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;meteor-contest&lt;/td&gt;&lt;td&gt;0.984747426912&lt;/td&gt;&lt;td&gt;2.93838610037&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;nbody_modified&lt;/td&gt;&lt;td&gt;0.236969593082&lt;/td&gt;&lt;td&gt;1.40027234936&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;pyflate-fast&lt;/td&gt;&lt;td&gt;0.367447191807&lt;/td&gt;&lt;td&gt;2.72472422146&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;raytrace-simple&lt;/td&gt;&lt;td&gt;0.0290527461437&lt;/td&gt;&lt;td&gt;1.97270054339&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;richards&lt;/td&gt;&lt;td&gt;0.034575573553&lt;/td&gt;&lt;td&gt;3.29767342015&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;slowspitfire&lt;/td&gt;&lt;td&gt;0.786642551908&lt;/td&gt;&lt;td&gt;3.7397367403&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spambayes&lt;/td&gt;&lt;td&gt;0.660324379456&lt;/td&gt;&lt;td&gt;3.29059863111&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spectral-norm&lt;/td&gt;&lt;td&gt;0.063610783731&lt;/td&gt;&lt;td&gt;4.01788986233&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spitfire&lt;/td&gt;&lt;td&gt;0.43617131165&lt;/td&gt;&lt;td&gt;2.72050579076&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spitfire_cstringio&lt;/td&gt;&lt;td&gt;0.255538702134&lt;/td&gt;&lt;td&gt;1.7418593111&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;telco&lt;/td&gt;&lt;td&gt;0.102918930413&lt;/td&gt;&lt;td&gt;3.86388866047&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_iteration&lt;/td&gt;&lt;td&gt;0.122723986805&lt;/td&gt;&lt;td&gt;4.33632475491&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_names&lt;/td&gt;&lt;td&gt;2.42367797135&lt;/td&gt;&lt;td&gt;2.99878698076&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_pb&lt;/td&gt;&lt;td&gt;1.30991837431&lt;/td&gt;&lt;td&gt;4.48877805486&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_tcp&lt;/td&gt;&lt;td&gt;0.927033354055&lt;/td&gt;&lt;td&gt;2.8161624665&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;waf&lt;/td&gt;&lt;td&gt;1.02059811932&lt;/td&gt;&lt;td&gt;1.03793427321&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;div class="section" id="the-next-steps-and-call-for-help"&gt;
&lt;h2&gt;




The next steps and call for help&lt;/h2&gt;
Although there probably still are some remaining issues which have not surfaced yet, the JIT backend for ARM is working. Before we can merge the backend into the main development line there are some things that we would like to do first, in particular it we are looking for a way to run the all PyPy tests to verify that things work on ARM before we can merge.Â AdditionallyÂ there are some other longterm ideas. To do this we are looking for people willing to help, either by contributing to implement the open features or that can help us with hardware to test.&lt;br&gt;
&lt;br&gt;
The incomplete list of open topics:&lt;br&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;We are looking for a better way to translate PyPy for ARM, than the one describe above. I am not sure if there currently is hardware with enough memory to directly translate PyPy on an ARM based system, this would require between 1.5 or 2 Gig of memory. A fully &lt;a class="reference external" href="https://wiki.qemu.org/Main_Page"&gt;QEMU&lt;/a&gt; based approach could also work, instead of Scratchbox2 that uses QEMU under the hood.&lt;/li&gt;
&lt;li&gt;Test the JIT on different hardware.&lt;/li&gt;
&lt;li&gt;Experiment with the JIT settings to find the optimal thresholds for ARM.&lt;/li&gt;
&lt;li&gt;Continuous integration: We are looking for a way to run the PyPy test suite to make sure everything works as expected on ARM, here QEMU also might provide an alternative.&lt;/li&gt;
&lt;li&gt;A long term plan would be to port the backend to ARMv5 ISA and improve the support for systems without a floating point unit. This would require to implement the ISA and create different code paths and improve the instruction selection depending on the target architecture.&lt;/li&gt;
&lt;li&gt;Review of the generated machine code the JIT generates on ARM to see if the instruction selection makes sense for ARM.&lt;/li&gt;
&lt;li&gt;Build a version that runs on Android.&lt;/li&gt;
&lt;li&gt;Improve the tools, i.e. integrate with &lt;a class="reference external" href="https://bitbucket.org/pypy/jitviewer"&gt;jitviewer&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
So if you are interested or willing to help in any way contact us.&lt;/div&gt;</description><category>arm</category><category>jit</category><category>pypy</category><guid>https://www.pypy.org/posts/2012/02/almost-there-pypys-arm-backend_01-3216759488618774525.html</guid><pubDate>Wed, 01 Feb 2012 09:43:00 GMT</pubDate></item><item><title>Benchmarking twisted</title><link>https://www.pypy.org/posts/2010/03/hello-5058108566628405592.html</link><dc:creator>Maciej Fijalkowski</dc:creator><description>&lt;p&gt;Hello.&lt;/p&gt;
&lt;p&gt;I recently did some benchmarking of &lt;a class="reference external" href="https://twistedmatrix.com"&gt;twisted&lt;/a&gt; on top of PyPy. For the very
impatient: &lt;b&gt;PyPy is up to 285% faster than CPython&lt;/b&gt;. For more patient people,
there is a full explanation of what I did and how I performed measurements,
so they can judge themselves.&lt;/p&gt;
&lt;p&gt;The benchmarks are living in &lt;a class="reference external" href="https://code.launchpad.net/~exarkun/+junk/twisted-benchmarks"&gt;twisted-benchmarks&lt;/a&gt; and were mostly written
by &lt;a class="reference external" href="https://jcalderone.livejournal.com/"&gt;Jean Paul Calderone&lt;/a&gt;. Even though he called them "initial exploratory
investigation into a potential direction for future development resulting
in performance oriented metrics guiding the process of optimization and
avoidance of complexity regressions", they're still much much better than
average benchmarks found out there.&lt;/p&gt;
&lt;p&gt;The methodology was to run each benchmark for
quite some time (about 1 minute), measuring number of requests each 5s.
Then I looked at &lt;a class="reference external" href="https://codespeak.net/svn/user/fijal/txt/twisted-data.txt"&gt;dump&lt;/a&gt; of data and subtracted some time it took
for JIT-capable interpreters to warm up (up to 15s), averaging
everything after that. Averages of requests per second are in the table below (the higher the better):&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="19%"&gt;
&lt;col width="16%"&gt;
&lt;col width="31%"&gt;
&lt;col width="34%"&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;benchname&lt;/td&gt;
&lt;td&gt;CPython&lt;/td&gt;
&lt;td&gt;Unladen swallow&lt;/td&gt;
&lt;td&gt;PyPy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;names&lt;/td&gt;
&lt;td style="background-color: red;"&gt;10930&lt;/td&gt;
&lt;td&gt;11940 (9% faster)&lt;/td&gt;
&lt;td style="background-color: #0C0;"&gt;15429 (40% faster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;pb&lt;/td&gt;
&lt;td style="background-color: red;"&gt;1705&lt;/td&gt;
&lt;td&gt;2280 (34% faster)&lt;/td&gt;
&lt;td style="background-color: #0C0;"&gt;3029 (78% faster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;iterations&lt;/td&gt;
&lt;td style="background-color: red;"&gt;75569&lt;/td&gt;
&lt;td&gt;94554 (25% faster)&lt;/td&gt;
&lt;td style="background-color: #0C0;"&gt;291066 (285% faster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;accept&lt;/td&gt;
&lt;td&gt;2176&lt;/td&gt;
&lt;td&gt;2166 (same speed)&lt;/td&gt;
&lt;td&gt;2290 (5% faster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;web&lt;/td&gt;
&lt;td&gt;879&lt;/td&gt;
&lt;td&gt;854 (3% slower)&lt;/td&gt;
&lt;td style="background-color: #0C0;"&gt;1040 (18% faster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;tcp&lt;/td&gt;
&lt;td&gt;105M&lt;/td&gt;
&lt;td style="background-color: #0C0;"&gt;119M (7% faster)&lt;/td&gt;
&lt;td style="background-color: red;"&gt;60M (46% slower)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;To reproduce, run each benchmark with:&lt;/p&gt;
&lt;blockquote&gt;
benchname.py -n 12 -d 5&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;WARNING&lt;/em&gt;: running tcp-based benchmarks that open new connection for each
request (web &amp;amp; accept) can exhaust number of some kernel structures,
limit &lt;strong&gt;n&lt;/strong&gt; or wait until next run if you see drops in request per second.&lt;/p&gt;
&lt;p&gt;The first obvious thing is that various benchmarks are more or less amenable
to speedups by JIT compilation. Accept and tcp getting smallest speedups, if at
all. This is understandable, since JIT is mostly about reducing interpretation
and frame overhead, which is probably not large when it comes to accepting
connections. However, if you actually loop around, doing something, JIT
can give you a lot of speedup.&lt;/p&gt;
&lt;p&gt;The other obvious thing is that &lt;b&gt;PyPy is the fastest python interpreter
here&lt;/b&gt;, almost across-the board (Jython and IronPython won't run twisted),
except for raw tcp throughput. However, speedups can vary and I expect
this to improve after the release, as there are points, where PyPy can
be improved. Regarding raw tcp throughput - this can be a problem for
some applications and we're looking forward to improve this particular
bit.&lt;/p&gt;
&lt;p&gt;The main reason to use twisted for this comparison is a lot of support from
twisted team and JP Calderone in particular, especially when it comes to
providing benchmarks. If some open source project wants to be looked at
by PyPy team, please &lt;b&gt;provide a reasonable set of benchmarks and infrastructure&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;If, however, you're a closed source project fighting with performance problems
of Python, we're providing &lt;b&gt;contracting for investigating opportunities&lt;/b&gt;, how
PyPy and not only PyPy, can speed up your project.&lt;/p&gt;
&lt;p&gt;Cheers,&lt;br&gt;
fijal&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Benchmark descriptions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;em&gt;names&lt;/em&gt; - simple DNS server&lt;/li&gt;
&lt;li&gt;&lt;em&gt;web&lt;/em&gt; - simple http hello world server&lt;/li&gt;
&lt;li&gt;&lt;em&gt;pb&lt;/em&gt; - perspective broker, RPC mechanism for twisted&lt;/li&gt;
&lt;li&gt;&lt;em&gt;iterations&lt;/em&gt; - empty twisted loop&lt;/li&gt;
&lt;li&gt;&lt;em&gt;accept&lt;/em&gt; - number of tcp connections accepted per second&lt;/li&gt;
&lt;li&gt;&lt;em&gt;tcp&lt;/em&gt; - raw socket transfer throughput&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Used interpreters:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;CPython 2.6.2 - as packaged by ubuntu&lt;/li&gt;
&lt;li&gt;Unladen swallow svn trunk, revision 1109&lt;/li&gt;
&lt;li&gt;PyPy svn trunk, revision 71439&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Twisted version used: svn trunk, revision 28580&lt;/p&gt;
&lt;p&gt;Machine: unfortunately 32bit virtual-machine under qemu, running ubuntu karmic,
on top of Quad core intel Q9550 with 6M cache. Courtesy of Michael Schneider.&lt;/p&gt;</description><category>jit</category><guid>https://www.pypy.org/posts/2010/03/hello-5058108566628405592.html</guid><pubDate>Mon, 01 Mar 2010 15:05:00 GMT</pubDate></item><item><title>Some benchmarking</title><link>https://www.pypy.org/posts/2009/11/some-benchmarking-9211261260383281459.html</link><dc:creator>Maciej Fijalkowski</dc:creator><description>&lt;p&gt;Hello.
&lt;/p&gt;&lt;p&gt;
Recently, thanks to the surprisingly helpful Unhelpful, also known as Andrew Mahone,
we have a decent, if slightly arbitrary, set of performances graphs.
It contains a couple of benchmarks already
seen on this blog as well as some taken from &lt;a href="https://shootout.alioth.debian.org/"&gt;The Great Computer
Language Benchmarks Game&lt;/a&gt;. These benchmarks don't even try to represent "real applications"
as they're mostly small algorithmic benchmarks. Interpreters used:
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
PyPy trunk, revision 69331 with --translation-backendopt-storesink, which is
now on by default
&lt;/li&gt;
&lt;li&gt;
Unladen swallow trunk, r900
&lt;/li&gt;
&lt;li&gt;CPython 2.6.2 release&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Here are the graphs; the benchmarks and the runner script are &lt;a href="https://www.looking-glass.us/~chshrcat/python-benchmarks/"&gt;available&lt;/a&gt;
&lt;/p&gt;

&lt;a href="https://1.bp.blogspot.com/_5R1EBmwBBTs/SwRteBYi01I/AAAAAAAAAOU/BU3h_VUfmH0/s1600/result.png"&gt;&lt;img alt="" border="0" id="BLOGGER_PHOTO_ID_5405565815286322002" src="https://1.bp.blogspot.com/_5R1EBmwBBTs/SwRteBYi01I/AAAAAAAAAOU/BU3h_VUfmH0/s400/result.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 300px;"&gt;&lt;/a&gt;

And zoomed in for all benchmarks except binary-trees and fannkuch.
&lt;a href="https://1.bp.blogspot.com/_5R1EBmwBBTs/SwRtnxYPJII/AAAAAAAAAOc/JAvE6pYaEjI/s1600/result2.png"&gt;&lt;img alt="" border="0" id="BLOGGER_PHOTO_ID_5405565982788756610" src="https://1.bp.blogspot.com/_5R1EBmwBBTs/SwRtnxYPJII/AAAAAAAAAOc/JAvE6pYaEjI/s400/result2.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 300px;"&gt;&lt;/a&gt;

&lt;p&gt;
As we can see, PyPy is generally somewhere between the same speed
as CPython to 50x faster (f1int). The places where we're the same
speed as CPython are places where we know we have problems - for example generators are
not sped up by the JIT and they require some work (although not as much by far
as generators &amp;amp; Psyco :-). The glaring inefficiency is in the regex-dna benchmark.
This one clearly demonstrates that our regular expression engine is really,
really, bad and urgently requires attention.
&lt;/p&gt;
&lt;p&gt;
The cool thing here is, that although these benchmarks might not represent
typical python applications, they're not uninteresting. They show
that algorithmic code does not need to be far slower in Python than in C,
so using PyPy one need not worry about algorithmic code being dramatically
slow. As many readers would agree, that kills yet another usage of C in our
lives :-)
&lt;/p&gt;
Cheers,&lt;br&gt;
fijal</description><category>jit</category><guid>https://www.pypy.org/posts/2009/11/some-benchmarking-9211261260383281459.html</guid><pubDate>Wed, 18 Nov 2009 21:53:00 GMT</pubDate></item><item><title>Logging and nice graphs</title><link>https://www.pypy.org/posts/2009/11/hi-all-this-week-i-worked-on-improving-6515977421244851229.html</link><dc:creator>Armin Rigo</dc:creator><description>&lt;p&gt;Hi all,&lt;/p&gt;

&lt;p&gt;This week I worked on improving the system we use for logging.  Well, it was not really a "system" but rather a pile of hacks to measure in custom ways timings and counts and display them.  So now, we have a system :-)&lt;/p&gt;

&lt;p&gt;The system in question was integrated in the code for the GC and the JIT, which are two independent components as far as the source is concerned.  However, we can now display a unified view.  Here is for example pypy-c-jit running pystone for (only) 5000 iterations:&lt;/p&gt;

&lt;a href="https://codespeak.net/~arigo/raw/pystone.png"&gt;&lt;img alt="" border="0" id="BLOGGER_PHOTO_ID_5399212353093417154" src="https://3.bp.blogspot.com/_Sg3NUJ-JhgU/Su3bB2UIuMI/AAAAAAAAAAM/2-Vf5zry_4Q/s320/pystone.png" style="cursor: pointer; cursor: hand; width: 320px; height: 51px;"&gt;&lt;/a&gt;

&lt;p&gt;The top long bar represents time.  The bottom shows two summaries of the total time taken by the various components, and also plays the role of a legend to understand the colors at the top.  Shades of red are the GC, shades of green are the JIT.&lt;/p&gt;

&lt;p&gt;Here is another picture, this time on pypy-c-jit running 10 iterations of richards:&lt;/p&gt;

&lt;a href="https://codespeak.net/~arigo/raw/richards.png"&gt;&lt;img alt="" border="0" id="BLOGGER_PHOTO_ID_5399212511216555922" src="https://4.bp.blogspot.com/_Sg3NUJ-JhgU/Su3bLDXoV5I/AAAAAAAAAAU/VPxEP_hqrFk/s320/richards.png" style="cursor: pointer; cursor: hand; width: 320px; height: 19px;"&gt;&lt;/a&gt;

&lt;p&gt;We have to look more closely at various examples, but a few things immediately show up.  One thing is that the GC is put under large pressure by the jit-tracing, jit-optimize and (to a lesser extent) the jit-backend components.  So large in fact that the GC takes at least 60-70% of the time there.  We will have to do something about it at some point.  The other thing is that on richards (and it's likely generally the case), the jit-blackhole component takes a lot of time.  "Blackholing" is the operation of recovering from a guard failure in the generated assembler, and falling back to the interpreter.  So this is also something we will need to improve.&lt;/p&gt;

&lt;p&gt;That's it!  The images were generated with the following commands:&lt;/p&gt;

&lt;pre&gt;PYPYLOG=/tmp/log pypy-c-jit richards.py
python pypy/tool/logparser.py draw-time /tmp/log --mainwidth=8000 --output=filename.png&lt;/pre&gt;

&lt;i&gt;&lt;b&gt;EDIT:&lt;/b&gt; nowadays the command-line has changed to:&lt;/i&gt;&lt;pre&gt;python rpython/tool/logparser.py draw-time /tmp/log --mainwidth=8000 filename.png&lt;/pre&gt;</description><category>jit</category><guid>https://www.pypy.org/posts/2009/11/hi-all-this-week-i-worked-on-improving-6515977421244851229.html</guid><pubDate>Sun, 01 Nov 2009 18:59:00 GMT</pubDate></item><item><title>First pypy-cli-jit benchmarks</title><link>https://www.pypy.org/posts/2009/10/first-pypy-cli-jit-benchmarks-6698484455072589492.html</link><dc:creator>Antonio Cuni</dc:creator><description>&lt;p&gt;As the readers of this blog &lt;a class="reference external" href="https://www.pypy.org/posts/2008/11/porting-jit-to-cli-part-1-8712941279840156635.html"&gt;already know&lt;/a&gt;, I've been working on porting the
JIT to CLI/.NET for the last months.  Now that it's finally possible to get a
working pypy-cli-jit, it's time to do some benchmarks.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; as usual, all of this has to be considered to be a alpha version:
don't be surprised if you get a crash when trying to run pypy-cli-jit.  Of
course, things are improving very quickly so it should become more and more
stable as days pass.&lt;/p&gt;
&lt;p&gt;For this time, I decided to run four benchmarks. Note that for all of them we
run the main function once in advance, to let the JIT recognize the hot
loops and emitting the corresponding code.  Thus, the results reported do
&lt;strong&gt;not&lt;/strong&gt; include the time spent by the JIT compiler itself, but give a good
measure of how good is the code generated by the JIT.  At this point in time,
I know that the CLI JIT backend spends way too much time compiling stuff, but
this issue will be fixed soon.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://paste.pocoo.org/show/145050/"&gt;f1.py&lt;/a&gt;: this is the classic PyPy JIT benchmark. It is just a function
that does some computational intensive work with integers.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://paste.pocoo.org/show/143243/"&gt;floatdemo.py&lt;/a&gt;: this is the same benchmark involving floating point
numbers that have already been described in a previous &lt;a class="reference external" href="https://www.pypy.org/posts/2009/10/pypys-jit-now-supports-floats-7003493323596806737.html"&gt;blog post&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://paste.pocoo.org/show/145051/"&gt;oodemo.py&lt;/a&gt;: this is just a microbenchmark doing object oriented stuff
such as method calls and attribute access.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://paste.pocoo.org/show/145052/"&gt;richards2.py&lt;/a&gt;: a modified version of the classic richards.py, with a
warmup call before starting the real benchmark.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;The benchmarks were run on a Windows machine with an Intel Pentium Dual Core
E5200 2.5GHz and 2GB RAM, both with .NET (CLR 2.0) and Mono 2.4.2.3.&lt;/p&gt;
&lt;p&gt;Because of a known &lt;a class="reference external" href="https://bugzilla.novell.com/show_bug.cgi?id=474718"&gt;mono bug&lt;/a&gt;, if you use a version older than 2.1 you need
to pass the option &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O=-branch&lt;/span&gt;&lt;/tt&gt; to mono when running pypy-cli-jit, else it
will just loop forever.&lt;/p&gt;
&lt;p&gt;For comparison, we also run the same benchmarks with IronPython 2.0.1 and
IronPython 2.6rc1.  Note that IronPython 2.6rc1 does not work with mono.&lt;/p&gt;
&lt;p&gt;So, here are the results (expressed in seconds) with Microsoft CLR:&lt;/p&gt;
&lt;blockquote&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="15%"&gt;
&lt;col width="20%"&gt;
&lt;col width="15%"&gt;
&lt;col width="12%"&gt;
&lt;col width="20%"&gt;
&lt;col width="18%"&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Benchmark&lt;/th&gt;
&lt;th class="head"&gt;pypy-cli-jit&lt;/th&gt;
&lt;th class="head"&gt;ipy 2.0.1&lt;/th&gt;
&lt;th class="head"&gt;ipy 2.6&lt;/th&gt;
&lt;th class="head"&gt;ipy2.01/ pypy&lt;/th&gt;
&lt;th class="head"&gt;ipy2.6/ pypy&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;f1&lt;/td&gt;
&lt;td&gt;0.028&lt;/td&gt;
&lt;td&gt;0.145&lt;/td&gt;
&lt;td&gt;0.136&lt;/td&gt;
&lt;td&gt;5.18x&lt;/td&gt;
&lt;td&gt;4.85x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;floatdemo&lt;/td&gt;
&lt;td&gt;0.671&lt;/td&gt;
&lt;td&gt;0.765&lt;/td&gt;
&lt;td&gt;0.812&lt;/td&gt;
&lt;td&gt;1.14x&lt;/td&gt;
&lt;td&gt;1.21x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;oodemo&lt;/td&gt;
&lt;td&gt;1.25&lt;/td&gt;
&lt;td&gt;4.278&lt;/td&gt;
&lt;td&gt;3.816&lt;/td&gt;
&lt;td&gt;3.42x&lt;/td&gt;
&lt;td&gt;3.05x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;richards2&lt;/td&gt;
&lt;td&gt;1228&lt;/td&gt;
&lt;td&gt;442&lt;/td&gt;
&lt;td&gt;670&lt;/td&gt;
&lt;td&gt;0.36x&lt;/td&gt;
&lt;td&gt;0.54x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;p&gt;And with Mono:&lt;/p&gt;
&lt;blockquote&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="21%"&gt;
&lt;col width="29%"&gt;
&lt;col width="21%"&gt;
&lt;col width="29%"&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Benchmark&lt;/th&gt;
&lt;th class="head"&gt;pypy-cli-jit&lt;/th&gt;
&lt;th class="head"&gt;ipy 2.0.1&lt;/th&gt;
&lt;th class="head"&gt;ipy2.01/ pypy&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;f1&lt;/td&gt;
&lt;td&gt;0.042&lt;/td&gt;
&lt;td&gt;0.695&lt;/td&gt;
&lt;td&gt;16.54x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;floatdemo&lt;/td&gt;
&lt;td&gt;0.781&lt;/td&gt;
&lt;td&gt;1.218&lt;/td&gt;
&lt;td&gt;1.55x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;oodemo&lt;/td&gt;
&lt;td&gt;1.703&lt;/td&gt;
&lt;td&gt;9.501&lt;/td&gt;
&lt;td&gt;5.31x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;richards2&lt;/td&gt;
&lt;td&gt;720&lt;/td&gt;
&lt;td&gt;862&lt;/td&gt;
&lt;td&gt;1.20x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;p&gt;These results are very interesting: under the CLR, we are between 5x faster
and 3x slower than IronPython 2.0.1, and between 4.8x faster and 1.8x slower
than IronPython 2.6.  On the other hand, on mono we are consistently faster
than IronPython, up to 16x.  Also, it is also interesting to note that
pypy-cli runs faster on CLR than mono for all benchmarks except richards2.&lt;/p&gt;
&lt;p&gt;I've not investigated yet, but I think that the culprit is the terrible
behaviour of tail calls on CLR: as I already wrote in &lt;a class="reference external" href="https://www.pypy.org/posts/2008/12/porting-jit-to-cli-part-3-3519327524638923621.html"&gt;another blog post&lt;/a&gt;,
tail calls are ~10x slower than normal calls on CLR, while being only ~2x
slower than normal calls on mono.  richads2 is probably the benchmark that
makes most use of tail calls, thus explaining why we have a much better result
on mono than CLR.&lt;/p&gt;
&lt;p&gt;The next step is probably to find an alternative implementation that does not
use tail calls: this probably will also improve the time spent by the JIT
compiler itself, which is not reported in the numbers above but that so far it
is surely too high to be acceptable. Stay tuned.&lt;/p&gt;</description><category>cli</category><category>jit</category><category>pypy</category><guid>https://www.pypy.org/posts/2009/10/first-pypy-cli-jit-benchmarks-6698484455072589492.html</guid><pubDate>Thu, 15 Oct 2009 13:36:00 GMT</pubDate></item></channel></rss>