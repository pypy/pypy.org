<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts about releasecffi)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/categories/releasecffi.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Mon, 07 Jul 2025 11:01:31 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>CFFI release 0.3</title><link>https://www.pypy.org/posts/2012/08/cffi-release-03-4740491796308953732.html</link><dc:creator>Armin Rigo</dc:creator><description>&lt;p&gt;Hi everybody,&lt;/p&gt;
&lt;p&gt;We released &lt;a class="reference external" href="https://cffi.readthedocs.org"&gt;CFFI 0.3&lt;/a&gt;.  This is the first release that supports more
than CPython 2.x &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;:-)&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;CPython 2.6, 2.7, and &lt;strong&gt;3.x&lt;/strong&gt; are supported (3.3 definitely, but maybe 3.2 or earlier too)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PyPy trunk&lt;/strong&gt; is supported.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In more details, the main news are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;support for PyPy.  You need to get a trunk version of PyPy, which
comes with the built-in module &lt;tt class="docutils literal"&gt;_cffi_backend&lt;/tt&gt; to use with the CFFI
release.  For testing, you can download the &lt;a class="reference external" href="https://buildbot.pypy.org/nightly/trunk/"&gt;Linux 32/64 versions of
PyPy trunk&lt;/a&gt;.  The OS/X and Windows versions of &lt;tt class="docutils literal"&gt;_cffi_backend&lt;/tt&gt;
are not tested at all so far, so probably don't work yet.&lt;/li&gt;
&lt;li&gt;support for Python 3.  It is unknown which exact version is
required; probably 3.2 or even earlier, but we need 3.3 to run the
tests.  The 3.x version is not a separate source; it runs out of the same sources.  Thanks Amaury for starting this port.&lt;/li&gt;
&lt;li&gt;the main change in the API is that you need to use &lt;tt class="docutils literal"&gt;ffi.string(cdata)&lt;/tt&gt;
instead of &lt;tt class="docutils literal"&gt;str(cdata)&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;unicode(cdata)&lt;/tt&gt;.  The motivation for this
change was the Python 3 compatibility.  If your Python 2 code used to
contain &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;str(&amp;lt;cdata&lt;/span&gt; 'char &lt;span class="pre"&gt;*'&amp;gt;)&lt;/span&gt;&lt;/tt&gt;, it would interpret the memory content
as a null-terminated string; but on Python 3 it would just return a
different string, namely &lt;tt class="docutils literal"&gt;"&amp;lt;cdata 'char &lt;span class="pre"&gt;*'&amp;gt;"&lt;/span&gt;&lt;/tt&gt;, and proceed without even
a crash, which is bad.  So ffi.string() solves it by always returning
the memory content as an 8-bit string (which is a str in Python 2 and
a bytes in Python 3).&lt;/li&gt;
&lt;li&gt;other minor API changes are documented at
&lt;a class="reference external" href="https://cffi.readthedocs.org/"&gt;https://cffi.readthedocs.org/&lt;/a&gt; (grep for &lt;tt class="docutils literal"&gt;version 0.3&lt;/tt&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Upcoming work, to be done before release 1.0:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;expose to the user the module &lt;tt class="docutils literal"&gt;cffi.model&lt;/tt&gt; in a possibly refactored
way, for people that don't like (or for some reason can't easily use)
strings containing snippets of C declarations.  We are thinking about
refactoring it in such a way that it has a ctypes-compatible
interface, to ease porting existing code from ctypes to cffi.  Note
that this would concern only the C type and function declarations, not
all the rest of ctypes.&lt;/li&gt;
&lt;li&gt;CFFI 1.0 will also have a corresponding PyPy release.  We are thinking
about calling it PyPy 2.0 and including the whole of CFFI (instead of
just the &lt;tt class="docutils literal"&gt;_cffi_backend&lt;/tt&gt; module like now).  In other words it will
support CFFI out of the box --- we want to push forward usage of CFFI
in PyPy &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;:-)&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cheers,&lt;/p&gt;
&lt;p&gt;Armin Rigo and Maciej Fijałkowski&lt;/p&gt;</description><category>releasecffi</category><guid>https://www.pypy.org/posts/2012/08/cffi-release-03-4740491796308953732.html</guid><pubDate>Mon, 13 Aug 2012 19:59:00 GMT</pubDate></item><item><title>CFFI release 0.2.1</title><link>https://www.pypy.org/posts/2012/07/cffi-release-02-4800000428934604295.html</link><dc:creator>Armin Rigo</dc:creator><description>&lt;p&gt;Hi everybody,&lt;/p&gt;&lt;p&gt;We released &lt;a class="reference" href="https://cffi.readthedocs.org"&gt;CFFI 0.2.1&lt;/a&gt; (expected to be 1.0 soon).  CFFI is a way to call C from Python.&lt;/p&gt;&lt;p&gt;&lt;b&gt;EDIT:&lt;/b&gt; Win32 was broken in 0.2.  Fixed.&lt;/p&gt;&lt;p&gt;This release is only for CPython 2.6 or 2.7.  PyPy support is coming in&lt;br&gt;
the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ffi-backend&lt;/span&gt;&lt;/tt&gt; branch, but not finished yet.  CPython 3.x would be&lt;br&gt;
easy but requires the help of someone.&lt;/p&gt;&lt;p&gt;The package is available &lt;a class="reference" href="https://foss.heptapod.net/cffi/cffi"&gt;on bitbucket&lt;/a&gt; as well as &lt;a class="reference" href="https://cffi.readthedocs.org"&gt;documented&lt;/a&gt;. You&lt;br&gt;
can also install it straight from the &lt;a href="https://pypi.python.org/pypi/cffi"&gt;python package index&lt;/a&gt;: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;pip install cffi&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;&lt;ul class="simple"&gt;&lt;li&gt;Contains numerous small changes and support for more C-isms.&lt;/li&gt;
&lt;li&gt;The biggest news is the support for &lt;a class="reference" href="https://cffi.readthedocs.org/en/latest/index.html#distributing-modules-using-cffi"&gt;installing packages&lt;/a&gt; that use&lt;br&gt;
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ffi.verify()&lt;/span&gt;&lt;/tt&gt; on machines without a C compiler.  Arguably, this&lt;br&gt;
lifts the last serious restriction for people to use CFFI.&lt;/li&gt;
&lt;li&gt;Partial list of smaller changes:&lt;ul&gt;&lt;li&gt;mappings between 'wchar_t' and Python unicodes&lt;/li&gt;
&lt;li&gt;the introduction of ffi.NULL&lt;/li&gt;
&lt;li&gt;a possibly clearer API for &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ffi.new()&lt;/span&gt;&lt;/tt&gt;: e.g. to allocate a single &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;int&lt;/span&gt;&lt;/tt&gt; and obtain a pointer to it, use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ffi.new("int *")&lt;/span&gt;&lt;/tt&gt; instead of the old&lt;br&gt;
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ffi.new("int")&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;and of course a plethora of smaller bug fixes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CFFI uses &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;pkg-config&lt;/span&gt;&lt;/tt&gt; to install itself if available.  This helps&lt;br&gt;
locate &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;libffi&lt;/span&gt;&lt;/tt&gt; on modern Linuxes.  Mac OS/X support is available too&lt;br&gt;
(see the detailed &lt;a class="reference" href="https://cffi.readthedocs.org/en/latest/index.html#macos-10-6"&gt;installation instructions&lt;/a&gt;).  Win32 should work out&lt;br&gt;
of the box.  Win64 has not been really tested yet.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Cheers,&lt;br&gt;
Armin Rigo and Maciej Fijałkowski&lt;/p&gt;</description><category>releasecffi</category><guid>https://www.pypy.org/posts/2012/07/cffi-release-02-4800000428934604295.html</guid><pubDate>Thu, 26 Jul 2012 17:45:00 GMT</pubDate></item><item><title>Release 0.1 of CFFI</title><link>https://www.pypy.org/posts/2012/06/release-01-of-cffi-4760622823232463868.html</link><dc:creator>Maciej Fijalkowski</dc:creator><description>&lt;div dir="ltr" style="text-align: left;"&gt;&lt;p&gt;Hi.&lt;/p&gt;&lt;p&gt;We're pleased to announce the first public release, 0.1 of CFFI, a way to call C from Python.&lt;br&gt;
(This release does not support PyPy yet --- but we announce it here as it is planned for the&lt;br&gt;
next release :-)&lt;/p&gt;&lt;p&gt;The package is available &lt;a class="reference external" href="https://foss.heptapod.net/cffi/cffi"&gt;on bitbucket&lt;/a&gt; as well as &lt;a class="reference external" href="https://cffi.readthedocs.org"&gt;documented&lt;/a&gt;. You can also install it&lt;br&gt;
straight from the python package index (pip).&lt;/p&gt;&lt;p&gt;The aim of this project is to provide a convenient and reliable way of calling C code from Python.&lt;br&gt;
The interface is based on &lt;a class="reference external" href="https://luajit.org/ext_ffi.html"&gt;LuaJIT's FFI&lt;/a&gt; and follows a few principles:&lt;/p&gt;&lt;ul class="simple"&gt;&lt;li&gt;The goal is to call C code from Python.  You should be able to do so&lt;br&gt;
without learning a 3rd language: every alternative requires you to learn&lt;br&gt;
their own language (&lt;a class="reference external" href="https://www.cython.org"&gt;Cython&lt;/a&gt;, &lt;a class="reference external" href="https://www.swig.org/"&gt;SWIG&lt;/a&gt;) or API (&lt;a class="reference external" href="https://docs.python.org/library/ctypes.html"&gt;ctypes&lt;/a&gt;).  So we tried to&lt;br&gt;
assume that you know Python and C and minimize the extra bits of API that&lt;br&gt;
you need to learn.&lt;/li&gt;
&lt;li&gt;Keep all the Python-related logic in Python so that you don't need to&lt;br&gt;
write much C code (unlike &lt;a class="reference external" href="https://docs.python.org/extending/extending.html"&gt;CPython native C extensions&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Work either at the level of the ABI (Application Binary Interface)&lt;br&gt;
or the API (Application Programming Interface).  Usually, C&lt;br&gt;
libraries have a specified C API but often not an ABI (e.g. they may&lt;br&gt;
document a "struct" as having at least these fields, but maybe more).&lt;br&gt;
(&lt;a class="reference external" href="https://docs.python.org/library/ctypes.html"&gt;ctypes&lt;/a&gt; works at the ABI level, whereas Cython or &lt;a class="reference external" href="https://docs.python.org/extending/extending.html"&gt;native C extensions&lt;/a&gt;&lt;br&gt;
work at the API level.)&lt;/li&gt;
&lt;li&gt;We try to be complete.  For now some C99 constructs are not supported,&lt;br&gt;
but all C89 should be, including macros (and including macro "abuses",&lt;br&gt;
which you can manually wrap in saner-looking C functions).&lt;/li&gt;
&lt;li&gt;We attempt to support both PyPy and CPython (although PyPy support is not&lt;br&gt;
complete yet) with a reasonable path for other Python implementations like&lt;br&gt;
IronPython and Jython.&lt;/li&gt;
&lt;li&gt;Note that this project is &lt;strong&gt;not&lt;/strong&gt; about embedding executable C code in&lt;br&gt;
Python, unlike &lt;a class="reference external" href="https://www.scipy.org/Weave"&gt;Weave&lt;/a&gt;.  This is about calling existing C libraries&lt;br&gt;
from Python.&lt;/li&gt;
&lt;/ul&gt;&lt;div class="section" id="status-of-the-project"&gt;&lt;h3&gt;Status of the project&lt;/h3&gt;&lt;p&gt;Consider this as a beta release. Creating CPython extensions is fully supported and the API should&lt;br&gt;
be relatively stable; however, minor adjustements of the API are possible.&lt;/p&gt;&lt;p&gt;PyPy support is not yet done and this is a goal for the next release. There are vague plans to make this the&lt;br&gt;
preferred way to call C from Python that can reliably work between PyPy and CPython.&lt;/p&gt;&lt;p&gt;Right now CFFI's verify() requires a C compiler and header files to be available at run-time.&lt;br&gt;
This limitation will be lifted in the near future and it'll contain a way to cache the resulting binary.&lt;/p&gt;&lt;p&gt;Cheers,&lt;br&gt;
&lt;br&gt;
Armin Rigo and Maciej Fijałkowski&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><category>releasecffi</category><guid>https://www.pypy.org/posts/2012/06/release-01-of-cffi-4760622823232463868.html</guid><pubDate>Mon, 18 Jun 2012 12:59:00 GMT</pubDate></item></channel></rss>