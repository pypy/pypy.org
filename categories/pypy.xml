<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts about pypy)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/categories/pypy.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Mon, 07 Jul 2025 11:01:31 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>A new chapter for PyPy</title><link>https://www.pypy.org/posts/2020/08/a-new-chapter-for-pypy-8388322709667328389.html</link><dc:creator>hodgestar</dc:creator><description>&lt;p&gt;&lt;i&gt;PyPy winds down its membership in the Software Freedom Conservancy&lt;/i&gt;&lt;/p&gt;

&lt;h1&gt;Conservancy and PyPy's great work together&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://pypy.org/"&gt;PyPy&lt;/a&gt; joined &lt;a href="https://sfconservancy.org/"&gt;Conservancy&lt;/a&gt; in
the &lt;a href="https://sfconservancy.org/blog/2011/jan/02/oct-dec-2010/"&gt;second half of 2010&lt;/a&gt;, shortly after the release of
PyPy 1.2, the first version to contain a fully functional JIT. &lt;a href="https://lwn.net/Articles/550427/"&gt;In 2013&lt;/a&gt;, PyPy
started supporting ARM, bringing its just-in-time speediness to many more devices and began working toward supporting NumPy to help
scientists crunch their numbers faster. Together, PyPy and Conservancy ran successful fundraising drives and facilitated payment
and oversight for &lt;a href="https://sfconservancy.org/blog/2016/dec/01/pypy-2016/"&gt;contractors and code sprints&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Conservancy supported PyPy's impressive growth as it expanded support for
different hardware platforms, greatly improved the performance of C extensions,
and added support for Python 3 as the language itself evolved.&lt;/p&gt;

&lt;h1&gt;The road ahead&lt;/h1&gt;
  
&lt;p&gt;Conservancy provides a fiscal and organizational home for projects that find the
freedoms and guardrails that come along with a charitable home advantageous for
their community goals. While this framework was a great fit for the early PyPy
community, times change and all good things must come to an end.&lt;/p&gt;

&lt;p&gt;PyPy will remain a free and open source project, but the community's structure
and organizational underpinnings will be changing and the PyPy community will be
exploring options outside of the charitable realm for its next phase of growth
("charitable" in the legal sense -- PyPy will remain a community project).&lt;/p&gt;

&lt;p&gt;During the last year PyPy and Conservancy have worked together to properly
utilise the generous donations made by stalwart PyPy enthusiats over the years
and to wrap up PyPy's remaining charitable obligations. PyPy is grateful for
the Conservancy's help in shepherding the project toward its next chapter.&lt;/p&gt;

&lt;h1&gt;Thank yous&lt;/h1&gt;&lt;p&gt;From Conservancy: &lt;br&gt;&lt;/p&gt;&lt;p style="text-align: left;"&gt;&lt;/p&gt;&lt;blockquote&gt;"We are happy that Conservancy was able to help PyPy bring important software
for the public good during a critical time in its history. We wish the
community well and look forward to seeing it develop and succeed in new ways." &lt;br&gt;&lt;/blockquote&gt;&lt;blockquote&gt;— Karen Sandler, Conservancy's Executive Director&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;From PyPy:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div style="text-align: left;"&gt;&lt;div style="text-align: left;"&gt;&lt;blockquote&gt;&lt;p&gt;"PyPy would like to thank Conservancy for their decade long support in
building the community and wishes Conservancy continued success in their
journey promoting, improving, developing and defending free and open source
sofware." &lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p style="text-align: left;"&gt;— Simon Cross &amp;amp; Carl Friedrich Bolz-Tereick, on behalf of PyPy.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;

&lt;h1&gt;About&lt;/h1&gt;

&lt;p&gt;&lt;a class="reference external" href="https://pypy.org/"&gt;PyPy&lt;/a&gt; is a multi-layer python interpreter with a built-in JIT compiler that runs
Python quickly across different computing environments.
&lt;a class="reference external" href="https://sfconservancy.org/"&gt;Software Freedom Conservancy&lt;/a&gt; (Conservancy) is a charity that provides a home
to over forty free and open source software projects.&lt;/p&gt;</description><category>pypy</category><guid>https://www.pypy.org/posts/2020/08/a-new-chapter-for-pypy-8388322709667328389.html</guid><pubDate>Wed, 12 Aug 2020 19:00:00 GMT</pubDate></item><item><title>Leysin 2020 Sprint Report</title><link>https://www.pypy.org/posts/2020/03/leysin-2020-sprint-report-764567777353955897.html</link><dc:creator>hodgestar</dc:creator><description>&lt;p&gt;At the end of February ten of us gathered in Leysin, Switzerland to work on&lt;br&gt;
a variety of topics including &lt;a class="reference external" href="https://github.com/pyhandle/hpy/"&gt;HPy&lt;/a&gt;, &lt;a class="reference external" href="https://buildbot.pypy.org/summary?branch=py3.7"&gt;PyPy Python 3.7&lt;/a&gt; support and the PyPy&lt;br&gt;
migration to &lt;a class="reference external" href="https://foss.heptapod.net/pypy/"&gt;Heptapod&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;
&lt;/p&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="https://1.bp.blogspot.com/-PIs_hVhn3RY/XnFDceuihNI/AAAAAAAAbRg/LKMOMWxeFw4jhcwqy8jx7iKzKE01fbfxQCEwYBhgL/s1600/2020_leysin_sprint_attendees.jpg" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="180" src="https://1.bp.blogspot.com/-PIs_hVhn3RY/XnFDceuihNI/AAAAAAAAbRg/LKMOMWxeFw4jhcwqy8jx7iKzKE01fbfxQCEwYBhgL/s320/2020_leysin_sprint_attendees.jpg" width="320"&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br&gt;
We had a fun and productive week. The snow was beautiful. There was skiing&lt;br&gt;
and lunch at the top of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Berneuse"&gt;Berneuse&lt;/a&gt;, cooking together, some late nights at&lt;br&gt;
the pub next door, some even later nights coding, and of course the&lt;br&gt;
obligatory cheese fondue outing.&lt;br&gt;
&lt;br&gt;
There were a few of us participating in a PyPy sprint for the first time&lt;br&gt;
and a few familiar faces who had attended many sprints. Many different&lt;br&gt;
projects were represented including PyPy, &lt;a class="reference external" href="https://github.com/pyhandle/hpy/"&gt;HPy&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/graalvm/graalpython"&gt;GraalPython&lt;/a&gt;,&lt;br&gt;
&lt;a class="reference external" href="https://foss.heptapod.net/pypy/"&gt;Heptapod&lt;/a&gt;, and &lt;a class="reference external" href="https://github.com/dgrunwald/rust-cpython"&gt;rust-cpython&lt;/a&gt;. The atmosphere was relaxed and welcoming, so if&lt;br&gt;
you're thinking of attending the next one -- please do!&lt;br&gt;
&lt;br&gt;
Topics worked on:&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;
HPy&lt;/h2&gt;
HPy is a new project to design and implement a better API for extending&lt;br&gt;
Python in C. If you're unfamiliar with it you can read more about it at&lt;br&gt;
&lt;a class="reference external" href="https://github.com/pyhandle/hpy/"&gt;HPy&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;
A lot of attention was devoted to the Big HPy Design Discussion which&lt;br&gt;
took up two full mornings. So much was decided that this will likely&lt;br&gt;
get its own detailed write-up, but bigger topics included:&lt;br&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;the HPy GetAttr, SetAttr, GetItem and SetItem methods,&lt;/li&gt;
&lt;li&gt;HPy_FromVoidP and HPy_AsVoidP for passing HPy handles to C functions&lt;br&gt;
that pass void* pointers to callbacks,&lt;/li&gt;
&lt;li&gt;avoiding having va_args as part of the ABI,&lt;/li&gt;
&lt;li&gt;exception handling,&lt;/li&gt;
&lt;li&gt;support for creating custom types.&lt;/li&gt;
&lt;/ul&gt;
Quite a few things got worked on too:&lt;br&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;implemented support for writing methods that take keyword arguments with&lt;br&gt;
HPy_METH_KEYWORDS,&lt;/li&gt;
&lt;li&gt;implemented HPy_GetAttr, HPy_SetAttr, HPy_GetItem, and HPy_SetItem,&lt;/li&gt;
&lt;li&gt;started implementing support for adding custom types,&lt;/li&gt;
&lt;li&gt;started implementing dumping JSON objects in ultrajson-hpy,&lt;/li&gt;
&lt;li&gt;refactored the PyPy GIL to improve the interaction between HPy and&lt;br&gt;
PyPy's cpyext,&lt;/li&gt;
&lt;li&gt;experimented with adding HPy support to rust-cpython.&lt;/li&gt;
&lt;/ul&gt;
And there was some discussion of the next steps of the HPy initiative&lt;br&gt;
including writing documentation, setting up websites and funding, and&lt;br&gt;
possibly organising another HPy gathering later in the year.&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;
PyPy&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Georges gave a presentation on the Heptapod topic and branch workflows&lt;br&gt;
and showed everyone how to use hg-evolve.&lt;/li&gt;
&lt;li&gt;Work was done on improving the PyPy CI buildbot post the move to&lt;br&gt;
heptapod, including a light-weight pre-merge CI and restricting&lt;br&gt;
when the full CI is run to only branch commits.&lt;/li&gt;
&lt;li&gt;A lot of work was done improving the -D tests. &lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2&gt;
Miscellaneous&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Armin demoed VRSketch and NaN Industries in VR, including an implementation&lt;br&gt;
of the Game of Life within NaN Industries!&lt;/li&gt;
&lt;li&gt;Skiing!&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2&gt;
Aftermath&lt;/h2&gt;
Immediately after the sprint large parts of Europe and the world were&lt;br&gt;
hit by the COVID-19 epidemic. It was good to spend time together before&lt;br&gt;
travelling ceased to be a sensible idea and many gatherings were cancelled.&lt;br&gt;
&lt;br&gt;
Keep safe out there everyone.&lt;br&gt;
&lt;br&gt;
The HPy &amp;amp; PyPy Team &amp;amp; Friends&lt;br&gt;
&lt;br&gt;
&lt;i&gt;In joke for those who attended the sprint: Please don't replace this blog post&lt;br&gt;
with its Swedish translation (or indeed a translation to any other language :).&lt;/i&gt;</description><category>cpyext</category><category>CPython</category><category>GraalPython</category><category>Heptapod</category><category>hpy</category><category>pypy</category><category>pypy3</category><guid>https://www.pypy.org/posts/2020/03/leysin-2020-sprint-report-764567777353955897.html</guid><pubDate>Tue, 17 Mar 2020 21:57:00 GMT</pubDate></item><item><title>Almost There - PyPy's ARM Backend</title><link>https://www.pypy.org/posts/2012/02/almost-there-pypys-arm-backend_01-3216759488618774525.html</link><dc:creator>David Schneider</dc:creator><description>&lt;div style="text-align: left;"&gt;
In this post I want to give an update on the status of the ARM backend for PyPy's JIT and describe some of the issues and details of the backend.&lt;/div&gt;
&lt;div class="section" id="current-status"&gt;
&lt;br&gt;
&lt;h2&gt;




Current Status&lt;/h2&gt;
It has been a more than a year that I have been working on the ARM backend. Now it is in a shape, that we can measure meaningful numbers and also ask for some feedback. Since the &lt;a class="reference external" href="https://www.pypy.org/posts/2011/01/jit-backend-for-arm-processors-5994810755839586463.html"&gt;last post about the backend&lt;/a&gt; we have added support floating point operations as well as for PyPy's framework GC's. Another area of work was to keep up with the constant improvements done in the main development branch, such as out-of-line guards, labels, etc. It has been possible for about a year to cross-translate the PyPy Python interpreter and other interpreters such as &lt;a class="reference external" href="https://bitbucket.org/cfbolz/pyrolog/"&gt;Pyrolog&lt;/a&gt;, with a JIT, to run benchmarks on ARM. Up until now there remained some hard to track bugs that would cause the interpreter to crash with a segmentation fault in certain cases when running with the JIT on ARM. Lately it was possible to run all benchmarks without problems, but when running the translation toolchain itself it would crash. During the last PyPy sprint in &lt;a class="reference external" href="https://www.pypy.org/posts/2011/12/leysin-winter-sprint-6862532189897876336.html"&gt;Leysin&lt;/a&gt; Armin and I managed to fix several of these hard to track bugs in the ARM backend with the result that, it is now possible to run the PyPy translator on ARM itself (at least unless until it runs out of memory), which is a kind of litmus test for the backend itself and used to crash before. Just to point it out, we are not able to complete a PyPy translation on ARM, because on the hardware we have currently available there is not enough memory. But up to the point we run out of memory the JIT does not hit any issues.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="implementation-details"&gt;
&lt;h2&gt;




Implementation Details&lt;/h2&gt;
The hardware requirements to run the JIT on ARM follow those for Ubuntu on ARM which targets ARMv7 with a VFP unit running in little endian mode. The JIT can be translated without floating point support, but there might be a few places that need to be fixed to fully work in this setting. We are targeting the ARM instruction set, because at least at the time we decided to use it seemed to be the best choice in terms of speed while having some size overhead compared to the Thumb2 instruction set. It appears that the Thumb2 instruction set should give comparable speed with better code density but has a few restriction on the number of registers available and the use of conditional execution. Also the implementation is a bit easier using a fixed width instruction set and we can use the full set of registers in the generated code when using the ARM instruction set.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="the-calling-convention-on-arm"&gt;
&lt;h2&gt;




The calling convention on ARM&lt;/h2&gt;
The calling convention on ARM uses 4 of the general purpose registers to pass arguments to functions, further arguments are passed on the stack. The presence of a floating point unit is not required for ARM cores, for this reason there are different ways of handling floats with relation to the calling convention. There is a so called soft-float calling convention that is independent of the presence of a floating point unit. For this calling convention floating point arguments to functions are stored in the general purpose registers and on the stack. Passing floats around this way works with software and hardware floating point implementations. But in presence of a floating point unit it produces some overhead, because floating point numbers need to be moved from the floating point unit to the core registers to do a call and moved back to the floating point registers by the callee. The alternative calling convention is the so-called hard-float calling convention which requires the presence of a floating point unit but has the advantage of getting rid of the overhead of moving floating point values around when performing a call. Although it would be better in the long term to support the hard-float calling convention, we need to be able to interoperate with external code compiled for the operating system we are running on. For this reason at the moment we only support the soft-float to interoperate with external code. We implemented and tested the backend on a &lt;a class="reference external" href="https://beagleboard.org/hardware-xM/"&gt;BeagleBoard-xM&lt;/a&gt; with a &lt;a class="reference external" href="https://www.arm.com/products/processors/cortex-a/cortex-a8.php"&gt;Cortex-A8&lt;/a&gt; processor running &lt;a class="reference external" href="https://wiki.ubuntu.com/ARM"&gt;Ubuntu 11.04 for ARM&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="translating-for-arm"&gt;
&lt;h2&gt;




Translating for ARM&lt;/h2&gt;
The toolchain used to translate PyPy currently is based on a &lt;a class="reference external" href="https://maemo.gitorious.org/scratchbox2/pages/Home"&gt;Scratchbox2&lt;/a&gt;. Scratchbox2 is a cross-compiling environment. Development had stopped for a while, but it seems to have revived again. We run a 32-bit Python interpreter on the host system and perform all calls to the compiler using a Scratchbox2 based environment. A description on how to setup the cross translation toolchain can be found &lt;a class="reference external" href="https://bitbucket.org/pypy/pypy/src/1f07ea8076c9/pypy/doc/arm.rst"&gt;here&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
&lt;div class="section" id="results"&gt;
&lt;h2&gt;




Results&lt;/h2&gt;
The current results on ARM, as shown in the graph below, show that the JIT currently gives a speedup of about 3.5 times compared to CPython on ARM. The benchmarks were run on the before mentioned BeagleBoard-xM with a 1GHz ARM Cortex-A8 processor and 512MB of memory. The operating system on the board is Ubuntu 11.04 for ARM. We measured the PyPy interpreter with the JIT enabled and disabled comparing each to CPython Python 2.7.1+ (r271:86832) for ARM. The graph shows the speedup or slowdown of both PyPy versions for the different benchmarks from our benchmark suite normalized to the runtime of CPython. The data used for the graph can be seen below.&lt;br&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="https://2.bp.blogspot.com/-uckc9tOWgnM/TykHMuuGT9I/AAAAAAAAAKg/J8_fC6RS-QA/s1600/graph.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="258" src="https://2.bp.blogspot.com/-uckc9tOWgnM/TykHMuuGT9I/AAAAAAAAAKg/J8_fC6RS-QA/s400/graph.png" width="400"&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br&gt;
The speedup is less than the speedup of 5.2 times we currently  get on x86 on our own benchmark suite (see &lt;a class="reference external" href="https://speed.pypy.org/"&gt;https://speed.pypy.org&lt;/a&gt; for details). There are several possible reasons for this. Comparing the results for the interpreter without the JIT on ARM and x86 suggests that the interpreter generated by PyPy, without the JIT, has a worse performance when compared to CPython that it does on x86. Also it is quite possible that the code we are generating with the JIT is not yet optimal. Also there are some architectural constraints produce some overhead. One of these differences is the handling of constants, most ARM instructions only support 8 bit (that can be shifted) immediate values, larger constants need to be loaded into a register, something that is not necessary on x86.&lt;br&gt;
&lt;br&gt;
&lt;table border="1" class="docutils"&gt;&lt;colgroup&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="40%"&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="32%"&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width="28%"&gt;&lt;/colgroup&gt;&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Benchmark&lt;/td&gt;&lt;td&gt;PyPy JIT&lt;/td&gt;&lt;td&gt;PyPy no JIT&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ai&lt;/td&gt;&lt;td&gt;0.484439780047&lt;/td&gt;&lt;td&gt;3.72756749625&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;chaos&lt;/td&gt;&lt;td&gt;0.0807291691934&lt;/td&gt;&lt;td&gt;2.2908692212&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;crypto_pyaes&lt;/td&gt;&lt;td&gt;0.0711114832245&lt;/td&gt;&lt;td&gt;3.30112318509&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;django&lt;/td&gt;&lt;td&gt;0.0977743245519&lt;/td&gt;&lt;td&gt;2.56779947601&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;fannkuch&lt;/td&gt;&lt;td&gt;0.210423735698&lt;/td&gt;&lt;td&gt;2.49163632938&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;float&lt;/td&gt;&lt;td&gt;0.154275334675&lt;/td&gt;&lt;td&gt;2.12053281495&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;go&lt;/td&gt;&lt;td&gt;0.330483034202&lt;/td&gt;&lt;td&gt;5.84628320479&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;html5lib&lt;/td&gt;&lt;td&gt;0.629264389862&lt;/td&gt;&lt;td&gt;3.60333138526&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;meteor-contest&lt;/td&gt;&lt;td&gt;0.984747426912&lt;/td&gt;&lt;td&gt;2.93838610037&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;nbody_modified&lt;/td&gt;&lt;td&gt;0.236969593082&lt;/td&gt;&lt;td&gt;1.40027234936&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;pyflate-fast&lt;/td&gt;&lt;td&gt;0.367447191807&lt;/td&gt;&lt;td&gt;2.72472422146&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;raytrace-simple&lt;/td&gt;&lt;td&gt;0.0290527461437&lt;/td&gt;&lt;td&gt;1.97270054339&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;richards&lt;/td&gt;&lt;td&gt;0.034575573553&lt;/td&gt;&lt;td&gt;3.29767342015&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;slowspitfire&lt;/td&gt;&lt;td&gt;0.786642551908&lt;/td&gt;&lt;td&gt;3.7397367403&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spambayes&lt;/td&gt;&lt;td&gt;0.660324379456&lt;/td&gt;&lt;td&gt;3.29059863111&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spectral-norm&lt;/td&gt;&lt;td&gt;0.063610783731&lt;/td&gt;&lt;td&gt;4.01788986233&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spitfire&lt;/td&gt;&lt;td&gt;0.43617131165&lt;/td&gt;&lt;td&gt;2.72050579076&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;spitfire_cstringio&lt;/td&gt;&lt;td&gt;0.255538702134&lt;/td&gt;&lt;td&gt;1.7418593111&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;telco&lt;/td&gt;&lt;td&gt;0.102918930413&lt;/td&gt;&lt;td&gt;3.86388866047&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_iteration&lt;/td&gt;&lt;td&gt;0.122723986805&lt;/td&gt;&lt;td&gt;4.33632475491&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_names&lt;/td&gt;&lt;td&gt;2.42367797135&lt;/td&gt;&lt;td&gt;2.99878698076&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_pb&lt;/td&gt;&lt;td&gt;1.30991837431&lt;/td&gt;&lt;td&gt;4.48877805486&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;twisted_tcp&lt;/td&gt;&lt;td&gt;0.927033354055&lt;/td&gt;&lt;td&gt;2.8161624665&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;waf&lt;/td&gt;&lt;td&gt;1.02059811932&lt;/td&gt;&lt;td&gt;1.03793427321&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;div class="section" id="the-next-steps-and-call-for-help"&gt;
&lt;h2&gt;




The next steps and call for help&lt;/h2&gt;
Although there probably still are some remaining issues which have not surfaced yet, the JIT backend for ARM is working. Before we can merge the backend into the main development line there are some things that we would like to do first, in particular it we are looking for a way to run the all PyPy tests to verify that things work on ARM before we can merge. Additionally there are some other longterm ideas. To do this we are looking for people willing to help, either by contributing to implement the open features or that can help us with hardware to test.&lt;br&gt;
&lt;br&gt;
The incomplete list of open topics:&lt;br&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;We are looking for a better way to translate PyPy for ARM, than the one describe above. I am not sure if there currently is hardware with enough memory to directly translate PyPy on an ARM based system, this would require between 1.5 or 2 Gig of memory. A fully &lt;a class="reference external" href="https://wiki.qemu.org/Main_Page"&gt;QEMU&lt;/a&gt; based approach could also work, instead of Scratchbox2 that uses QEMU under the hood.&lt;/li&gt;
&lt;li&gt;Test the JIT on different hardware.&lt;/li&gt;
&lt;li&gt;Experiment with the JIT settings to find the optimal thresholds for ARM.&lt;/li&gt;
&lt;li&gt;Continuous integration: We are looking for a way to run the PyPy test suite to make sure everything works as expected on ARM, here QEMU also might provide an alternative.&lt;/li&gt;
&lt;li&gt;A long term plan would be to port the backend to ARMv5 ISA and improve the support for systems without a floating point unit. This would require to implement the ISA and create different code paths and improve the instruction selection depending on the target architecture.&lt;/li&gt;
&lt;li&gt;Review of the generated machine code the JIT generates on ARM to see if the instruction selection makes sense for ARM.&lt;/li&gt;
&lt;li&gt;Build a version that runs on Android.&lt;/li&gt;
&lt;li&gt;Improve the tools, i.e. integrate with &lt;a class="reference external" href="https://bitbucket.org/pypy/jitviewer"&gt;jitviewer&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
So if you are interested or willing to help in any way contact us.&lt;/div&gt;</description><category>arm</category><category>jit</category><category>pypy</category><guid>https://www.pypy.org/posts/2012/02/almost-there-pypys-arm-backend_01-3216759488618774525.html</guid><pubDate>Wed, 01 Feb 2012 09:43:00 GMT</pubDate></item><item><title>First pypy-cli-jit benchmarks</title><link>https://www.pypy.org/posts/2009/10/first-pypy-cli-jit-benchmarks-6698484455072589492.html</link><dc:creator>Antonio Cuni</dc:creator><description>&lt;p&gt;As the readers of this blog &lt;a class="reference external" href="https://www.pypy.org/posts/2008/11/porting-jit-to-cli-part-1-8712941279840156635.html"&gt;already know&lt;/a&gt;, I've been working on porting the
JIT to CLI/.NET for the last months.  Now that it's finally possible to get a
working pypy-cli-jit, it's time to do some benchmarks.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; as usual, all of this has to be considered to be a alpha version:
don't be surprised if you get a crash when trying to run pypy-cli-jit.  Of
course, things are improving very quickly so it should become more and more
stable as days pass.&lt;/p&gt;
&lt;p&gt;For this time, I decided to run four benchmarks. Note that for all of them we
run the main function once in advance, to let the JIT recognize the hot
loops and emitting the corresponding code.  Thus, the results reported do
&lt;strong&gt;not&lt;/strong&gt; include the time spent by the JIT compiler itself, but give a good
measure of how good is the code generated by the JIT.  At this point in time,
I know that the CLI JIT backend spends way too much time compiling stuff, but
this issue will be fixed soon.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://paste.pocoo.org/show/145050/"&gt;f1.py&lt;/a&gt;: this is the classic PyPy JIT benchmark. It is just a function
that does some computational intensive work with integers.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://paste.pocoo.org/show/143243/"&gt;floatdemo.py&lt;/a&gt;: this is the same benchmark involving floating point
numbers that have already been described in a previous &lt;a class="reference external" href="https://www.pypy.org/posts/2009/10/pypys-jit-now-supports-floats-7003493323596806737.html"&gt;blog post&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://paste.pocoo.org/show/145051/"&gt;oodemo.py&lt;/a&gt;: this is just a microbenchmark doing object oriented stuff
such as method calls and attribute access.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://paste.pocoo.org/show/145052/"&gt;richards2.py&lt;/a&gt;: a modified version of the classic richards.py, with a
warmup call before starting the real benchmark.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;The benchmarks were run on a Windows machine with an Intel Pentium Dual Core
E5200 2.5GHz and 2GB RAM, both with .NET (CLR 2.0) and Mono 2.4.2.3.&lt;/p&gt;
&lt;p&gt;Because of a known &lt;a class="reference external" href="https://bugzilla.novell.com/show_bug.cgi?id=474718"&gt;mono bug&lt;/a&gt;, if you use a version older than 2.1 you need
to pass the option &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O=-branch&lt;/span&gt;&lt;/tt&gt; to mono when running pypy-cli-jit, else it
will just loop forever.&lt;/p&gt;
&lt;p&gt;For comparison, we also run the same benchmarks with IronPython 2.0.1 and
IronPython 2.6rc1.  Note that IronPython 2.6rc1 does not work with mono.&lt;/p&gt;
&lt;p&gt;So, here are the results (expressed in seconds) with Microsoft CLR:&lt;/p&gt;
&lt;blockquote&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="15%"&gt;
&lt;col width="20%"&gt;
&lt;col width="15%"&gt;
&lt;col width="12%"&gt;
&lt;col width="20%"&gt;
&lt;col width="18%"&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Benchmark&lt;/th&gt;
&lt;th class="head"&gt;pypy-cli-jit&lt;/th&gt;
&lt;th class="head"&gt;ipy 2.0.1&lt;/th&gt;
&lt;th class="head"&gt;ipy 2.6&lt;/th&gt;
&lt;th class="head"&gt;ipy2.01/ pypy&lt;/th&gt;
&lt;th class="head"&gt;ipy2.6/ pypy&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;f1&lt;/td&gt;
&lt;td&gt;0.028&lt;/td&gt;
&lt;td&gt;0.145&lt;/td&gt;
&lt;td&gt;0.136&lt;/td&gt;
&lt;td&gt;5.18x&lt;/td&gt;
&lt;td&gt;4.85x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;floatdemo&lt;/td&gt;
&lt;td&gt;0.671&lt;/td&gt;
&lt;td&gt;0.765&lt;/td&gt;
&lt;td&gt;0.812&lt;/td&gt;
&lt;td&gt;1.14x&lt;/td&gt;
&lt;td&gt;1.21x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;oodemo&lt;/td&gt;
&lt;td&gt;1.25&lt;/td&gt;
&lt;td&gt;4.278&lt;/td&gt;
&lt;td&gt;3.816&lt;/td&gt;
&lt;td&gt;3.42x&lt;/td&gt;
&lt;td&gt;3.05x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;richards2&lt;/td&gt;
&lt;td&gt;1228&lt;/td&gt;
&lt;td&gt;442&lt;/td&gt;
&lt;td&gt;670&lt;/td&gt;
&lt;td&gt;0.36x&lt;/td&gt;
&lt;td&gt;0.54x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;p&gt;And with Mono:&lt;/p&gt;
&lt;blockquote&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="21%"&gt;
&lt;col width="29%"&gt;
&lt;col width="21%"&gt;
&lt;col width="29%"&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Benchmark&lt;/th&gt;
&lt;th class="head"&gt;pypy-cli-jit&lt;/th&gt;
&lt;th class="head"&gt;ipy 2.0.1&lt;/th&gt;
&lt;th class="head"&gt;ipy2.01/ pypy&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;f1&lt;/td&gt;
&lt;td&gt;0.042&lt;/td&gt;
&lt;td&gt;0.695&lt;/td&gt;
&lt;td&gt;16.54x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;floatdemo&lt;/td&gt;
&lt;td&gt;0.781&lt;/td&gt;
&lt;td&gt;1.218&lt;/td&gt;
&lt;td&gt;1.55x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;oodemo&lt;/td&gt;
&lt;td&gt;1.703&lt;/td&gt;
&lt;td&gt;9.501&lt;/td&gt;
&lt;td&gt;5.31x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;richards2&lt;/td&gt;
&lt;td&gt;720&lt;/td&gt;
&lt;td&gt;862&lt;/td&gt;
&lt;td&gt;1.20x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;p&gt;These results are very interesting: under the CLR, we are between 5x faster
and 3x slower than IronPython 2.0.1, and between 4.8x faster and 1.8x slower
than IronPython 2.6.  On the other hand, on mono we are consistently faster
than IronPython, up to 16x.  Also, it is also interesting to note that
pypy-cli runs faster on CLR than mono for all benchmarks except richards2.&lt;/p&gt;
&lt;p&gt;I've not investigated yet, but I think that the culprit is the terrible
behaviour of tail calls on CLR: as I already wrote in &lt;a class="reference external" href="https://www.pypy.org/posts/2008/12/porting-jit-to-cli-part-3-3519327524638923621.html"&gt;another blog post&lt;/a&gt;,
tail calls are ~10x slower than normal calls on CLR, while being only ~2x
slower than normal calls on mono.  richads2 is probably the benchmark that
makes most use of tail calls, thus explaining why we have a much better result
on mono than CLR.&lt;/p&gt;
&lt;p&gt;The next step is probably to find an alternative implementation that does not
use tail calls: this probably will also improve the time spent by the JIT
compiler itself, which is not reported in the numbers above but that so far it
is surely too high to be acceptable. Stay tuned.&lt;/p&gt;</description><category>cli</category><category>jit</category><category>pypy</category><guid>https://www.pypy.org/posts/2009/10/first-pypy-cli-jit-benchmarks-6698484455072589492.html</guid><pubDate>Thu, 15 Oct 2009 13:36:00 GMT</pubDate></item><item><title>Roadmap for JIT</title><link>https://www.pypy.org/posts/2009/04/roadmap-for-jit-377358891902851723.html</link><dc:creator>Maciej Fijalkowski</dc:creator><description>&lt;p&gt;Hello.
&lt;/p&gt;
&lt;p&gt;
First a disclaimer. This post is more about plans for future than current
status. We usually try to write about things that we have done, because
it's much much easier to promise things than to actually make it happen,
but I think it's important enough to have some sort of roadmap.
&lt;/p&gt;
&lt;p&gt;
In recent months we came to the point where the 5th generation of
JIT prototype was working as &lt;a href="https://www.pypy.org/posts/2009/03/good-news-everyone-421421336094214242.html"&gt;nice&lt;/a&gt;
or even a bit nicer than 1st one back in 2007. Someone might ask "so why
did you spend all this time without going forward?". And indeed, we spend
a lot of time moving sideways, but as posted, we also spent a lot of time
doing &lt;a href="https://www.pypy.org/posts/2009/04/beta-for-110-released-4604559533184706699.html"&gt;some other things&lt;/a&gt;, which are important as well.
The main advantage of current JIT incarnation is much much simpler than
the first one. Even I can comprehend it, which is much of an improvement :-)
&lt;/p&gt;
&lt;p&gt;
So, the prototype is working and gives very nice speedups in range of 20-30x
over CPython. We're pretty confident this prototype will work and will
produce fast python interpreter eventually. So we decided that now we'll
work towards changing prototype into something stable and solid. This
might sound easy, but in fact it's not. Having stable assembler backend
and optimizations that keep semantics is not as easy as it might sound.
&lt;/p&gt;
&lt;p&gt;
The current roadmap, as I see it, looks like as following:
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; Provide a JIT that does not speedup things, but produce assembler without
  optimizations turned on, that is correct and able to run CPython's library
  tests on a nightly basis.
&lt;/li&gt;
&lt;li&gt;
 Introduce simple optimizations, that should make above JIT a bit faster than
  CPython. With optimizations disabled JIT is producing incredibly dumb
  assembler, which is slower than correspoding C code, even with removal
  of interpretation overhead (which is not very surprising).
&lt;/li&gt;
&lt;li&gt;
 Backport optimizations from JIT prototype, one by one, keeping an eye
  on how they perform and making sure they don't break anything.
&lt;/li&gt;
&lt;li&gt;
 Create new optimizations, like speeding up attribute access.
&lt;/li&gt;
&lt;li&gt;
 Profit.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
This way, we can hopefully provide a working JIT, which gives fast python
interpreter, which is a bit harder than just a nice prototype.
&lt;/p&gt;
&lt;p&gt;
Tell us what you think about this plan.
&lt;/p&gt;
Cheers,&lt;br&gt;
fijal &amp;amp; others.</description><category>jit</category><category>pypy</category><category>roadmap</category><category>speed</category><guid>https://www.pypy.org/posts/2009/04/roadmap-for-jit-377358891902851723.html</guid><pubDate>Tue, 21 Apr 2009 19:38:00 GMT</pubDate></item><item><title>EP2008: PyPy meets Jython</title><link>https://www.pypy.org/posts/2008/07/ep2008-pypy-meets-jython-1107070144380217881.html</link><dc:creator>holger krekel</dc:creator><description>&lt;p&gt;One of the great events at EuroPython 2008 were our chats and meetings with the Jython and Sun people.  The Jython people recently are pushing into releasing Python version 2.5 and they currently pursue many interesting sub projects.  Coincidentally, PyPy also has tons of interesting areas and results :)  So we eventually got into brainstorming a number of possible technical collab ideas.  Further below is a first list as i wrote it down from our 10 people PyPy / Jython 30 minute close up meeting yesterday.

It felt great to be able to talk to the Jython people this way - kudos to Sun for their clear commitments and open ways to go about things!  I sense a genuine interest on fair collaboration with non-java developer communities.  Seems like they are serious about not focusing on "Java this", "Java that" anymore  but rather focus on the JVM platform.  Good!  And about language
independent interest in ambitious technology. Even Better!  I am tensed to see how things go from here.

So here the list of technical collab ideas:
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;ctypes - try to create _rawffi module in Java for Jython, which will enable Jython to reuse our existing ctypes implementation (and have PyPy use the Jython-rawffi for its own for PyPy.JVM)&lt;/li&gt;&lt;li&gt; generally see to share work / (continue) collaborate regarding extension modules&lt;/li&gt;&lt;li&gt;Jython/PyPy (and eventually IronPython): document known differences to CPython, maybe in a PEP&lt;/li&gt;&lt;li&gt;Python Interpreter for Jython (in order to run CPython's .pyc files): re-use pypy's bytecode evaluator, implement a "Jython object space". &lt;/li&gt;&lt;li&gt;re-use rpython-extension modules for jython (e.g. SRE), by compiling them to Java and reusing as a native library.&lt;/li&gt;&lt;li&gt;collaborate on testing framework / benchmarking, have a common site to show test results&lt;/li&gt;&lt;li&gt;make py.test compatible with jython&lt;/li&gt;&lt;li&gt;come up with a set of "pure Python language" tests, which would gather and refactor tests from CPython, PyPy and Jython. &lt;/li&gt;&lt;li&gt;look into using java types / jython approaches for implementing free threading.&lt;/li&gt;&lt;li&gt;share knowledge regarding JIT / psyco
&lt;/li&gt;&lt;/ul&gt;If you have any more ideas, comments or would like to join efforts, let us know!

Cheers and thanks to &lt;a href="https://www.sauria.com/blog/"&gt;Ted Leung&lt;/a&gt;, &lt;a href="https://fwierzbicki.blogspot.com/"&gt;Frank Wierzbiki&lt;/a&gt;, &lt;a href="https://www.zyasoft.com/pythoneering/"&gt;Jim Baker&lt;/a&gt; and Tobias Ivarsson from Sun and Jython fame respectively,

Holger</description><category>ep2008</category><category>jython</category><category>pypy</category><category>sun</category><guid>https://www.pypy.org/posts/2008/07/ep2008-pypy-meets-jython-1107070144380217881.html</guid><pubDate>Thu, 10 Jul 2008 08:29:00 GMT</pubDate></item></channel></rss>